{
 "all": {
  "become": {
   "ansible.builtin.runas": {
    "doc": {
     "author": "ansible (@core)",
     "collection": "ansible.builtin",
     "description": [
      "This become plugin allows your remote/login user to execute commands as another user via the windows runas facility."
     ],
     "filename": "/ansible/plugins/become/runas.py",
     "name": "runas",
     "notes": [
      "runas is really implemented in the powershell module handler and as such can only be used with winrm connections.",
      "This plugin ignores the 'become_exe' setting as it uses an API and not an executable.",
      "The Secondary Logon service (seclogon) must be running to use runas"
     ],
     "options": {
      "become_flags": {
       "default": "",
       "description": "Options to pass to runas, a space delimited list of k=v pairs",
       "env": [
        {
         "name": "ANSIBLE_BECOME_FLAGS"
        },
        {
         "name": "ANSIBLE_RUNAS_FLAGS"
        }
       ],
       "ini": [
        {
         "key": "become_flags",
         "section": "privilege_escalation"
        },
        {
         "key": "flags",
         "section": "runas_become_plugin"
        }
       ],
       "keyword": [
        {
         "name": "become_flags"
        }
       ],
       "vars": [
        {
         "name": "ansible_become_flags"
        },
        {
         "name": "ansible_runas_flags"
        }
       ]
      },
      "become_pass": {
       "description": "password",
       "env": [
        {
         "name": "ANSIBLE_BECOME_PASS"
        },
        {
         "name": "ANSIBLE_RUNAS_PASS"
        }
       ],
       "ini": [
        {
         "key": "password",
         "section": "runas_become_plugin"
        }
       ],
       "vars": [
        {
         "name": "ansible_become_password"
        },
        {
         "name": "ansible_become_pass"
        },
        {
         "name": "ansible_runas_pass"
        }
       ]
      },
      "become_user": {
       "description": "User you 'become' to execute the task",
       "env": [
        {
         "name": "ANSIBLE_BECOME_USER"
        },
        {
         "name": "ANSIBLE_RUNAS_USER"
        }
       ],
       "ini": [
        {
         "key": "become_user",
         "section": "privilege_escalation"
        },
        {
         "key": "user",
         "section": "runas_become_plugin"
        }
       ],
       "keyword": [
        {
         "name": "become_user"
        }
       ],
       "required": true,
       "vars": [
        {
         "name": "ansible_become_user"
        },
        {
         "name": "ansible_runas_user"
        }
       ]
      }
     },
     "short_description": "Run As user",
     "version_added": "2.8",
     "version_added_collection": "ansible.builtin"
    },
    "examples": null,
    "metadata": null,
    "return": null
   },
   "ansible.builtin.su": {
    "doc": {
     "author": "ansible (@core)",
     "collection": "ansible.builtin",
     "description": [
      "This become plugin allows your remote/login user to execute commands as another user via the su utility."
     ],
     "filename": "/ansible/plugins/become/su.py",
     "name": "su",
     "options": {
      "become_exe": {
       "default": "su",
       "description": "Su executable",
       "env": [
        {
         "name": "ANSIBLE_BECOME_EXE"
        },
        {
         "name": "ANSIBLE_SU_EXE"
        }
       ],
       "ini": [
        {
         "key": "become_exe",
         "section": "privilege_escalation"
        },
        {
         "key": "executable",
         "section": "su_become_plugin"
        }
       ],
       "keyword": [
        {
         "name": "become_exe"
        }
       ],
       "vars": [
        {
         "name": "ansible_become_exe"
        },
        {
         "name": "ansible_su_exe"
        }
       ]
      },
      "become_flags": {
       "default": "",
       "description": "Options to pass to su",
       "env": [
        {
         "name": "ANSIBLE_BECOME_FLAGS"
        },
        {
         "name": "ANSIBLE_SU_FLAGS"
        }
       ],
       "ini": [
        {
         "key": "become_flags",
         "section": "privilege_escalation"
        },
        {
         "key": "flags",
         "section": "su_become_plugin"
        }
       ],
       "keyword": [
        {
         "name": "become_flags"
        }
       ],
       "vars": [
        {
         "name": "ansible_become_flags"
        },
        {
         "name": "ansible_su_flags"
        }
       ]
      },
      "become_pass": {
       "description": "Password to pass to su",
       "env": [
        {
         "name": "ANSIBLE_BECOME_PASS"
        },
        {
         "name": "ANSIBLE_SU_PASS"
        }
       ],
       "ini": [
        {
         "key": "password",
         "section": "su_become_plugin"
        }
       ],
       "required": false,
       "vars": [
        {
         "name": "ansible_become_password"
        },
        {
         "name": "ansible_become_pass"
        },
        {
         "name": "ansible_su_pass"
        }
       ]
      },
      "become_user": {
       "default": "root",
       "description": "User you 'become' to execute the task",
       "env": [
        {
         "name": "ANSIBLE_BECOME_USER"
        },
        {
         "name": "ANSIBLE_SU_USER"
        }
       ],
       "ini": [
        {
         "key": "become_user",
         "section": "privilege_escalation"
        },
        {
         "key": "user",
         "section": "su_become_plugin"
        }
       ],
       "keyword": [
        {
         "name": "become_user"
        }
       ],
       "vars": [
        {
         "name": "ansible_become_user"
        },
        {
         "name": "ansible_su_user"
        }
       ]
      },
      "prompt_l10n": {
       "default": [],
       "description": [
        "List of localized strings to match for prompt detection",
        "If empty we'll use the built in one",
        "Do NOT add a colon (:) to your custom entries. Ansible adds a colon at the end of each prompt; if you add another one in your string, your prompt will fail with a \"Timeout\" error."
       ],
       "elements": "string",
       "env": [
        {
         "name": "ANSIBLE_SU_PROMPT_L10N"
        }
       ],
       "ini": [
        {
         "key": "localized_prompts",
         "section": "su_become_plugin"
        }
       ],
       "type": "list",
       "vars": [
        {
         "name": "ansible_su_prompt_l10n"
        }
       ]
      }
     },
     "short_description": "Substitute User",
     "version_added": "2.8",
     "version_added_collection": "ansible.builtin"
    },
    "examples": null,
    "metadata": null,
    "return": null
   },
   "ansible.builtin.sudo": {
    "doc": {
     "author": "ansible (@core)",
     "collection": "ansible.builtin",
     "description": [
      "This become plugin allows your remote/login user to execute commands as another user via the sudo utility."
     ],
     "filename": "/ansible/plugins/become/sudo.py",
     "name": "sudo",
     "options": {
      "become_exe": {
       "default": "sudo",
       "description": "Sudo executable",
       "env": [
        {
         "name": "ANSIBLE_BECOME_EXE"
        },
        {
         "name": "ANSIBLE_SUDO_EXE"
        }
       ],
       "ini": [
        {
         "key": "become_exe",
         "section": "privilege_escalation"
        },
        {
         "key": "executable",
         "section": "sudo_become_plugin"
        }
       ],
       "keyword": [
        {
         "name": "become_exe"
        }
       ],
       "vars": [
        {
         "name": "ansible_become_exe"
        },
        {
         "name": "ansible_sudo_exe"
        }
       ]
      },
      "become_flags": {
       "default": "-H -S -n",
       "description": "Options to pass to sudo",
       "env": [
        {
         "name": "ANSIBLE_BECOME_FLAGS"
        },
        {
         "name": "ANSIBLE_SUDO_FLAGS"
        }
       ],
       "ini": [
        {
         "key": "become_flags",
         "section": "privilege_escalation"
        },
        {
         "key": "flags",
         "section": "sudo_become_plugin"
        }
       ],
       "keyword": [
        {
         "name": "become_flags"
        }
       ],
       "vars": [
        {
         "name": "ansible_become_flags"
        },
        {
         "name": "ansible_sudo_flags"
        }
       ]
      },
      "become_pass": {
       "description": "Password to pass to sudo",
       "env": [
        {
         "name": "ANSIBLE_BECOME_PASS"
        },
        {
         "name": "ANSIBLE_SUDO_PASS"
        }
       ],
       "ini": [
        {
         "key": "password",
         "section": "sudo_become_plugin"
        }
       ],
       "required": false,
       "vars": [
        {
         "name": "ansible_become_password"
        },
        {
         "name": "ansible_become_pass"
        },
        {
         "name": "ansible_sudo_pass"
        }
       ]
      },
      "become_user": {
       "default": "root",
       "description": "User you 'become' to execute the task",
       "env": [
        {
         "name": "ANSIBLE_BECOME_USER"
        },
        {
         "name": "ANSIBLE_SUDO_USER"
        }
       ],
       "ini": [
        {
         "key": "become_user",
         "section": "privilege_escalation"
        },
        {
         "key": "user",
         "section": "sudo_become_plugin"
        }
       ],
       "keyword": [
        {
         "name": "become_user"
        }
       ],
       "vars": [
        {
         "name": "ansible_become_user"
        },
        {
         "name": "ansible_sudo_user"
        }
       ]
      }
     },
     "short_description": "Substitute User DO",
     "version_added": "2.8",
     "version_added_collection": "ansible.builtin"
    },
    "examples": null,
    "metadata": null,
    "return": null
   },
   "ns2.col.foo": {
    "doc": {
     "author": "Nobody (!UNKNOWN)",
     "collection": "ns2.col",
     "deprecated": {
      "alternatives": "I don't know\nof any\nalternative.\n",
      "removed_from_collection": "ns2.col",
      "removed_in": "5.0.0",
      "why": "Just some text.\nThis one has more than one line.\nAnd one more.\n"
     },
     "description": [
      "This become plugin uses foo.",
      "This is a second paragraph."
     ],
     "filename": "ansible_collections/ns2/col/plugins/become/foo.py",
     "name": "foo",
     "options": {
      "bar": {
       "deprecated": {
        "alternatives": "nothing\nrelevant\nI know of\n",
        "collection_name": "ns2.col",
        "version": "4.0.0",
        "why": "Just some other text.\nThis one has more than one line though.\nOne more.\n"
       },
       "description": [
        "Bar. B(BAR!)",
        "Totally unrelated to O(become_user). Even with O(become_user=foo).",
        "Might not be compatible when O(become_user) is V(bar), though."
       ],
       "type": "str",
       "version_added": "1.2.0",
       "version_added_collection": "ns2.col"
      },
      "become_exe": {
       "default": "foo",
       "description": "Foo executable.",
       "env": [
        {
         "name": "ANSIBLE_BECOME_EXE"
        },
        {
         "deprecated": {
          "alternatives": "nothing",
          "collection_name": "ns2.col",
          "version": "3.0.0",
          "why": "Just some text."
         },
         "name": "ANSIBLE_FOO_EXE"
        }
       ],
       "ini": [
        {
         "key": "become_exe",
         "section": "privilege_escalation"
        },
        {
         "deprecated": {
          "alternatives": "nothing",
          "collection_name": "ns2.col",
          "version": "3.0.0",
          "why": "Just some text."
         },
         "key": "executable",
         "section": "foo_become_plugin"
        }
       ],
       "keyword": [
        {
         "name": "become_exe"
        }
       ],
       "vars": [
        {
         "name": "ansible_become_exe"
        },
        {
         "deprecated": {
          "alternatives": "nothing",
          "collection_name": "ns2.col",
          "version": "3.0.0",
          "why": "Just some text."
         },
         "name": "ansible_foo_exe"
        }
       ],
       "version_added": "0.2.0",
       "version_added_collection": "ns2.col"
      },
      "become_user": {
       "default": "root",
       "description": "User you 'become' to execute the task.",
       "env": [
        {
         "name": "ANSIBLE_BECOME_USER",
         "version_added": "0.1.0",
         "version_added_collection": "ns2.col"
        },
        {
         "name": "ANSIBLE_FOO_USER"
        }
       ],
       "ini": [
        {
         "key": "become_user",
         "section": "privilege_escalation",
         "version_added": "0.1.0",
         "version_added_collection": "ns2.col"
        },
        {
         "key": "user",
         "section": "foo_become_plugin"
        }
       ],
       "keyword": [
        {
         "name": "become_user",
         "version_added": "0.1.0"
        }
       ],
       "vars": [
        {
         "name": "ansible_become_user"
        },
        {
         "name": "ansible_foo_user",
         "version_added": "0.1.0",
         "version_added_collection": "ns2.col"
        }
       ]
      }
     },
     "short_description": "Use foo O(bar)",
     "version_added": "historical",
     "version_added_collection": "ns2.col"
    },
    "examples": null,
    "metadata": null,
    "return": null
   }
  },
  "cache": {
   "ansible.builtin.jsonfile": {
    "doc": {
     "author": "Ansible Core (@ansible-core)",
     "collection": "ansible.builtin",
     "description": [
      "This cache uses JSON formatted, per host, files saved to the filesystem."
     ],
     "filename": "/ansible/plugins/cache/jsonfile.py",
     "name": "jsonfile",
     "options": {
      "_prefix": {
       "description": "User defined prefix to use when creating the JSON files",
       "env": [
        {
         "name": "ANSIBLE_CACHE_PLUGIN_PREFIX"
        }
       ],
       "ini": [
        {
         "key": "fact_caching_prefix",
         "section": "defaults"
        }
       ]
      },
      "_timeout": {
       "default": 86400,
       "description": "Expiration timeout for the cache plugin data",
       "env": [
        {
         "name": "ANSIBLE_CACHE_PLUGIN_TIMEOUT"
        }
       ],
       "ini": [
        {
         "key": "fact_caching_timeout",
         "section": "defaults"
        }
       ],
       "type": "integer"
      },
      "_uri": {
       "description": [
        "Path in which the cache plugin will save the JSON files"
       ],
       "env": [
        {
         "name": "ANSIBLE_CACHE_PLUGIN_CONNECTION"
        }
       ],
       "ini": [
        {
         "key": "fact_caching_connection",
         "section": "defaults"
        }
       ],
       "required": true,
       "type": "path"
      }
     },
     "short_description": "JSON formatted files.",
     "version_added": "1.9",
     "version_added_collection": "ansible.builtin"
    },
    "examples": null,
    "metadata": null,
    "return": null
   },
   "ansible.builtin.memory": {
    "doc": {
     "author": "core team (@ansible-core)",
     "collection": "ansible.builtin",
     "description": [
      "RAM backed cache that is not persistent.",
      "This is the default used if no other plugin is specified.",
      "There are no options to configure."
     ],
     "filename": "/ansible/plugins/cache/memory.py",
     "name": "memory",
     "short_description": "RAM backed, non persistent",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": null,
    "metadata": null,
    "return": null
   },
   "ns2.col.foo": {
    "doc": {
     "author": "Ansible Core (@ansible-core)",
     "collection": "ns2.col",
     "description": [
      "Cache foo files."
     ],
     "filename": "ansible_collections/ns2/col/plugins/cache/foo.py",
     "name": "foo",
     "options": {
      "_uri": {
       "description": [
        "Path in which the cache plugin will save the foo files."
       ],
       "env": [
        {
         "name": "ANSIBLE_CACHE_PLUGIN_CONNECTION"
        }
       ],
       "ini": [
        {
         "key": "fact_caching_connection",
         "section": "defaults"
        }
       ],
       "required": true,
       "type": "path"
      },
      "bar": {
       "description": "Nothing.",
       "type": "str"
      }
     },
     "short_description": "Foo files O(bar)",
     "version_added": "1.9.0",
     "version_added_collection": "ns2.col"
    },
    "examples": null,
    "metadata": null,
    "return": null
   }
  },
  "callback": {
   "ansible.builtin.default": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "This is the default output callback for ansible-playbook."
     ],
     "filename": "/ansible/plugins/callback/default.py",
     "name": "default",
     "options": {
      "check_mode_markers": {
       "default": false,
       "description": [
        "Toggle to control displaying markers when running in check mode.",
        "The markers are C(DRY RUN) at the beginning and ending of playbook execution (when calling C(ansible-playbook --check)) and C(CHECK MODE) as a suffix at every play and task that is run in check mode."
       ],
       "env": [
        {
         "name": "ANSIBLE_CHECK_MODE_MARKERS"
        }
       ],
       "ini": [
        {
         "key": "check_mode_markers",
         "section": "defaults"
        }
       ],
       "name": "Show markers when running in check mode",
       "type": "bool",
       "version_added": "2.9",
       "version_added_collection": "ansible.builtin"
      },
      "display_failed_stderr": {
       "default": false,
       "description": "Toggle to control whether failed and unreachable tasks are displayed to STDERR (vs. STDOUT)",
       "env": [
        {
         "name": "ANSIBLE_DISPLAY_FAILED_STDERR"
        }
       ],
       "ini": [
        {
         "key": "display_failed_stderr",
         "section": "defaults"
        }
       ],
       "name": "Use STDERR for failed and unreachable tasks",
       "type": "bool",
       "version_added": "2.7",
       "version_added_collection": "ansible.builtin"
      },
      "display_ok_hosts": {
       "default": true,
       "description": "Toggle to control displaying 'ok' task/host results in a task",
       "env": [
        {
         "name": "ANSIBLE_DISPLAY_OK_HOSTS"
        }
       ],
       "ini": [
        {
         "key": "display_ok_hosts",
         "section": "defaults"
        }
       ],
       "name": "Show 'ok' hosts",
       "type": "bool",
       "version_added": "2.7",
       "version_added_collection": "ansible.builtin"
      },
      "display_skipped_hosts": {
       "default": true,
       "description": "Toggle to control displaying skipped task/host results in a task",
       "env": [
        {
         "name": "ANSIBLE_DISPLAY_SKIPPED_HOSTS"
        }
       ],
       "ini": [
        {
         "key": "display_skipped_hosts",
         "section": "defaults"
        }
       ],
       "name": "Show skipped hosts",
       "type": "bool"
      },
      "pretty_results": {
       "default": null,
       "description": [
        "Configure the result format to be more readable",
        "When O(result_format) is set to V(yaml) this option defaults to V(True), and defaults to V(False) when configured to V(json).",
        "Setting this option to V(True) will force V(json) and V(yaml) results to always be pretty printed regardless of verbosity.",
        "When set to V(True) and used with the V(yaml) result format, this option will modify module responses in an attempt to produce a more human friendly output at the expense of correctness, and should not be relied upon to aid in writing variable manipulations or conditionals. For correctness, set this option to V(False) or set O(result_format) to V(json)."
       ],
       "env": [
        {
         "name": "ANSIBLE_CALLBACK_FORMAT_PRETTY"
        }
       ],
       "ini": [
        {
         "key": "callback_format_pretty",
         "section": "defaults"
        }
       ],
       "name": "Configure output for readability",
       "type": "bool",
       "version_added": "2.13",
       "version_added_collection": "ansible.builtin"
      },
      "result_format": {
       "choices": [
        "json",
        "yaml"
       ],
       "default": "json",
       "description": [
        "Define the task result format used in the callback output.",
        "These formats do not cause the callback to emit valid JSON or YAML formats.",
        "The output contains these formats interspersed with other non-machine parsable data."
       ],
       "env": [
        {
         "name": "ANSIBLE_CALLBACK_RESULT_FORMAT"
        }
       ],
       "ini": [
        {
         "key": "callback_result_format",
         "section": "defaults"
        }
       ],
       "name": "Format of the task result",
       "type": "str",
       "version_added": "2.13",
       "version_added_collection": "ansible.builtin"
      },
      "show_custom_stats": {
       "default": false,
       "description": "This adds the custom stats set via the set_stats plugin to the play recap",
       "env": [
        {
         "name": "ANSIBLE_SHOW_CUSTOM_STATS"
        }
       ],
       "ini": [
        {
         "key": "show_custom_stats",
         "section": "defaults"
        }
       ],
       "name": "Show custom stats",
       "type": "bool"
      },
      "show_per_host_start": {
       "default": false,
       "description": "This adds output that shows when a task is started to execute for each host",
       "env": [
        {
         "name": "ANSIBLE_SHOW_PER_HOST_START"
        }
       ],
       "ini": [
        {
         "key": "show_per_host_start",
         "section": "defaults"
        }
       ],
       "name": "Show per host task start",
       "type": "bool",
       "version_added": "2.9",
       "version_added_collection": "ansible.builtin"
      },
      "show_task_path_on_failure": {
       "default": false,
       "description": "When a task fails, display the path to the file containing the failed task and the line number. This information is displayed automatically for every task when running with C(-vv) or greater verbosity.",
       "env": [
        {
         "name": "ANSIBLE_SHOW_TASK_PATH_ON_FAILURE"
        }
       ],
       "ini": [
        {
         "key": "show_task_path_on_failure",
         "section": "defaults"
        }
       ],
       "name": "Show file path on failed tasks",
       "type": "bool",
       "version_added": "2.11",
       "version_added_collection": "ansible.builtin"
      }
     },
     "requirements": [
      "set as stdout in configuration"
     ],
     "short_description": "default Ansible screen output",
     "type": "stdout",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": null,
    "metadata": null,
    "return": null
   },
   "ansible.builtin.junit": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "This callback writes playbook output to a JUnit formatted XML file.",
      "Tasks show up in the report as follows: 'ok': pass 'failed' with 'EXPECTED FAILURE' in the task name: pass 'failed' with 'TOGGLE RESULT' in the task name: pass 'ok' with 'TOGGLE RESULT' in the task name: failure 'failed' due to an exception: error 'failed' for other reasons: failure 'skipped': skipped"
     ],
     "filename": "/ansible/plugins/callback/junit.py",
     "name": "junit",
     "options": {
      "fail_on_change": {
       "default": false,
       "description": "Consider any tasks reporting \"changed\" as a junit test failure",
       "env": [
        {
         "name": "JUNIT_FAIL_ON_CHANGE"
        }
       ],
       "name": "JUnit fail on change"
      },
      "fail_on_ignore": {
       "default": false,
       "description": "Consider failed tasks as a junit test failure even if ignore_on_error is set",
       "env": [
        {
         "name": "JUNIT_FAIL_ON_IGNORE"
        }
       ],
       "name": "JUnit fail on ignore"
      },
      "hide_task_arguments": {
       "default": false,
       "description": "Hide the arguments for a task",
       "env": [
        {
         "name": "JUNIT_HIDE_TASK_ARGUMENTS"
        }
       ],
       "name": "Hide the arguments for a task",
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      },
      "include_setup_tasks_in_report": {
       "default": true,
       "description": "Should the setup tasks be included in the final report",
       "env": [
        {
         "name": "JUNIT_INCLUDE_SETUP_TASKS_IN_REPORT"
        }
       ],
       "name": "JUnit include setup tasks in report"
      },
      "output_dir": {
       "default": "~/.ansible.log",
       "description": "Directory to write XML files to.",
       "env": [
        {
         "name": "JUNIT_OUTPUT_DIR"
        }
       ],
       "name": "JUnit output dir"
      },
      "replace_out_of_tree_path": {
       "default": "none",
       "description": "Replace the directory portion of an out-of-tree relative task path with the given placeholder",
       "env": [
        {
         "name": "JUNIT_REPLACE_OUT_OF_TREE_PATH"
        }
       ],
       "name": "Replace out of tree path",
       "version_added": "2.12.3",
       "version_added_collection": "ansible.builtin"
      },
      "task_class": {
       "default": false,
       "description": "Configure the output to be one class per yaml file",
       "env": [
        {
         "name": "JUNIT_TASK_CLASS"
        }
       ],
       "name": "JUnit Task class"
      },
      "task_relative_path": {
       "default": "none",
       "description": "Configure the output to use relative paths to given directory",
       "env": [
        {
         "name": "JUNIT_TASK_RELATIVE_PATH"
        }
       ],
       "name": "JUnit Task relative path",
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      },
      "test_case_prefix": {
       "default": "<empty>",
       "description": "Consider a task only as test case if it has this value as prefix. Additionally failing tasks are recorded as failed test cases.",
       "env": [
        {
         "name": "JUNIT_TEST_CASE_PREFIX"
        }
       ],
       "name": "Prefix to find actual test cases",
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      }
     },
     "requirements": [
      "enable in configuration"
     ],
     "short_description": "write playbook output to a JUnit file.",
     "type": "aggregate",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": null,
    "metadata": null,
    "return": null
   },
   "ansible.builtin.minimal": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "This is the default output callback used by the ansible command (ad-hoc)"
     ],
     "filename": "/ansible/plugins/callback/minimal.py",
     "name": "minimal",
     "options": {
      "pretty_results": {
       "default": null,
       "description": [
        "Configure the result format to be more readable",
        "When O(result_format) is set to V(yaml) this option defaults to V(True), and defaults to V(False) when configured to V(json).",
        "Setting this option to V(True) will force V(json) and V(yaml) results to always be pretty printed regardless of verbosity.",
        "When set to V(True) and used with the V(yaml) result format, this option will modify module responses in an attempt to produce a more human friendly output at the expense of correctness, and should not be relied upon to aid in writing variable manipulations or conditionals. For correctness, set this option to V(False) or set O(result_format) to V(json)."
       ],
       "env": [
        {
         "name": "ANSIBLE_CALLBACK_FORMAT_PRETTY"
        }
       ],
       "ini": [
        {
         "key": "callback_format_pretty",
         "section": "defaults"
        }
       ],
       "name": "Configure output for readability",
       "type": "bool",
       "version_added": "2.13",
       "version_added_collection": "ansible.builtin"
      },
      "result_format": {
       "choices": [
        "json",
        "yaml"
       ],
       "default": "json",
       "description": [
        "Define the task result format used in the callback output.",
        "These formats do not cause the callback to emit valid JSON or YAML formats.",
        "The output contains these formats interspersed with other non-machine parsable data."
       ],
       "env": [
        {
         "name": "ANSIBLE_CALLBACK_RESULT_FORMAT"
        }
       ],
       "ini": [
        {
         "key": "callback_result_format",
         "section": "defaults"
        }
       ],
       "name": "Format of the task result",
       "type": "str",
       "version_added": "2.13",
       "version_added_collection": "ansible.builtin"
      }
     },
     "short_description": "minimal Ansible screen output",
     "type": "stdout",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": null,
    "metadata": null,
    "return": null
   },
   "ansible.builtin.oneline": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "This is the output callback used by the C(-o)/C(--one-line) command line option."
     ],
     "filename": "/ansible/plugins/callback/oneline.py",
     "name": "oneline",
     "short_description": "oneline Ansible screen output",
     "type": "stdout",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": null,
    "metadata": null,
    "return": null
   },
   "ansible.builtin.tree": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "This callback is used by the Ansible (adhoc) command line option C(-t|--tree).",
      "This produces a JSON dump of events in a directory, a file for each host, the directory used MUST be passed as a command line option."
     ],
     "filename": "/ansible/plugins/callback/tree.py",
     "name": "tree",
     "options": {
      "directory": {
       "default": "~/.ansible/tree",
       "description": "directory that will contain the per host JSON files. Also set by the C(--tree) option when using adhoc.",
       "env": [
        {
         "name": "ANSIBLE_CALLBACK_TREE_DIR"
        }
       ],
       "ini": [
        {
         "key": "directory",
         "section": "callback_tree"
        }
       ],
       "type": "path",
       "version_added": "2.11",
       "version_added_collection": "ansible.builtin"
      }
     },
     "requirements": [
      "invoked in the command line"
     ],
     "short_description": "Save host events to files",
     "type": "notification",
     "version_added": "2.0",
     "version_added_collection": "ansible.builtin"
    },
    "examples": null,
    "metadata": null,
    "return": null
   },
   "ns2.col.foo": {
    "doc": {
     "collection": "ns2.col",
     "description": [
      "Absolut minimal foo output."
     ],
     "filename": "ansible_collections/ns2/col/plugins/callback/foo.py",
     "name": "foo",
     "options": {
      "bar": {
       "description": "Nothing.",
       "type": "string"
      }
     },
     "short_description": "Foo output O(bar)",
     "type": "stdout",
     "version_added": "0.0.1",
     "version_added_collection": "ns2.col"
    },
    "examples": null,
    "metadata": null,
    "return": null
   }
  },
  "cliconf": {
   "ns2.col.foo": {
    "doc": {
     "author": "Felix Fontein (@felixfontein) <felix@fontein.de>",
     "collection": "ns2.col",
     "description": [
      "This is a CLI config for foo routers. Whatever these are."
     ],
     "filename": "ansible_collections/ns2/col/plugins/cliconf/foo.py",
     "name": "foo",
     "short_description": "Foo router CLI config"
    },
    "examples": null,
    "metadata": null,
    "return": null
   }
  },
  "connection": {
   "ansible.builtin.local": {
    "doc": {
     "author": "ansible (@core)",
     "collection": "ansible.builtin",
     "description": [
      "This connection plugin allows ansible to execute tasks on the Ansible 'controller' instead of on a remote host."
     ],
     "filename": "/ansible/plugins/connection/local.py",
     "name": "local",
     "notes": [
      "The remote user is ignored, the user with which the ansible CLI was executed is used instead."
     ],
     "options": {
      "pipelining": {
       "default": false,
       "description": [
        "Pipelining reduces the number of connection operations required to execute a module on the remote server, by executing many Ansible modules without actual file transfers.",
        "This can result in a very significant performance improvement when enabled.",
        "However this can conflict with privilege escalation (become). For example, when using sudo operations you must first disable 'requiretty' in the sudoers file for the target hosts, which is why this feature is disabled by default."
       ],
       "env": [
        {
         "name": "ANSIBLE_PIPELINING"
        }
       ],
       "ini": [
        {
         "key": "pipelining",
         "section": "defaults"
        },
        {
         "key": "pipelining",
         "section": "connection"
        }
       ],
       "type": "boolean",
       "vars": [
        {
         "name": "ansible_pipelining"
        }
       ]
      }
     },
     "short_description": "execute on controller",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": null,
    "metadata": null,
    "return": null
   },
   "ansible.builtin.paramiko_ssh": {
    "doc": {
     "author": "Ansible Core Team",
     "collection": "ansible.builtin",
     "description": [
      "Use the Python SSH implementation (Paramiko) to connect to targets",
      "The paramiko transport is provided because many distributions, in particular EL6 and before do not support ControlPersist in their SSH implementations.",
      "This is needed on the Ansible control machine to be reasonably efficient with connections. Thus paramiko is faster for most users on these platforms. Users with ControlPersist capability can consider using -c ssh or configuring the transport in the configuration file.",
      "This plugin also borrows a lot of settings from the ssh plugin as they both cover the same protocol."
     ],
     "filename": "/ansible/plugins/connection/paramiko_ssh.py",
     "name": "paramiko",
     "options": {
      "banner_timeout": {
       "default": 30,
       "description": [
        "Configures, in seconds, the amount of time to wait for the SSH banner to be presented. This option is supported by paramiko version 1.15.0 or newer."
       ],
       "env": [
        {
         "name": "ANSIBLE_PARAMIKO_BANNER_TIMEOUT"
        }
       ],
       "ini": [
        {
         "key": "banner_timeout",
         "section": "paramiko_connection"
        }
       ],
       "type": "float",
       "version_added": "2.14",
       "version_added_collection": "ansible.builtin"
      },
      "host_key_auto_add": {
       "description": "Automatically add host keys",
       "env": [
        {
         "name": "ANSIBLE_PARAMIKO_HOST_KEY_AUTO_ADD"
        }
       ],
       "ini": [
        {
         "key": "host_key_auto_add",
         "section": "paramiko_connection"
        }
       ],
       "type": "boolean"
      },
      "host_key_checking": {
       "default": true,
       "description": "Set this to \"False\" if you want to avoid host key checking by the underlying tools Ansible uses to connect to the host",
       "env": [
        {
         "name": "ANSIBLE_HOST_KEY_CHECKING"
        },
        {
         "name": "ANSIBLE_SSH_HOST_KEY_CHECKING",
         "version_added": "2.5",
         "version_added_collection": "ansible.builtin"
        },
        {
         "name": "ANSIBLE_PARAMIKO_HOST_KEY_CHECKING",
         "version_added": "2.5",
         "version_added_collection": "ansible.builtin"
        }
       ],
       "ini": [
        {
         "key": "host_key_checking",
         "section": "defaults"
        },
        {
         "key": "host_key_checking",
         "section": "paramiko_connection",
         "version_added": "2.5",
         "version_added_collection": "ansible.builtin"
        }
       ],
       "type": "boolean",
       "vars": [
        {
         "name": "ansible_host_key_checking",
         "version_added": "2.5",
         "version_added_collection": "ansible.builtin"
        },
        {
         "name": "ansible_ssh_host_key_checking",
         "version_added": "2.5",
         "version_added_collection": "ansible.builtin"
        },
        {
         "name": "ansible_paramiko_host_key_checking",
         "version_added": "2.5",
         "version_added_collection": "ansible.builtin"
        }
       ]
      },
      "look_for_keys": {
       "default": true,
       "description": "False to disable searching for private key files in ~/.ssh/",
       "env": [
        {
         "name": "ANSIBLE_PARAMIKO_LOOK_FOR_KEYS"
        }
       ],
       "ini": [
        {
         "key": "look_for_keys",
         "section": "paramiko_connection"
        }
       ],
       "type": "boolean"
      },
      "password": {
       "description": [
        "Secret used to either login the ssh server or as a passphrase for ssh keys that require it",
        "Can be set from the CLI via the C(--ask-pass) option."
       ],
       "type": "string",
       "vars": [
        {
         "name": "ansible_password"
        },
        {
         "name": "ansible_ssh_pass"
        },
        {
         "name": "ansible_ssh_password"
        },
        {
         "name": "ansible_paramiko_pass"
        },
        {
         "name": "ansible_paramiko_password",
         "version_added": "2.5",
         "version_added_collection": "ansible.builtin"
        }
       ]
      },
      "port": {
       "default": 22,
       "description": "Remote port to connect to.",
       "env": [
        {
         "name": "ANSIBLE_REMOTE_PORT"
        },
        {
         "name": "ANSIBLE_REMOTE_PARAMIKO_PORT",
         "version_added": "2.15",
         "version_added_collection": "ansible.builtin"
        }
       ],
       "ini": [
        {
         "key": "remote_port",
         "section": "defaults"
        },
        {
         "key": "remote_port",
         "section": "paramiko_connection",
         "version_added": "2.15",
         "version_added_collection": "ansible.builtin"
        }
       ],
       "keyword": [
        {
         "name": "port"
        }
       ],
       "type": "int",
       "vars": [
        {
         "name": "ansible_port"
        },
        {
         "name": "ansible_ssh_port"
        },
        {
         "name": "ansible_paramiko_port",
         "version_added": "2.15",
         "version_added_collection": "ansible.builtin"
        }
       ]
      },
      "private_key_file": {
       "cli": [
        {
         "name": "private_key_file",
         "option": "--private-key"
        }
       ],
       "description": [
        "Path to private key file to use for authentication."
       ],
       "env": [
        {
         "name": "ANSIBLE_PRIVATE_KEY_FILE"
        },
        {
         "name": "ANSIBLE_PARAMIKO_PRIVATE_KEY_FILE",
         "version_added": "2.15",
         "version_added_collection": "ansible.builtin"
        }
       ],
       "ini": [
        {
         "key": "private_key_file",
         "section": "defaults"
        },
        {
         "key": "private_key_file",
         "section": "paramiko_connection",
         "version_added": "2.15",
         "version_added_collection": "ansible.builtin"
        }
       ],
       "type": "string",
       "vars": [
        {
         "name": "ansible_private_key_file"
        },
        {
         "name": "ansible_ssh_private_key_file"
        },
        {
         "name": "ansible_paramiko_private_key_file",
         "version_added": "2.15",
         "version_added_collection": "ansible.builtin"
        }
       ]
      },
      "proxy_command": {
       "default": "",
       "description": [
        "Proxy information for running the connection via a jumphost",
        "Also this plugin will scan 'ssh_args', 'ssh_extra_args' and 'ssh_common_args' from the 'ssh' plugin settings for proxy information if set."
       ],
       "env": [
        {
         "name": "ANSIBLE_PARAMIKO_PROXY_COMMAND"
        }
       ],
       "ini": [
        {
         "key": "proxy_command",
         "section": "paramiko_connection"
        }
       ],
       "type": "string",
       "vars": [
        {
         "name": "ansible_paramiko_proxy_command",
         "version_added": "2.15",
         "version_added_collection": "ansible.builtin"
        }
       ]
      },
      "pty": {
       "default": true,
       "description": "SUDO usually requires a PTY, True to give a PTY and False to not give a PTY.",
       "env": [
        {
         "name": "ANSIBLE_PARAMIKO_PTY"
        }
       ],
       "ini": [
        {
         "key": "pty",
         "section": "paramiko_connection"
        }
       ],
       "type": "boolean"
      },
      "record_host_keys": {
       "default": true,
       "description": "Save the host keys to a file",
       "env": [
        {
         "name": "ANSIBLE_PARAMIKO_RECORD_HOST_KEYS"
        }
       ],
       "ini": [
        {
         "key": "record_host_keys",
         "section": "paramiko_connection"
        }
       ],
       "type": "boolean"
      },
      "remote_addr": {
       "default": "inventory_hostname",
       "description": [
        "Address of the remote target"
       ],
       "type": "string",
       "vars": [
        {
         "name": "inventory_hostname"
        },
        {
         "name": "ansible_host"
        },
        {
         "name": "ansible_ssh_host"
        },
        {
         "name": "ansible_paramiko_host"
        }
       ]
      },
      "remote_user": {
       "description": [
        "User to login/authenticate as",
        "Can be set from the CLI via the C(--user) or C(-u) options."
       ],
       "env": [
        {
         "name": "ANSIBLE_REMOTE_USER"
        },
        {
         "name": "ANSIBLE_PARAMIKO_REMOTE_USER",
         "version_added": "2.5",
         "version_added_collection": "ansible.builtin"
        }
       ],
       "ini": [
        {
         "key": "remote_user",
         "section": "defaults"
        },
        {
         "key": "remote_user",
         "section": "paramiko_connection",
         "version_added": "2.5",
         "version_added_collection": "ansible.builtin"
        }
       ],
       "keyword": [
        {
         "name": "remote_user"
        }
       ],
       "type": "string",
       "vars": [
        {
         "name": "ansible_user"
        },
        {
         "name": "ansible_ssh_user"
        },
        {
         "name": "ansible_paramiko_user"
        }
       ]
      },
      "ssh_args": {
       "default": "",
       "deprecated": {
        "alternatives": "proxy_command",
        "collection_name": "ansible.builtin",
        "version": "2.18",
        "why": "In favor of the \"proxy_command\" option."
       },
       "description": "Only used in parsing ProxyCommand for use in this plugin.",
       "env": [
        {
         "name": "ANSIBLE_SSH_ARGS"
        }
       ],
       "ini": [
        {
         "key": "ssh_args",
         "section": "ssh_connection"
        }
       ],
       "type": "string",
       "vars": [
        {
         "name": "ansible_ssh_args",
         "version_added": "2.7",
         "version_added_collection": "ansible.builtin"
        }
       ]
      },
      "ssh_common_args": {
       "cli": [
        {
         "name": "ssh_common_args"
        }
       ],
       "default": "",
       "deprecated": {
        "alternatives": "proxy_command",
        "collection_name": "ansible.builtin",
        "version": "2.18",
        "why": "In favor of the \"proxy_command\" option."
       },
       "description": "Only used in parsing ProxyCommand for use in this plugin.",
       "env": [
        {
         "name": "ANSIBLE_SSH_COMMON_ARGS",
         "version_added": "2.7",
         "version_added_collection": "ansible.builtin"
        }
       ],
       "ini": [
        {
         "key": "ssh_common_args",
         "section": "ssh_connection",
         "version_added": "2.7",
         "version_added_collection": "ansible.builtin"
        }
       ],
       "type": "string",
       "vars": [
        {
         "name": "ansible_ssh_common_args"
        }
       ]
      },
      "ssh_extra_args": {
       "cli": [
        {
         "name": "ssh_extra_args"
        }
       ],
       "default": "",
       "deprecated": {
        "alternatives": "proxy_command",
        "collection_name": "ansible.builtin",
        "version": "2.18",
        "why": "In favor of the \"proxy_command\" option."
       },
       "description": "Only used in parsing ProxyCommand for use in this plugin.",
       "env": [
        {
         "name": "ANSIBLE_SSH_EXTRA_ARGS",
         "version_added": "2.7",
         "version_added_collection": "ansible.builtin"
        }
       ],
       "ini": [
        {
         "key": "ssh_extra_args",
         "section": "ssh_connection",
         "version_added": "2.7",
         "version_added_collection": "ansible.builtin"
        }
       ],
       "type": "string",
       "vars": [
        {
         "name": "ansible_ssh_extra_args"
        }
       ]
      },
      "timeout": {
       "cli": [
        {
         "name": "timeout"
        }
       ],
       "default": 10,
       "description": "Number of seconds until the plugin gives up on failing to establish a TCP connection.",
       "env": [
        {
         "name": "ANSIBLE_TIMEOUT"
        },
        {
         "name": "ANSIBLE_SSH_TIMEOUT",
         "version_added": "2.11",
         "version_added_collection": "ansible.builtin"
        },
        {
         "name": "ANSIBLE_PARAMIKO_TIMEOUT",
         "version_added": "2.15",
         "version_added_collection": "ansible.builtin"
        }
       ],
       "ini": [
        {
         "key": "timeout",
         "section": "defaults"
        },
        {
         "key": "timeout",
         "section": "ssh_connection",
         "version_added": "2.11",
         "version_added_collection": "ansible.builtin"
        },
        {
         "key": "timeout",
         "section": "paramiko_connection",
         "version_added": "2.15",
         "version_added_collection": "ansible.builtin"
        }
       ],
       "type": "int",
       "vars": [
        {
         "name": "ansible_ssh_timeout",
         "version_added": "2.11",
         "version_added_collection": "ansible.builtin"
        },
        {
         "name": "ansible_paramiko_timeout",
         "version_added": "2.15",
         "version_added_collection": "ansible.builtin"
        }
       ]
      },
      "use_persistent_connections": {
       "default": false,
       "description": "Toggles the use of persistence for connections",
       "env": [
        {
         "name": "ANSIBLE_USE_PERSISTENT_CONNECTIONS"
        }
       ],
       "ini": [
        {
         "key": "use_persistent_connections",
         "section": "defaults"
        }
       ],
       "type": "boolean"
      },
      "use_rsa_sha2_algorithms": {
       "default": true,
       "description": [
        "Whether or not to enable RSA SHA2 algorithms for pubkeys and hostkeys",
        "On paramiko versions older than 2.9, this only affects hostkeys",
        "For behavior matching paramiko<2.9 set this to V(False)"
       ],
       "env": [
        {
         "name": "ANSIBLE_PARAMIKO_USE_RSA_SHA2_ALGORITHMS"
        }
       ],
       "ini": [
        {
         "key": "use_rsa_sha2_algorithms",
         "section": "paramiko_connection"
        }
       ],
       "type": "boolean",
       "vars": [
        {
         "name": "ansible_paramiko_use_rsa_sha2_algorithms"
        }
       ],
       "version_added": "2.14",
       "version_added_collection": "ansible.builtin"
      }
     },
     "short_description": "Run tasks via Python SSH (paramiko)",
     "version_added": "0.1",
     "version_added_collection": "ansible.builtin"
    },
    "examples": null,
    "metadata": null,
    "return": null
   },
   "ansible.builtin.psrp": {
    "doc": {
     "author": "Ansible Core Team",
     "collection": "ansible.builtin",
     "description": [
      "Run commands or put/fetch on a target via PSRP (WinRM plugin)",
      "This is similar to the P(ansible.builtin.winrm#connection) connection plugin which uses the same underlying transport but instead runs in a PowerShell interpreter."
     ],
     "filename": "/ansible/plugins/connection/psrp.py",
     "name": "psrp",
     "options": {
      "auth": {
       "choices": [
        "basic",
        "certificate",
        "negotiate",
        "kerberos",
        "ntlm",
        "credssp"
       ],
       "default": "negotiate",
       "description": [
        "The authentication protocol to use when authenticating the remote user.",
        "The default, V(negotiate), will attempt to use Kerberos (V(kerberos)) if it is available and fall back to NTLM (V(ntlm)) if it isn't."
       ],
       "type": "str",
       "vars": [
        {
         "name": "ansible_psrp_auth"
        }
       ]
      },
      "ca_cert": {
       "aliases": [
        "cert_trust_path"
       ],
       "description": [
        "The path to a PEM certificate chain to use when validating the server's certificate.",
        "This value is ignored if O(cert_validation) is set to V(ignore)."
       ],
       "type": "path",
       "vars": [
        {
         "name": "ansible_psrp_cert_trust_path"
        },
        {
         "name": "ansible_psrp_ca_cert"
        }
       ]
      },
      "cert_validation": {
       "choices": [
        "validate",
        "ignore"
       ],
       "default": "validate",
       "description": [
        "Whether to validate the remote server's certificate or not.",
        "Set to V(ignore) to not validate any certificates.",
        "O(ca_cert) can be set to the path of a PEM certificate chain to use in the validation."
       ],
       "type": "str",
       "vars": [
        {
         "name": "ansible_psrp_cert_validation"
        }
       ]
      },
      "certificate_key_pem": {
       "description": [
        "The local path to an X509 certificate key to use with certificate auth."
       ],
       "type": "path",
       "vars": [
        {
         "name": "ansible_psrp_certificate_key_pem"
        }
       ]
      },
      "certificate_pem": {
       "description": [
        "The local path to an X509 certificate to use with certificate auth."
       ],
       "type": "path",
       "vars": [
        {
         "name": "ansible_psrp_certificate_pem"
        }
       ]
      },
      "configuration_name": {
       "default": "Microsoft.PowerShell",
       "description": [
        "The name of the PowerShell configuration endpoint to connect to."
       ],
       "type": "str",
       "vars": [
        {
         "name": "ansible_psrp_configuration_name"
        }
       ]
      },
      "connection_timeout": {
       "default": 30,
       "description": [
        "The connection timeout for making the request to the remote host.",
        "This is measured in seconds."
       ],
       "type": "int",
       "vars": [
        {
         "name": "ansible_psrp_connection_timeout"
        }
       ]
      },
      "credssp_auth_mechanism": {
       "choices": [
        "auto",
        "kerberos",
        "ntlm"
       ],
       "default": "auto",
       "description": [
        "The sub authentication mechanism to use with CredSSP auth.",
        "When V(auto), both Kerberos and NTLM is attempted with kerberos being preferred."
       ],
       "type": "str",
       "vars": [
        {
         "name": "ansible_psrp_credssp_auth_mechanism"
        }
       ]
      },
      "credssp_disable_tlsv1_2": {
       "default": false,
       "description": [
        "Disables the use of TLSv1.2 on the CredSSP authentication channel.",
        "This should not be set to V(yes) unless dealing with a host that does not have TLSv1.2."
       ],
       "type": "bool",
       "vars": [
        {
         "name": "ansible_psrp_credssp_disable_tlsv1_2"
        }
       ]
      },
      "credssp_minimum_version": {
       "default": 2,
       "description": [
        "The minimum CredSSP server authentication version that will be accepted.",
        "Set to V(5) to ensure the server has been patched and is not vulnerable to CVE 2018-0886."
       ],
       "type": "int",
       "vars": [
        {
         "name": "ansible_psrp_credssp_minimum_version"
        }
       ]
      },
      "ignore_proxy": {
       "default": false,
       "description": [
        "Will disable any environment proxy settings and connect directly to the remote host.",
        "This option is ignored if O(proxy) is set."
       ],
       "type": "bool",
       "vars": [
        {
         "name": "ansible_psrp_ignore_proxy"
        }
       ]
      },
      "max_envelope_size": {
       "default": 153600,
       "description": [
        "Sets the maximum size of each WSMan message sent to the remote host.",
        "This is measured in bytes.",
        "Defaults to C(150KiB) for compatibility with older hosts."
       ],
       "type": "int",
       "vars": [
        {
         "name": "ansible_psrp_max_envelope_size"
        }
       ]
      },
      "message_encryption": {
       "choices": [
        "auto",
        "always",
        "never"
       ],
       "default": "auto",
       "description": [
        "Controls the message encryption settings, this is different from TLS encryption when O(protocol) is V(https).",
        "Only the auth protocols V(negotiate), V(kerberos), V(ntlm), and V(credssp) can do message encryption. The other authentication protocols only support encryption when V(protocol) is set to V(https).",
        "V(auto) means means message encryption is only used when not using TLS/HTTPS.",
        "V(always) is the same as V(auto) but message encryption is always used even when running over TLS/HTTPS.",
        "V(never) disables any encryption checks that are in place when running over HTTP and disables any authentication encryption processes."
       ],
       "type": "str",
       "vars": [
        {
         "name": "ansible_psrp_message_encryption"
        }
       ]
      },
      "negotiate_delegate": {
       "description": [
        "Allow the remote user the ability to delegate it's credentials to another server, i.e. credential delegation.",
        "Only valid when Kerberos was the negotiated auth or was explicitly set as the authentication.",
        "Ignored when NTLM was the negotiated auth."
       ],
       "type": "bool",
       "vars": [
        {
         "name": "ansible_psrp_negotiate_delegate"
        }
       ]
      },
      "negotiate_hostname_override": {
       "description": [
        "Override the remote hostname when searching for the host in the Kerberos lookup.",
        "This allows Ansible to connect over IP but authenticate with the remote server using it's DNS name.",
        "Only valid when Kerberos was the negotiated auth or was explicitly set as the authentication.",
        "Ignored when NTLM was the negotiated auth."
       ],
       "type": "str",
       "vars": [
        {
         "name": "ansible_psrp_negotiate_hostname_override"
        }
       ]
      },
      "negotiate_send_cbt": {
       "default": true,
       "description": [
        "Send the Channel Binding Token (CBT) structure when authenticating.",
        "CBT is used to provide extra protection against Man in the Middle C(MitM) attacks by binding the outer transport channel to the auth channel.",
        "CBT is not used when using just C(HTTP), only C(HTTPS)."
       ],
       "type": "bool",
       "vars": [
        {
         "name": "ansible_psrp_negotiate_send_cbt"
        }
       ]
      },
      "negotiate_service": {
       "default": "WSMAN",
       "description": [
        "Override the service part of the SPN used during Kerberos authentication.",
        "Only valid when Kerberos was the negotiated auth or was explicitly set as the authentication.",
        "Ignored when NTLM was the negotiated auth."
       ],
       "type": "str",
       "vars": [
        {
         "name": "ansible_psrp_negotiate_service"
        }
       ]
      },
      "operation_timeout": {
       "default": 20,
       "description": [
        "Sets the WSMan timeout for each operation.",
        "This is measured in seconds.",
        "This should not exceed the value for O(connection_timeout)."
       ],
       "type": "int",
       "vars": [
        {
         "name": "ansible_psrp_operation_timeout"
        }
       ]
      },
      "path": {
       "default": "wsman",
       "description": [
        "The URI path to connect to."
       ],
       "type": "str",
       "vars": [
        {
         "name": "ansible_psrp_path"
        }
       ]
      },
      "pipelining": {
       "default": false,
       "description": [
        "Pipelining reduces the number of connection operations required to execute a module on the remote server, by executing many Ansible modules without actual file transfers.",
        "This can result in a very significant performance improvement when enabled.",
        "However this can conflict with privilege escalation (become). For example, when using sudo operations you must first disable 'requiretty' in the sudoers file for the target hosts, which is why this feature is disabled by default."
       ],
       "env": [
        {
         "name": "ANSIBLE_PIPELINING"
        }
       ],
       "ini": [
        {
         "key": "pipelining",
         "section": "defaults"
        },
        {
         "key": "pipelining",
         "section": "connection"
        }
       ],
       "type": "boolean",
       "vars": [
        {
         "name": "ansible_pipelining"
        }
       ]
      },
      "port": {
       "description": [
        "The port for PSRP to connect on the remote target.",
        "Default is V(5986) if O(protocol) is not defined or is V(https), otherwise the port is V(5985)."
       ],
       "keyword": [
        {
         "name": "port"
        }
       ],
       "type": "int",
       "vars": [
        {
         "name": "ansible_port"
        },
        {
         "name": "ansible_psrp_port"
        }
       ]
      },
      "protocol": {
       "choices": [
        "http",
        "https"
       ],
       "description": [
        "Set the protocol to use for the connection.",
        "Default is V(https) if O(port) is not defined or O(port) is not V(5985)."
       ],
       "type": "str",
       "vars": [
        {
         "name": "ansible_psrp_protocol"
        }
       ]
      },
      "proxy": {
       "description": [
        "Set the proxy URL to use when connecting to the remote host."
       ],
       "type": "str",
       "vars": [
        {
         "name": "ansible_psrp_proxy"
        }
       ]
      },
      "read_timeout": {
       "default": 30,
       "description": [
        "The read timeout for receiving data from the remote host.",
        "This value must always be greater than O(operation_timeout).",
        "This option requires pypsrp >= 0.3.",
        "This is measured in seconds."
       ],
       "type": "int",
       "vars": [
        {
         "name": "ansible_psrp_read_timeout"
        }
       ],
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      },
      "reconnection_backoff": {
       "default": 2,
       "description": [
        "The backoff time to use in between reconnection attempts. (First sleeps X, then sleeps 2*X, then sleeps 4*X, ...)",
        "This is measured in seconds.",
        "The C(ansible_psrp_reconnection_backoff) variable was added in Ansible 2.9."
       ],
       "type": "int",
       "vars": [
        {
         "name": "ansible_psrp_connection_backoff"
        },
        {
         "name": "ansible_psrp_reconnection_backoff"
        }
       ],
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      },
      "reconnection_retries": {
       "default": 0,
       "description": [
        "The number of retries on connection errors."
       ],
       "type": "int",
       "vars": [
        {
         "name": "ansible_psrp_reconnection_retries"
        }
       ],
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      },
      "remote_addr": {
       "default": "inventory_hostname",
       "description": [
        "The hostname or IP address of the remote host."
       ],
       "type": "str",
       "vars": [
        {
         "name": "inventory_hostname"
        },
        {
         "name": "ansible_host"
        },
        {
         "name": "ansible_psrp_host"
        }
       ]
      },
      "remote_password": {
       "aliases": [
        "password"
       ],
       "description": "Authentication password for the O(remote_user). Can be supplied as CLI option.",
       "type": "str",
       "vars": [
        {
         "name": "ansible_password"
        },
        {
         "name": "ansible_winrm_pass"
        },
        {
         "name": "ansible_winrm_password"
        }
       ]
      },
      "remote_user": {
       "description": [
        "The user to log in as."
       ],
       "keyword": [
        {
         "name": "remote_user"
        }
       ],
       "type": "str",
       "vars": [
        {
         "name": "ansible_user"
        },
        {
         "name": "ansible_psrp_user"
        }
       ]
      }
     },
     "requirements": [
      "pypsrp>=0.4.0 (Python library)"
     ],
     "short_description": "Run tasks over Microsoft PowerShell Remoting Protocol",
     "version_added": "2.7",
     "version_added_collection": "ansible.builtin"
    },
    "examples": null,
    "metadata": null,
    "return": null
   },
   "ansible.builtin.ssh": {
    "doc": {
     "author": "ansible (@core)",
     "collection": "ansible.builtin",
     "description": [
      "This connection plugin allows Ansible to communicate to the target machines through normal SSH command line.",
      "Ansible does not expose a channel to allow communication between the user and the SSH process to accept a password manually to decrypt an SSH key when using this connection plugin (which is the default). The use of C(ssh-agent) is highly recommended."
     ],
     "filename": "/ansible/plugins/connection/ssh.py",
     "name": "ssh",
     "notes": [
      "This plugin is mostly a wrapper to the ``ssh`` CLI utility and the exact behavior of the options depends on this tool. This means that the documentation provided here is subject to be overridden by the CLI tool itself.",
      "Many options default to V(None) here but that only means we do not override the SSH tool's defaults and/or configuration. For example, if you specify the port in this plugin it will override any C(Port) entry in your C(.ssh/config).",
      "The ssh CLI tool uses return code 255 as a 'connection error', this can conflict with commands/tools that also return 255 as an error code and will look like an 'unreachable' condition or 'connection error' to this plugin."
     ],
     "options": {
      "control_path": {
       "description": [
        "This is the location to save SSH's ControlPath sockets, it uses SSH's variable substitution.",
        "Since 2.3, if null (default), ansible will generate a unique hash. Use ``%(directory)s`` to indicate where to use the control dir path setting.",
        "Before 2.3 it defaulted to ``control_path=%(directory)s/ansible-ssh-%%h-%%p-%%r``.",
        "Be aware that this setting is ignored if C(-o ControlPath) is set in ssh args."
       ],
       "env": [
        {
         "name": "ANSIBLE_SSH_CONTROL_PATH"
        }
       ],
       "ini": [
        {
         "key": "control_path",
         "section": "ssh_connection"
        }
       ],
       "type": "string",
       "vars": [
        {
         "name": "ansible_control_path",
         "version_added": "2.7",
         "version_added_collection": "ansible.builtin"
        }
       ]
      },
      "control_path_dir": {
       "default": "~/.ansible/cp",
       "description": [
        "This sets the directory to use for ssh control path if the control path setting is null.",
        "Also, provides the ``%(directory)s`` variable for the control path setting."
       ],
       "env": [
        {
         "name": "ANSIBLE_SSH_CONTROL_PATH_DIR"
        }
       ],
       "ini": [
        {
         "key": "control_path_dir",
         "section": "ssh_connection"
        }
       ],
       "type": "string",
       "vars": [
        {
         "name": "ansible_control_path_dir",
         "version_added": "2.7",
         "version_added_collection": "ansible.builtin"
        }
       ]
      },
      "host": {
       "default": "inventory_hostname",
       "description": "Hostname/IP to connect to.",
       "type": "string",
       "vars": [
        {
         "name": "inventory_hostname"
        },
        {
         "name": "ansible_host"
        },
        {
         "name": "ansible_ssh_host"
        },
        {
         "name": "delegated_vars['ansible_host']"
        },
        {
         "name": "delegated_vars['ansible_ssh_host']"
        }
       ]
      },
      "host_key_checking": {
       "default": true,
       "description": "Determines if SSH should reject or not a connection after checking host keys.",
       "env": [
        {
         "name": "ANSIBLE_HOST_KEY_CHECKING"
        },
        {
         "name": "ANSIBLE_SSH_HOST_KEY_CHECKING",
         "version_added": "2.5",
         "version_added_collection": "ansible.builtin"
        }
       ],
       "ini": [
        {
         "key": "host_key_checking",
         "section": "defaults"
        },
        {
         "key": "host_key_checking",
         "section": "ssh_connection",
         "version_added": "2.5",
         "version_added_collection": "ansible.builtin"
        }
       ],
       "type": "boolean",
       "vars": [
        {
         "name": "ansible_host_key_checking",
         "version_added": "2.5",
         "version_added_collection": "ansible.builtin"
        },
        {
         "name": "ansible_ssh_host_key_checking",
         "version_added": "2.5",
         "version_added_collection": "ansible.builtin"
        }
       ]
      },
      "password": {
       "description": "Authentication password for the O(remote_user). Can be supplied as CLI option.",
       "type": "string",
       "vars": [
        {
         "name": "ansible_password"
        },
        {
         "name": "ansible_ssh_pass"
        },
        {
         "name": "ansible_ssh_password"
        }
       ]
      },
      "pipelining": {
       "default": false,
       "description": [
        "Pipelining reduces the number of connection operations required to execute a module on the remote server, by executing many Ansible modules without actual file transfers.",
        "This can result in a very significant performance improvement when enabled.",
        "However this can conflict with privilege escalation (become). For example, when using sudo operations you must first disable 'requiretty' in the sudoers file for the target hosts, which is why this feature is disabled by default."
       ],
       "env": [
        {
         "name": "ANSIBLE_PIPELINING"
        },
        {
         "name": "ANSIBLE_SSH_PIPELINING"
        }
       ],
       "ini": [
        {
         "key": "pipelining",
         "section": "defaults"
        },
        {
         "key": "pipelining",
         "section": "connection"
        },
        {
         "key": "pipelining",
         "section": "ssh_connection"
        }
       ],
       "type": "boolean",
       "vars": [
        {
         "name": "ansible_pipelining"
        },
        {
         "name": "ansible_ssh_pipelining"
        }
       ]
      },
      "pkcs11_provider": {
       "default": "",
       "description": [
        "PKCS11 SmartCard provider such as opensc, example: /usr/local/lib/opensc-pkcs11.so",
        "Requires sshpass version 1.06+, sshpass must support the -P option."
       ],
       "env": [
        {
         "name": "ANSIBLE_PKCS11_PROVIDER"
        }
       ],
       "ini": [
        {
         "key": "pkcs11_provider",
         "section": "ssh_connection"
        }
       ],
       "type": "string",
       "vars": [
        {
         "name": "ansible_ssh_pkcs11_provider"
        }
       ],
       "version_added": "2.12",
       "version_added_collection": "ansible.builtin"
      },
      "port": {
       "description": "Remote port to connect to.",
       "env": [
        {
         "name": "ANSIBLE_REMOTE_PORT"
        }
       ],
       "ini": [
        {
         "key": "remote_port",
         "section": "defaults"
        }
       ],
       "keyword": [
        {
         "name": "port"
        }
       ],
       "type": "int",
       "vars": [
        {
         "name": "ansible_port"
        },
        {
         "name": "ansible_ssh_port"
        }
       ]
      },
      "private_key_file": {
       "cli": [
        {
         "name": "private_key_file",
         "option": "--private-key"
        }
       ],
       "description": [
        "Path to private key file to use for authentication."
       ],
       "env": [
        {
         "name": "ANSIBLE_PRIVATE_KEY_FILE"
        }
       ],
       "ini": [
        {
         "key": "private_key_file",
         "section": "defaults"
        }
       ],
       "type": "string",
       "vars": [
        {
         "name": "ansible_private_key_file"
        },
        {
         "name": "ansible_ssh_private_key_file"
        }
       ]
      },
      "reconnection_retries": {
       "default": 0,
       "description": [
        "Number of attempts to connect.",
        "Ansible retries connections only if it gets an SSH error with a return code of 255.",
        "Any errors with return codes other than 255 indicate an issue with program execution."
       ],
       "env": [
        {
         "name": "ANSIBLE_SSH_RETRIES"
        }
       ],
       "ini": [
        {
         "key": "retries",
         "section": "connection"
        },
        {
         "key": "retries",
         "section": "ssh_connection"
        }
       ],
       "type": "integer",
       "vars": [
        {
         "name": "ansible_ssh_retries",
         "version_added": "2.7",
         "version_added_collection": "ansible.builtin"
        }
       ]
      },
      "remote_user": {
       "cli": [
        {
         "name": "user"
        }
       ],
       "description": [
        "User name with which to login to the remote server, normally set by the remote_user keyword.",
        "If no user is supplied, Ansible will let the SSH client binary choose the user as it normally."
       ],
       "env": [
        {
         "name": "ANSIBLE_REMOTE_USER"
        }
       ],
       "ini": [
        {
         "key": "remote_user",
         "section": "defaults"
        }
       ],
       "keyword": [
        {
         "name": "remote_user"
        }
       ],
       "type": "string",
       "vars": [
        {
         "name": "ansible_user"
        },
        {
         "name": "ansible_ssh_user"
        }
       ]
      },
      "scp_executable": {
       "default": "scp",
       "description": [
        "This defines the location of the scp binary. It defaults to V(scp) which will use the first binary available in $PATH."
       ],
       "env": [
        {
         "name": "ANSIBLE_SCP_EXECUTABLE"
        }
       ],
       "ini": [
        {
         "key": "scp_executable",
         "section": "ssh_connection"
        }
       ],
       "type": "string",
       "vars": [
        {
         "name": "ansible_scp_executable",
         "version_added": "2.7",
         "version_added_collection": "ansible.builtin"
        }
       ],
       "version_added": "2.6",
       "version_added_collection": "ansible.builtin"
      },
      "scp_extra_args": {
       "cli": [
        {
         "name": "scp_extra_args"
        }
       ],
       "default": "",
       "description": "Extra exclusive to the C(scp) CLI",
       "env": [
        {
         "name": "ANSIBLE_SCP_EXTRA_ARGS",
         "version_added": "2.7",
         "version_added_collection": "ansible.builtin"
        }
       ],
       "ini": [
        {
         "key": "scp_extra_args",
         "section": "ssh_connection",
         "version_added": "2.7",
         "version_added_collection": "ansible.builtin"
        }
       ],
       "type": "string",
       "vars": [
        {
         "name": "ansible_scp_extra_args"
        }
       ]
      },
      "scp_if_ssh": {
       "default": "smart",
       "deprecated": {
        "alternatives": "O(ssh_transfer_method)",
        "collection_name": "ansible.builtin",
        "version": "2.17",
        "why": "In favor of the O(ssh_transfer_method) option."
       },
       "description": [
        "Preferred method to use when transferring files over SSH.",
        "When set to V(smart), Ansible will try them until one succeeds or they all fail.",
        "If set to V(True), it will force 'scp', if V(False) it will use 'sftp'.",
        "For OpenSSH >=9.0 you must add an additional option to enable scp (C(scp_extra_args=\"-O\"))",
        "This setting will overridden by O(ssh_transfer_method) if set."
       ],
       "env": [
        {
         "name": "ANSIBLE_SCP_IF_SSH"
        }
       ],
       "ini": [
        {
         "key": "scp_if_ssh",
         "section": "ssh_connection"
        }
       ],
       "vars": [
        {
         "name": "ansible_scp_if_ssh",
         "version_added": "2.7",
         "version_added_collection": "ansible.builtin"
        }
       ]
      },
      "sftp_batch_mode": {
       "default": true,
       "description": "TODO: write it",
       "env": [
        {
         "name": "ANSIBLE_SFTP_BATCH_MODE"
        }
       ],
       "ini": [
        {
         "key": "sftp_batch_mode",
         "section": "ssh_connection"
        }
       ],
       "type": "bool",
       "vars": [
        {
         "name": "ansible_sftp_batch_mode",
         "version_added": "2.7",
         "version_added_collection": "ansible.builtin"
        }
       ]
      },
      "sftp_executable": {
       "default": "sftp",
       "description": [
        "This defines the location of the sftp binary. It defaults to V(sftp) which will use the first binary available in $PATH."
       ],
       "env": [
        {
         "name": "ANSIBLE_SFTP_EXECUTABLE"
        }
       ],
       "ini": [
        {
         "key": "sftp_executable",
         "section": "ssh_connection"
        }
       ],
       "type": "string",
       "vars": [
        {
         "name": "ansible_sftp_executable",
         "version_added": "2.7",
         "version_added_collection": "ansible.builtin"
        }
       ],
       "version_added": "2.6",
       "version_added_collection": "ansible.builtin"
      },
      "sftp_extra_args": {
       "cli": [
        {
         "name": "sftp_extra_args"
        }
       ],
       "default": "",
       "description": "Extra exclusive to the C(sftp) CLI",
       "env": [
        {
         "name": "ANSIBLE_SFTP_EXTRA_ARGS",
         "version_added": "2.7",
         "version_added_collection": "ansible.builtin"
        }
       ],
       "ini": [
        {
         "key": "sftp_extra_args",
         "section": "ssh_connection",
         "version_added": "2.7",
         "version_added_collection": "ansible.builtin"
        }
       ],
       "type": "string",
       "vars": [
        {
         "name": "ansible_sftp_extra_args"
        }
       ]
      },
      "ssh_args": {
       "default": "-C -o ControlMaster=auto -o ControlPersist=60s",
       "description": "Arguments to pass to all SSH CLI tools.",
       "env": [
        {
         "name": "ANSIBLE_SSH_ARGS"
        }
       ],
       "ini": [
        {
         "key": "ssh_args",
         "section": "ssh_connection"
        }
       ],
       "type": "string",
       "vars": [
        {
         "name": "ansible_ssh_args",
         "version_added": "2.7",
         "version_added_collection": "ansible.builtin"
        }
       ]
      },
      "ssh_common_args": {
       "cli": [
        {
         "name": "ssh_common_args"
        }
       ],
       "default": "",
       "description": "Common extra args for all SSH CLI tools.",
       "env": [
        {
         "name": "ANSIBLE_SSH_COMMON_ARGS",
         "version_added": "2.7",
         "version_added_collection": "ansible.builtin"
        }
       ],
       "ini": [
        {
         "key": "ssh_common_args",
         "section": "ssh_connection",
         "version_added": "2.7",
         "version_added_collection": "ansible.builtin"
        }
       ],
       "type": "string",
       "vars": [
        {
         "name": "ansible_ssh_common_args"
        }
       ]
      },
      "ssh_executable": {
       "default": "ssh",
       "description": [
        "This defines the location of the SSH binary. It defaults to V(ssh) which will use the first SSH binary available in $PATH.",
        "This option is usually not required, it might be useful when access to system SSH is restricted, or when using SSH wrappers to connect to remote hosts."
       ],
       "env": [
        {
         "name": "ANSIBLE_SSH_EXECUTABLE"
        }
       ],
       "ini": [
        {
         "key": "ssh_executable",
         "section": "ssh_connection"
        }
       ],
       "type": "string",
       "vars": [
        {
         "name": "ansible_ssh_executable",
         "version_added": "2.7",
         "version_added_collection": "ansible.builtin"
        }
       ],
       "version_added": "2.2",
       "version_added_collection": "ansible.builtin"
      },
      "ssh_extra_args": {
       "cli": [
        {
         "name": "ssh_extra_args"
        }
       ],
       "default": "",
       "description": "Extra exclusive to the SSH CLI.",
       "env": [
        {
         "name": "ANSIBLE_SSH_EXTRA_ARGS",
         "version_added": "2.7",
         "version_added_collection": "ansible.builtin"
        }
       ],
       "ini": [
        {
         "key": "ssh_extra_args",
         "section": "ssh_connection",
         "version_added": "2.7",
         "version_added_collection": "ansible.builtin"
        }
       ],
       "type": "string",
       "vars": [
        {
         "name": "ansible_ssh_extra_args"
        }
       ]
      },
      "ssh_transfer_method": {
       "choices": [
        "sftp",
        "scp",
        "piped",
        "smart"
       ],
       "description": [
        "Preferred method to use when transferring files over ssh",
        "Setting to 'smart' (default) will try them in order, until one succeeds or they all fail",
        "For OpenSSH >=9.0 you must add an additional option to enable scp (scp_extra_args=\"-O\")",
        "Using 'piped' creates an ssh pipe with C(dd) on either side to copy the data"
       ],
       "env": [
        {
         "name": "ANSIBLE_SSH_TRANSFER_METHOD"
        }
       ],
       "ini": [
        {
         "key": "transfer_method",
         "section": "ssh_connection"
        }
       ],
       "type": "string",
       "vars": [
        {
         "name": "ansible_ssh_transfer_method",
         "version_added": "2.12",
         "version_added_collection": "ansible.builtin"
        }
       ]
      },
      "sshpass_prompt": {
       "default": "",
       "description": [
        "Password prompt that sshpass should search for. Supported by sshpass 1.06 and up.",
        "Defaults to C(Enter PIN for) when pkcs11_provider is set."
       ],
       "env": [
        {
         "name": "ANSIBLE_SSHPASS_PROMPT"
        }
       ],
       "ini": [
        {
         "key": "sshpass_prompt",
         "section": "ssh_connection"
        }
       ],
       "type": "string",
       "vars": [
        {
         "name": "ansible_sshpass_prompt"
        }
       ],
       "version_added": "2.10",
       "version_added_collection": "ansible.builtin"
      },
      "timeout": {
       "cli": [
        {
         "name": "timeout"
        }
       ],
       "default": 10,
       "description": [
        "This is the default amount of time we will wait while establishing an SSH connection.",
        "It also controls how long we can wait to access reading the connection once established (select on the socket)."
       ],
       "env": [
        {
         "name": "ANSIBLE_TIMEOUT"
        },
        {
         "name": "ANSIBLE_SSH_TIMEOUT",
         "version_added": "2.11",
         "version_added_collection": "ansible.builtin"
        }
       ],
       "ini": [
        {
         "key": "timeout",
         "section": "defaults"
        },
        {
         "key": "timeout",
         "section": "ssh_connection",
         "version_added": "2.11",
         "version_added_collection": "ansible.builtin"
        }
       ],
       "type": "integer",
       "vars": [
        {
         "name": "ansible_ssh_timeout",
         "version_added": "2.11",
         "version_added_collection": "ansible.builtin"
        }
       ]
      },
      "use_tty": {
       "default": true,
       "description": "add -tt to ssh commands to force tty allocation.",
       "env": [
        {
         "name": "ANSIBLE_SSH_USETTY"
        }
       ],
       "ini": [
        {
         "key": "usetty",
         "section": "ssh_connection"
        }
       ],
       "type": "bool",
       "vars": [
        {
         "name": "ansible_ssh_use_tty",
         "version_added": "2.7",
         "version_added_collection": "ansible.builtin"
        }
       ],
       "version_added": "2.5",
       "version_added_collection": "ansible.builtin"
      }
     },
     "short_description": "connect via SSH client binary",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": null,
    "metadata": null,
    "return": null
   },
   "ansible.builtin.winrm": {
    "doc": {
     "author": "Ansible Core Team",
     "collection": "ansible.builtin",
     "description": [
      "Run commands or put/fetch on a target via WinRM",
      "This plugin allows extra arguments to be passed that are supported by the protocol but not explicitly defined here. They should take the form of variables declared with the following pattern C(ansible_winrm_<option>)."
     ],
     "filename": "/ansible/plugins/connection/winrm.py",
     "name": "winrm",
     "options": {
      "connection_timeout": {
       "description": [
        "Despite its name, sets both the 'operation' and 'read' timeout settings for the WinRM connection.",
        "The operation timeout belongs to the WS-Man layer and runs on the winRM-service on the managed windows host.",
        "The read timeout belongs to the underlying python Request call (http-layer) and runs on the ansible controller.",
        "The operation timeout sets the WS-Man 'Operation timeout' that runs on the managed windows host. The operation timeout specifies how long a command will run on the winRM-service before it sends the message 'WinRMOperationTimeoutError' back to the client. The client (silently) ignores this message and starts a new instance of the operation timeout, waiting for the command to finish (long running commands).",
        "The read timeout sets the client HTTP-request timeout and specifies how long the client (ansible controller) will wait for data from the server to come back over the HTTP-connection (timeout for waiting for in-between messages from the server). When this timer expires, an exception will be thrown and the ansible connection will be terminated with the error message 'Read timed out'",
        "To avoid the above exception to be thrown, the read timeout will be set to 10 seconds higher than the WS-Man operation timeout, thus make the connection more robust on networks with long latency and/or many hops between server and client network wise.",
        "Setting the difference between the operation and the read timeout to 10 seconds aligns it to the defaults used in the winrm-module and the PSRP-module which also uses 10 seconds (30 seconds for read timeout and 20 seconds for operation timeout)",
        "Corresponds to the C(operation_timeout_sec) and C(read_timeout_sec) args in pywinrm so avoid setting these vars with this one.",
        "The default value is whatever is set in the installed version of pywinrm."
       ],
       "type": "int",
       "vars": [
        {
         "name": "ansible_winrm_connection_timeout"
        }
       ]
      },
      "kerberos_command": {
       "default": "kinit",
       "description": "kerberos command to use to request a authentication ticket",
       "type": "str",
       "vars": [
        {
         "name": "ansible_winrm_kinit_cmd"
        }
       ]
      },
      "kerberos_mode": {
       "choices": [
        "managed",
        "manual"
       ],
       "description": [
        "kerberos usage mode.",
        "The managed option means Ansible will obtain kerberos ticket.",
        "While the manual one means a ticket must already have been obtained by the user.",
        "If having issues with Ansible freezing when trying to obtain the Kerberos ticket, you can either set this to V(manual) and obtain it outside Ansible or install C(pexpect) through pip and try again."
       ],
       "type": "str",
       "vars": [
        {
         "name": "ansible_winrm_kinit_mode"
        }
       ]
      },
      "kinit_args": {
       "description": [
        "Extra arguments to pass to C(kinit) when getting the Kerberos authentication ticket.",
        "By default no extra arguments are passed into C(kinit) unless I(ansible_winrm_kerberos_delegation) is also set. In that case C(-f) is added to the C(kinit) args so a forwardable ticket is retrieved.",
        "If set, the args will overwrite any existing defaults for C(kinit), including C(-f) for a delegated ticket."
       ],
       "type": "str",
       "vars": [
        {
         "name": "ansible_winrm_kinit_args"
        }
       ],
       "version_added": "2.11",
       "version_added_collection": "ansible.builtin"
      },
      "kinit_env_vars": {
       "default": [],
       "description": [
        "A list of environment variables to pass through to C(kinit) when getting the Kerberos authentication ticket.",
        "By default no environment variables are passed through and C(kinit) is run with a blank slate.",
        "The environment variable C(KRB5CCNAME) cannot be specified here as it's used to store the temp Kerberos ticket used by WinRM."
       ],
       "elements": "str",
       "ini": [
        {
         "key": "kinit_env_vars",
         "section": "winrm"
        }
       ],
       "type": "list",
       "vars": [
        {
         "name": "ansible_winrm_kinit_env_vars"
        }
       ],
       "version_added": "2.12",
       "version_added_collection": "ansible.builtin"
      },
      "path": {
       "default": "/wsman",
       "description": "URI path to connect to",
       "type": "str",
       "vars": [
        {
         "name": "ansible_winrm_path"
        }
       ]
      },
      "pipelining": {
       "default": false,
       "description": [
        "Pipelining reduces the number of connection operations required to execute a module on the remote server, by executing many Ansible modules without actual file transfers.",
        "This can result in a very significant performance improvement when enabled.",
        "However this can conflict with privilege escalation (become). For example, when using sudo operations you must first disable 'requiretty' in the sudoers file for the target hosts, which is why this feature is disabled by default."
       ],
       "env": [
        {
         "name": "ANSIBLE_PIPELINING"
        }
       ],
       "ini": [
        {
         "key": "pipelining",
         "section": "defaults"
        },
        {
         "key": "pipelining",
         "section": "connection"
        }
       ],
       "type": "boolean",
       "vars": [
        {
         "name": "ansible_pipelining"
        }
       ]
      },
      "port": {
       "default": 5986,
       "description": [
        "port for winrm to connect on remote target",
        "The default is the https (5986) port, if using http it should be 5985"
       ],
       "keyword": [
        {
         "name": "port"
        }
       ],
       "type": "integer",
       "vars": [
        {
         "name": "ansible_port"
        },
        {
         "name": "ansible_winrm_port"
        }
       ]
      },
      "remote_addr": {
       "default": "inventory_hostname",
       "description": [
        "Address of the windows machine"
       ],
       "type": "str",
       "vars": [
        {
         "name": "inventory_hostname"
        },
        {
         "name": "ansible_host"
        },
        {
         "name": "ansible_winrm_host"
        }
       ]
      },
      "remote_password": {
       "aliases": [
        "password"
       ],
       "description": "Authentication password for the O(remote_user). Can be supplied as CLI option.",
       "type": "str",
       "vars": [
        {
         "name": "ansible_password"
        },
        {
         "name": "ansible_winrm_pass"
        },
        {
         "name": "ansible_winrm_password"
        }
       ]
      },
      "remote_user": {
       "description": [
        "The user to log in as to the Windows machine"
       ],
       "keyword": [
        {
         "name": "remote_user"
        }
       ],
       "type": "str",
       "vars": [
        {
         "name": "ansible_user"
        },
        {
         "name": "ansible_winrm_user"
        }
       ]
      },
      "scheme": {
       "choices": [
        "http",
        "https"
       ],
       "description": [
        "URI scheme to use",
        "If not set, then will default to V(https) or V(http) if O(port) is V(5985)."
       ],
       "type": "str",
       "vars": [
        {
         "name": "ansible_winrm_scheme"
        }
       ]
      },
      "transport": {
       "description": [
        "List of winrm transports to attempt to use (ssl, plaintext, kerberos, etc)",
        "If None (the default) the plugin will try to automatically guess the correct list",
        "The choices available depend on your version of pywinrm"
       ],
       "elements": "string",
       "type": "list",
       "vars": [
        {
         "name": "ansible_winrm_transport"
        }
       ]
      }
     },
     "requirements": [
      "pywinrm (python library)"
     ],
     "short_description": "Run tasks over Microsoft's WinRM",
     "version_added": "2.0",
     "version_added_collection": "ansible.builtin"
    },
    "examples": null,
    "metadata": null,
    "return": null
   },
   "ns2.col.foo": {
    "doc": {
     "author": "ansible (@core)",
     "collection": "ns2.col",
     "description": [
      "This is for the C(foo) connection."
     ],
     "filename": "ansible_collections/ns2/col/plugins/connection/foo.py",
     "name": "foo",
     "notes": [
      "Some note. B(Something in bold). C(And in code). I(And in italics). An URL: U(https://example.org).",
      "And another one. L(A link, https://example.com)."
     ],
     "options": {
      "bar": {
       "description": "Foo bar.",
       "type": "int"
      },
      "host": {
       "default": "inventory_hostname",
       "description": "Hostname to connect to.",
       "vars": [
        {
         "name": "inventory_hostname"
        },
        {
         "name": "ansible_host"
        },
        {
         "name": "ansible_ssh_host"
        },
        {
         "name": "delegated_vars['ansible_host']"
        },
        {
         "name": "delegated_vars['ansible_ssh_host']"
        }
       ]
      }
     },
     "short_description": "Foo connection O(bar)",
     "version_added": "1.2.0",
     "version_added_collection": "ns2.col"
    },
    "examples": null,
    "metadata": null,
    "return": null
   }
  },
  "filter": {
   "ansible.builtin.b64decode": {
    "doc": {
     "author": "ansible core team",
     "collection": "ansible.builtin",
     "description": [
      "Base64 decoding function.",
      "The return value is a string.",
      "Trying to store a binary blob in a string most likely corrupts the binary. To base64 decode a binary blob, use the ``base64`` command  and pipe the encoded data through standard input. For example, in the ansible.builtin.shell`` module, ``cmd=\"base64 --decode > myfile.bin\" stdin=\"{{ encoded }}\"``."
     ],
     "filename": "/ansible/plugins/filter/b64decode.yml",
     "name": "b64decode",
     "options": {
      "_input": {
       "description": "A base64 string to decode.",
       "required": true,
       "type": "string"
      }
     },
     "positional": "_input",
     "short_description": "Decode a base64 string",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# b64 decode a string\nlola: \"{{ 'bG9sYQ==' | b64decode }}\"\n\n# b64 decode the content of 'b64stuff' variable\nstuff: \"{{ b64stuff | b64decode }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The contents of the base64 encoded string.",
      "type": "string"
     }
    }
   },
   "ansible.builtin.b64encode": {
    "doc": {
     "author": "ansible core team",
     "collection": "ansible.builtin",
     "description": [
      "Base64 encoding function."
     ],
     "filename": "/ansible/plugins/filter/b64encode.yml",
     "name": "b64encode",
     "options": {
      "_input": {
       "description": "A string to encode.",
       "required": true,
       "type": "string"
      }
     },
     "positional": "_input",
     "short_description": "Encode a string as base64",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# b64 encode a string\nb64lola: \"{{ 'lola'| b64encode }}\"\n\n# b64 encode the content of 'stuff' variable\nb64stuff: \"{{ stuff | b64encode }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "A base64 encoded string.",
      "type": "string"
     }
    }
   },
   "ansible.builtin.basename": {
    "doc": {
     "author": "ansible core team",
     "collection": "ansible.builtin",
     "description": [
      "Returns the last name component of a path, what is left in the string that is not 'dirname'."
     ],
     "filename": "/ansible/plugins/filter/basename.yml",
     "name": "basename",
     "notes": [
      "The result of this filter is different from the Unix basename program; where basename for C(/foo/bar/) returns C(bar), the basename filter returns an empty string (C(''))."
     ],
     "options": {
      "_input": {
       "description": "A path.",
       "required": true,
       "type": "path"
      }
     },
     "seealso": [
      {
       "plugin": "ansible.builtin.dirname",
       "plugin_type": "filter"
      }
     ],
     "short_description": "get a path's base name",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# To get the last name of a file path, like 'foo.txt' out of '/etc/asdf/foo.txt'.\n{{ mypath | basename }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The base name from the path provided.",
      "type": "str"
     }
    }
   },
   "ansible.builtin.bool": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Attempt to cast the input into a boolean (V(True) or V(False)) value."
     ],
     "filename": "/ansible/plugins/filter/bool.yml",
     "name": "bool",
     "options": {
      "_input": {
       "description": "Data to cast.",
       "required": true,
       "type": "raw"
      }
     },
     "positional": "_input",
     "short_description": "cast into a boolean",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# in vars\nvars:\n  isbool: \"{{ (a == b) | bool }} \"\n  otherbool: \"{{ anothervar | bool }} \"\n\n# in a task\n...\nwhen: some_string_value | bool\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The boolean resulting of casting the input expression into a V(True) or V(False) value.",
      "type": "bool"
     }
    }
   },
   "ansible.builtin.checksum": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Returns a checksum (L(SHA-1, https://en.wikipedia.org/wiki/SHA-1)) hash of the input data."
     ],
     "filename": "/ansible/plugins/filter/checksum.yml",
     "name": "checksum",
     "options": {
      "_input": {
       "description": "Data to checksum.",
       "required": true,
       "type": "raw"
      }
     },
     "positional": "_input",
     "short_description": "checksum of input data",
     "version_added": "1.9",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# csum => \"109f4b3c50d7b0df729d299bc6f8e9ef9066971f\"\ncsum: \"{{ 'test2' | checksum }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The checksum (SHA-1) of the input.",
      "type": "string"
     }
    }
   },
   "ansible.builtin.combinations": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Create a list of combinations of sets from the elements of a list."
     ],
     "filename": "/ansible/plugins/filter/combinations.yml",
     "name": "combinations",
     "options": {
      "_input": {
       "description": "Elements to combine.",
       "required": true,
       "type": "list"
      },
      "set_size": {
       "description": "The size of the set for each combination.",
       "required": true,
       "type": "int"
      }
     },
     "positional": "_input, set_size",
     "short_description": "combinations from the elements of a list",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# combos_of_two => [ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 1, 5 ], [ 2, 3 ], [ 2, 4 ], [ 2, 5 ], [ 3, 4 ], [ 3, 5 ], [ 4, 5 ] ]\ncombos_of_two: \"{{ [1,2,3,4,5] | combinations(2) }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "List of combination sets resulting from the supplied elements and set size.",
      "type": "list"
     }
    }
   },
   "ansible.builtin.combine": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Create a dictionary (hash/associative array) as a result of merging existing dictionaries."
     ],
     "filename": "/ansible/plugins/filter/combine.yml",
     "name": "combine",
     "options": {
      "_dicts": {
       "description": "The list of dictionaries to combine.",
       "elements": "dictionary",
       "required": true,
       "type": "list"
      },
      "_input": {
       "description": "First dictionary to combine.",
       "required": true,
       "type": "dict"
      },
      "list_merge": {
       "choices": {
        "append": "append newer entries to the older ones",
        "append_rp": "append newer entries to the older ones, overwrite duplicates",
        "keep": "discard newer entries",
        "prepend": "insert newer entries in front of the older ones",
        "prepend_rp": "insert newer entries in front of the older ones, discard duplicates",
        "replace": "overwrite older entries with newer ones"
       },
       "default": "replace",
       "description": "Behavior when encountering list elements.",
       "type": "str"
      },
      "recursive": {
       "default": false,
       "description": "If V(True), merge elements recursively.",
       "type": "bool"
      }
     },
     "positional": "_input, _dicts",
     "short_description": "combine two dictionaries",
     "version_added": "2.0",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# ab => {'a':1, 'b':3, 'c': 4}\nab: {{ {'a':1, 'b':2} | ansible.builtin.combine({'b':3, 'c':4}) }}\n\nmany: \"{{ dict1 | ansible.builtin.combine(dict2, dict3, dict4) }}\"\n\n# defaults => {'a':{'b':3, 'c':4}, 'd': 5}\n# customization => {'a':{'c':20}}\n# final => {'a':{'b':3, 'c':20}, 'd': 5}\nfinal: \"{{ defaults | ansible.builtin.combine(customization, recursive=true) }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Resulting merge of supplied dictionaries.",
      "type": "dict"
     }
    }
   },
   "ansible.builtin.comment": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Use programming language conventions to turn the input string into an embeddable comment."
     ],
     "filename": "/ansible/plugins/filter/comment.yml",
     "name": "comment",
     "options": {
      "_input": {
       "description": "String to comment.",
       "required": true,
       "type": "string"
      },
      "beginning": {
       "description": "Indicator of the start of a comment block, only available for styles that support multiline comments.",
       "type": "string"
      },
      "decoration": {
       "description": "Indicator for comment or intermediate comment depending on the style.",
       "type": "string"
      },
      "end": {
       "description": "Indicator the end of a comment block, only available for styles that support multiline comments.",
       "type": "string"
      },
      "newline": {
       "default": "\\n",
       "description": "Indicator of comment end of line, only available for styles that support multiline comments.",
       "type": "string"
      },
      "postfix": {
       "description": "Indicator of the end of each line inside a comment block, only available for styles that support multiline comments.",
       "type": "string"
      },
      "postfix_count": {
       "default": 1,
       "description": "Number of times to add a postfix at the end of a line, when a prefix exists and is usable.",
       "type": "int"
      },
      "prefix": {
       "description": "Token to start each line inside a comment block, only available for styles that support multiline comments.",
       "type": "string"
      },
      "prefix_count": {
       "default": 1,
       "description": "Number of times to add a prefix at the start of a line, when a prefix exists and is usable.",
       "type": "int"
      },
      "style": {
       "choices": [
        "plain",
        "decoration",
        "erlang",
        "c",
        "cblock",
        "xml"
       ],
       "default": "plain",
       "description": "Comment style to use.",
       "type": "string"
      }
     },
     "positional": "_input, style",
     "short_description": "comment out a string",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# commented =>  #\n#               # Plain style (default)\n#               #\ncommented: \"{{ 'Plain style (default)' | comment }}\"\n\n# not going to show that here ...\nverycustom: \"{{ \"Custom style\" | comment('plain', prefix='#######\\n#', postfix='#\\n#######\\n   ###\\n    #') }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The 'commented out' string.",
      "type": "string"
     }
    }
   },
   "ansible.builtin.commonpath": {
    "doc": {
     "author": "Shivam Durgbuns",
     "collection": "ansible.builtin",
     "description": [
      "Returns the longest common path from the given list of paths."
     ],
     "filename": "/ansible/plugins/filter/commonpath.yml",
     "name": "commonpath",
     "options": {
      "_input": {
       "description": "A list of paths.",
       "elements": "path",
       "required": true,
       "type": "list"
      }
     },
     "seealso": [
      {
       "plugin": "ansible.builtin.basename",
       "plugin_type": "filter"
      }
     ],
     "short_description": "gets the common path",
     "version_added": "2.15",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# To get the longest common path (for example - '/foo/bar') from the given list of paths\n# (for example - ['/foo/bar/foobar','/foo/bar'])\n{{ listofpaths | commonpath }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The longest common path from the given list of paths.",
      "type": "path"
     }
    }
   },
   "ansible.builtin.dict2items": {
    "doc": {
     "author": "Ansible core team",
     "collection": "ansible.builtin",
     "description": [
      "Takes a dictionary and transforms it into a list of dictionaries, with each having a C(key) and C(value) keys that correspond to the keys and values of the original."
     ],
     "filename": "/ansible/plugins/filter/dict2items.yml",
     "name": "dict2items",
     "options": {
      "_input": {
       "description": [
        "The dictionary to transform"
       ],
       "required": true,
       "type": "dict"
      },
      "key_name": {
       "default": "key",
       "description": "The name of the property on the item representing the dictionary's keys.",
       "type": "str",
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      },
      "value_name": {
       "default": "value",
       "description": "The name of the property on the item representing the dictionary's values.",
       "type": "str",
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      }
     },
     "positional": "_input, key_name, value_name",
     "seealso": [
      {
       "plugin": "ansible.builtin.items2dict",
       "plugin_type": "filter"
      }
     ],
     "short_description": "Convert a dictionary into an itemized list of dictionaries",
     "version_added": "2.6",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# items => [ { \"key\": \"a\", \"value\": 1 }, { \"key\": \"b\", \"value\": 2 } ]\nitems: \"{{ {'a': 1, 'b': 2}| dict2items }}\"\n\n# files_dicts: [\n#       {\n#           \"file\": \"users\",\n#           \"path\": \"/etc/passwd\"\n#       },\n#       {\n#           \"file\": \"groups\",\n#           \"path\": \"/etc/group\"\n#       }\n# ]\nvars:\n  files:\n    users: /etc/passwd\n    groups: /etc/group\n  files_dicts: \"{{ files | dict2items(key_name='file', value_name='path') }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "A list of dictionaries.",
      "elements": "dict",
      "type": "list"
     }
    }
   },
   "ansible.builtin.difference": {
    "doc": {
     "author": "Brian Coca (@bcoca)",
     "collection": "ansible.builtin",
     "description": [
      "Provide a unique list of all the elements of the first list that do not appear in the second one.",
      "Items in the resulting list are returned in arbitrary order."
     ],
     "filename": "/ansible/plugins/filter/difference.yml",
     "name": "difference",
     "options": {
      "_input": {
       "description": "A list.",
       "required": true,
       "type": "list"
      },
      "_second_list": {
       "description": "A list.",
       "required": true,
       "type": "list"
      }
     },
     "seealso": [
      {
       "plugin": "ansible.builtin.intersect",
       "plugin_type": "filter"
      },
      {
       "plugin": "ansible.builtin.symmetric_difference",
       "plugin_type": "filter"
      },
      {
       "plugin": "ansible.builtin.union",
       "plugin_type": "filter"
      },
      {
       "plugin": "ansible.builtin.unique",
       "plugin_type": "filter"
      }
     ],
     "short_description": "the difference of one list from another",
     "version_added": "1.4",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# return the elements of list1 not in list2\n# list1: [1, 2, 5, 1, 3, 4, 10]\n# list2: [1, 2, 3, 4, 5, 11, 99]\n{{ list1 | difference(list2) }}\n# => [10]\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "A unique list of the elements from the first list that do not appear on the second.",
      "type": "list"
     }
    }
   },
   "ansible.builtin.dirname": {
    "doc": {
     "author": "ansible core team",
     "collection": "ansible.builtin",
     "description": [
      "Returns the 'head' component of a path, basically everything that is not the 'basename'."
     ],
     "filename": "/ansible/plugins/filter/dirname.yml",
     "name": "dirname",
     "notes": [
      "The result of this filter is different from the Unix dirname program; where dirname for C(/foo/bar/) returns C(/foo), the dirname filter returns the full path (C(/foo/bar/))."
     ],
     "options": {
      "_input": {
       "description": "A path.",
       "required": true,
       "type": "path"
      }
     },
     "seealso": [
      {
       "plugin": "ansible.builtin.basename",
       "plugin_type": "filter"
      }
     ],
     "short_description": "get a path's directory name",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# To get the dir name of a file path, like '/etc/asdf' out of '/etc/asdf/foo.txt'.\n{{ mypath | dirname }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The directory portion of the original path.",
      "type": "path"
     }
    }
   },
   "ansible.builtin.expanduser": {
    "doc": {
     "author": "ansible core team",
     "collection": "ansible.builtin",
     "description": [
      "Translates C(~) in a path to the proper user's home directory."
     ],
     "filename": "/ansible/plugins/filter/expanduser.yml",
     "name": "basename",
     "options": {
      "_input": {
       "description": "A string that contains a path.",
       "required": true,
       "type": "path"
      }
     },
     "short_description": "Returns a path with C(~) translation.",
     "version_added": "1.5",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# To get '/home/myuser/stuff.txt' from '~/stuff.txt'.\n{{ mypath | expanduser }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The translated path.",
      "type": "path"
     }
    }
   },
   "ansible.builtin.expandvars": {
    "doc": {
     "author": "ansible core team",
     "collection": "ansible.builtin",
     "description": [
      "Will do a shell-like substitution of environment variables on the provided input."
     ],
     "filename": "/ansible/plugins/filter/expandvars.yml",
     "name": "expandvars",
     "options": {
      "_input": {
       "description": "A string that contains environment variables.",
       "required": true,
       "type": "str"
      }
     },
     "short_description": "expand environment variables",
     "version_added": "1.5",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# To get '/home/myuser/stuff.txt' from '$HOME/stuff.txt'\n{{ mypath | expandvars }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The string with translated environment variable values.",
      "type": "str"
     }
    }
   },
   "ansible.builtin.extract": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Extract a value from a list or dictionary based on an index/key.",
      "User must ensure that index or key used matches the type of container.",
      "Equivalent of using C(list[index]) and C(dictionary[key]) but useful as a filter to combine with C(map)."
     ],
     "filename": "/ansible/plugins/filter/extract.yml",
     "name": "extract",
     "options": {
      "_input": {
       "description": "Index or key to extract.",
       "required": true,
       "type": "raw"
      },
      "container": {
       "description": "Dictionary or list from which to extract a value.",
       "required": true,
       "type": "raw"
      },
      "morekeys": {
       "description": "Indices or keys to extract from the initial result (subkeys/subindices).",
       "elements": "dictionary",
       "required": true,
       "type": "list"
      }
     },
     "positional": "_input, container, morekeys",
     "short_description": "extract a value based on an index or key",
     "version_added": "2.1",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# extracted => 'b', same as ['a', 'b', 'c'][1]\nextracted: \"{{ 1 | extract(['a', 'b', 'c']) }}\"\n\n# extracted_key => '2', same as {'a': 1, 'b': 2, 'c': 3}['b']\nextracted_key: \"{{ 'b' | extract({'a': 1, 'b': 2, 'c': 3}) }}\"\n\n# extracted_key_r => '2', same as [{'a': 1, 'b': 2, 'c': 3}, {'x': 9, 'y': 10}][0]['b']\nextracted_key_r: \"{{ 0 | extract([{'a': 1, 'b': 2, 'c': 3}, {'x': 9, 'y': 10}], morekeys='b') }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Resulting merge of supplied dictionaries.",
      "type": "dict"
     }
    }
   },
   "ansible.builtin.fileglob": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Return a list of files that matches the supplied path glob pattern.",
      "Filters run on the controller, so the files are matched from the controller's file system."
     ],
     "filename": "/ansible/plugins/filter/fileglob.yml",
     "name": "fileglob",
     "options": {
      "_input": {
       "description": "Path glob pattern.",
       "required": true,
       "type": "string"
      }
     },
     "positional": "_input",
     "short_description": "explode a path glob to matching files"
    },
    "examples": "# found = ['/etc/hosts', '/etc/hasts']\nfound: \"{{ '/etc/h?sts' | fileglob }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "List of files matched.",
      "elements": "string",
      "type": "list"
     }
    }
   },
   "ansible.builtin.flatten": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "For a given list, take any elements that are lists and insert their elements into the parent list directly."
     ],
     "filename": "/ansible/plugins/filter/flatten.yml",
     "name": "flatten",
     "options": {
      "_input": {
       "description": "First dictionary to combine.",
       "required": true,
       "type": "dict"
      },
      "levels": {
       "description": "Number of recursive list depths to flatten.",
       "type": "int"
      },
      "skip_nulls": {
       "default": true,
       "description": "Skip V(null)/V(None) elements when inserting into the top list.",
       "type": "bool"
      }
     },
     "positional": "_input, levels, skip_nulls",
     "short_description": "flatten lists within a list",
     "version_added": "2.5",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# [1,2,3,4,5,6]\nflat: \"{{ [1 , 2, [3, [4, 5]], 6] | flatten }}\"\n\n# [1,2,3,[4,5],6]\nflatone: \"{{ [1, 2, [3, [4, 5]], 6] | flatten(1) }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The flattened list.",
      "type": "list"
     }
    }
   },
   "ansible.builtin.from_json": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Converts a JSON string representation into an equivalent structured Ansible variable.",
      "Ansible automatically converts JSON strings into variable structures in most contexts, use this plugin in contexts where automatic conversion does not happen."
     ],
     "filename": "/ansible/plugins/filter/from_json.yml",
     "name": "from_json",
     "notes": [
      "This filter functions as a wrapper to the Python C(json.loads) function."
     ],
     "options": {
      "_input": {
       "description": "A JSON string.",
       "required": true,
       "type": "string"
      }
     },
     "short_description": "Convert JSON string into variable structure",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# variable from string variable containing a JSON document\n{{ docker_config | from_json }}\n\n# variable from string JSON document\n{{ '{\"a\": true, \"b\": 54, \"c\": [1,2,3]}' | from_json }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The variable resulting from deserialization of the JSON document.",
      "type": "raw"
     }
    }
   },
   "ansible.builtin.from_yaml": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Converts a YAML string representation into an equivalent structured Ansible variable.",
      "Ansible automatically converts YAML strings into variable structures in most contexts, use this plugin in contexts where automatic conversion does not happen."
     ],
     "filename": "/ansible/plugins/filter/from_yaml.yml",
     "name": "from_yaml",
     "notes": [
      "This filter functions as a wrapper to the L(Python pyyaml library, https://pypi.org/project/PyYAML/)'s C(yaml.safe_load) function."
     ],
     "options": {
      "_input": {
       "description": "A YAML string.",
       "required": true,
       "type": "string"
      }
     },
     "short_description": "Convert YAML string into variable structure",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# variable from string variable containing a YAML document\n{{ github_workflow | from_yaml }}\n\n# variable from string JSON document\n{{ '{\"a\": true, \"b\": 54, \"c\": [1,2,3]}' | from_yaml }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The variable resulting from deserializing the YAML document.",
      "type": "raw"
     }
    }
   },
   "ansible.builtin.from_yaml_all": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Converts a YAML documents in a string representation into an equivalent structured Ansible variable.",
      "Ansible internally auto-converts YAML strings into variable structures in most contexts, but by default does not handle 'multi document' YAML files or strings.",
      "If multiple YAML documents are not supplied, this is the equivalence of using C(from_yaml)."
     ],
     "filename": "/ansible/plugins/filter/from_yaml_all.yml",
     "name": "from_yaml_all",
     "notes": [
      "This filter functions as a wrapper to the Python C(yaml.safe_load_all) function, part of the L(pyyaml Python library, https://pypi.org/project/PyYAML/).",
      "Possible conflicts in variable names from the multiple documents are resolved directly by the pyyaml library."
     ],
     "options": {
      "_input": {
       "description": "A YAML string.",
       "required": true,
       "type": "string"
      }
     },
     "short_description": "Convert a series of YAML documents into a variable structure",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# variable from string variable containing YAML documents\n{{ multidoc_yaml_string | from_yaml_all }}\n\n# variable from multidocument YAML string\n{{ '---\\n{\"a\": true, \"b\": 54, \"c\": [1,2,3]}\\n...\\n---{\"x\": 1}\\n...\\n' | from_yaml_all }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The variable resulting from deserializing the YAML documents.",
      "type": "raw"
     }
    }
   },
   "ansible.builtin.hash": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Returns a configurable hash of the input data. Uses L(SHA-1, https://en.wikipedia.org/wiki/SHA-1) by default."
     ],
     "filename": "/ansible/plugins/filter/hash.yml",
     "name": "checksum",
     "options": {
      "_input": {
       "description": "Data to checksum.",
       "required": true,
       "type": "raw"
      },
      "hashtype": {
       "default": "sha1",
       "description": [
        "Type of algorithm to produce the hash.",
        "The list of available choices depends on the installed Python's hashlib."
       ],
       "type": "string"
      }
     },
     "positional": "_input",
     "short_description": "hash of input data",
     "version_added": "1.9",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# sha1_hash => \"109f4b3c50d7b0df729d299bc6f8e9ef9066971f\"\nsha1_hash: {{ 'test2' | hash('sha1') }}\n# md5 => \"5a105e8b9d40e1329780d62ea2265d8a\"\nmd5: {{ 'test2' | hash('md5') }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The checksum of the input, as configured in O(hashtype).",
      "type": "string"
     }
    }
   },
   "ansible.builtin.human_readable": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Convert byte or bit figures to more human-readable formats."
     ],
     "filename": "/ansible/plugins/filter/human_readable.yml",
     "name": "human_redable",
     "options": {
      "_input": {
       "description": "Number of bytes, or bits. Depends on O(isbits).",
       "required": true,
       "type": "int"
      },
      "isbits": {
       "default": false,
       "description": "Whether the input is bits, instead of bytes.",
       "type": "bool"
      },
      "unit": {
       "choices": [
        "Y",
        "Z",
        "E",
        "P",
        "T",
        "G",
        "M",
        "K",
        "B"
       ],
       "description": "Unit to force output into. If none specified the largest unit arrived at will be used.",
       "type": "str"
      }
     },
     "positional": "_input, isbits, unit",
     "short_description": "Make bytes/bits human-readable",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# size => \"1.15 GB\"\nsize: \"{{ 1232345345 | human_readable }}\"\n\n# size => \"1.15 Gb\"\nsize_bits: \"{{ 1232345345 | human_readable(true) }}\"\n\n# size => \"1175.26 MB\"\nsize_MB: \"{{ 1232345345 | human_readable(unit='M') }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "human-readable byte or bit size.",
      "type": "str"
     }
    }
   },
   "ansible.builtin.human_to_bytes": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Convert a human-readable byte or bit string into a number bytes."
     ],
     "filename": "/ansible/plugins/filter/human_to_bytes.yml",
     "name": "human_to_bytes",
     "options": {
      "_input": {
       "description": "human-readable description of a number of bytes.",
       "required": true,
       "type": "int"
      },
      "default_unit": {
       "choices": [
        "Y",
        "Z",
        "E",
        "P",
        "T",
        "G",
        "M",
        "K",
        "B"
       ],
       "description": "Unit to assume when input does not specify it.",
       "type": "str"
      },
      "isbits": {
       "description": "If V(True), force to interpret only bit input; if V(False), force bytes. Otherwise use the notation to guess.",
       "type": "bool"
      }
     },
     "positional": "_input, default_unit, isbits",
     "short_description": "Get bytes from string",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# size => 1234803098\nsize: '{{ \"1.15 GB\" | human_to_bytes }}'\n\n# size => 1234803098\nsize: '{{ \"1.15\" | human_to_bytes(default_unit=\"G\") }}'\n\n# this is an error, wants bits, got bytes\nERROR: '{{ \"1.15 GB\" | human_to_bytes(isbits=true) }}'\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Integer representing the bytes from the input.",
      "type": "int"
     }
    }
   },
   "ansible.builtin.intersect": {
    "doc": {
     "author": "Brian Coca (@bcoca)",
     "collection": "ansible.builtin",
     "description": [
      "Provide a list with the common elements from other lists.",
      "Items in the resulting list are returned in arbitrary order."
     ],
     "filename": "/ansible/plugins/filter/intersect.yml",
     "name": "intersect",
     "options": {
      "_input": {
       "description": "A list.",
       "required": true,
       "type": "list"
      },
      "_second_list": {
       "description": "A list.",
       "required": true,
       "type": "list"
      }
     },
     "seealso": [
      {
       "plugin": "ansible.builtin.difference",
       "plugin_type": "filter"
      },
      {
       "plugin": "ansible.builtin.symmetric_difference",
       "plugin_type": "filter"
      },
      {
       "plugin": "ansible.builtin.unique",
       "plugin_type": "filter"
      },
      {
       "plugin": "ansible.builtin.union",
       "plugin_type": "filter"
      }
     ],
     "short_description": "intersection of lists",
     "version_added": "1.4",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# return only the common elements of list1 and list2\n# list1: [1, 2, 5, 3, 4, 10]\n# list2: [1, 2, 3, 4, 5, 11, 99]\n{{ list1 | intersect(list2) }}\n# => [1, 2, 5, 3, 4]\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "A list with unique elements common to both lists, also known as a set.",
      "type": "list"
     }
    }
   },
   "ansible.builtin.items2dict": {
    "doc": {
     "author": "Ansible core team",
     "collection": "ansible.builtin",
     "description": [
      "Takes a list of dicts with each having a C(key) and C(value) keys, and transforms the list into a dictionary, effectively as the reverse of R(dict2items,ansible_collections.ansible.builtin.dict2items_filter)."
     ],
     "filename": "/ansible/plugins/filter/items2dict.yml",
     "name": "items2dict",
     "options": {
      "_input": {
       "description": [
        "A list of dictionaries.",
        "Every dictionary must have keys C(key) and C(value)."
       ],
       "elements": "dict",
       "required": true,
       "type": "list"
      },
      "key_name": {
       "default": "key",
       "description": "The name of the key in the element dictionaries that holds the key to use at destination.",
       "type": "str"
      },
      "value_name": {
       "default": "value",
       "description": "The name of the key in the element dictionaries that holds the value to use at destination.",
       "type": "str"
      }
     },
     "positional": "_input, key_name, value_name",
     "seealso": [
      {
       "plugin": "ansible.builtin.dict2items",
       "plugin_type": "filter"
      }
     ],
     "short_description": "Consolidate a list of itemized dictionaries into a dictionary",
     "version_added": "2.7",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# mydict =>  { \"hi\": \"bye\", \"ciao\": \"ciao\" }\nmydict: {{ [{'key': 'hi', 'value': 'bye'}, {'key': 'ciao', 'value': 'ciao'} ]| items2dict}}\n\n# The output is a dictionary with two key/value pairs:\n#     Application: payment\n#     Environment: dev\nvars:\n  tags:\n    - key: Application\n      value: payment\n    - key: Environment\n      value: dev\n  consolidated: \"{{ tags | items2dict }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Dictionary with the consolidated key/values.",
      "type": "dict"
     }
    }
   },
   "ansible.builtin.log": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Math operation that returns the L(logarithm, https://en.wikipedia.org/wiki/Logarithm) to base N of the input number.",
      "By default, computes the L(natural logarithm, https://en.wikipedia.org/wiki/Natural_logarithm)."
     ],
     "filename": "/ansible/plugins/filter/log.yml",
     "name": "log",
     "notes": [
      "This is a passthrough to Python's C(math.log)."
     ],
     "options": {
      "_input": {
       "description": "Number to operate on.",
       "required": true,
       "type": "float"
      },
      "base": {
       "default": 2.718281828459045,
       "description": "Which base to use. Defaults to L(Euler's number, https://en.wikipedia.org/wiki/Euler%27s_number).",
       "type": "float"
      }
     },
     "positional": "_input, base",
     "short_description": "log of (math operation)",
     "version_added": "1.9",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# 1.2920296742201791\neightlogfive: \"{{ 8 | log(5) }}\"\n\n# 0.9030899869919435\neightlog10: \"{{ 8 | log() }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Resulting number.",
      "type": "float"
     }
    }
   },
   "ansible.builtin.mandatory": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Depending on context undefined variables can be ignored or skipped, this ensures they force an error."
     ],
     "filename": "/ansible/plugins/filter/mandatory.yml",
     "name": "mandatory",
     "options": {
      "_input": {
       "description": "Mandatory expression.",
       "required": true,
       "type": "raw"
      },
      "msg": {
       "description": "The customized message that is printed when the given variable is not defined.",
       "required": false,
       "type": "str"
      }
     },
     "positional": "_input",
     "short_description": "make a variable's existence mandatory",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# results in a Filter Error\n{{ notdefined | mandatory }}\n\n# print a custom error message\n{{ notdefined | mandatory(msg='This variable is required.') }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The input if defined, otherwise an error.",
      "type": "raw"
     }
    }
   },
   "ansible.builtin.md5": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Returns an L(MD5 hash, https://en.wikipedia.org/wiki/MD5) of the input data"
     ],
     "filename": "/ansible/plugins/filter/md5.yml",
     "name": "md5",
     "notes": [
      "This requires the MD5 algorithm to be available on the system, security contexts like FIPS might prevent this.",
      "MD5 has long been deemed insecure and is not recommended for security related uses."
     ],
     "options": {
      "_input": {
       "description": "data to hash",
       "required": true,
       "type": "raw"
      }
     },
     "positional": "_input",
     "short_description": "MD5 hash of input data",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# md5hash => \"ae2b1fca515949e5d54fb22b8ed95575\"\nmd5hash: \"{{ 'testing' | md5 }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The MD5 hash of the input.",
      "type": "string"
     }
    }
   },
   "ansible.builtin.normpath": {
    "doc": {
     "author": "Shivam Durgbuns",
     "collection": "ansible.builtin",
     "description": [
      "Returns the normalized pathname by collapsing redundant separators and up-level references."
     ],
     "filename": "/ansible/plugins/filter/normpath.yml",
     "name": "normpath",
     "options": {
      "_input": {
       "description": "A path.",
       "required": true,
       "type": "path"
      }
     },
     "seealso": [
      {
       "plugin": "ansible.builtin.basename",
       "plugin_type": "filter"
      }
     ],
     "short_description": "Normalize a pathname",
     "version_added": "2.15",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# To get a normalized path (for example - '/foo/bar') from the path (for example - '/foo//bar')\n{{ path | normpath }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The normalized path from the path given.",
      "type": "path"
     }
    }
   },
   "ansible.builtin.password_hash": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Returns a password_hash of a secret."
     ],
     "filename": "/ansible/plugins/filter/password_hash.yml",
     "name": "password_hash",
     "notes": [
      "Algorithms available might be restricted by the system.",
      "Algorithms may restrict salt length or content. For example, Blowfish/bcrypt requires a 22-character salt."
     ],
     "options": {
      "_input": {
       "description": "Secret to hash.",
       "required": true,
       "type": "string"
      },
      "hashtype": {
       "choices": [
        "md5",
        "blowfish",
        "sha256",
        "sha512"
       ],
       "default": "sha512",
       "description": "Hashing algorithm to use.",
       "type": "string"
      },
      "ident": {
       "description": "Algorithm identifier.",
       "type": "string"
      },
      "rounds": {
       "description": "Number of encryption rounds, default varies by algorithm used.",
       "type": "int"
      },
      "salt": {
       "description": "Secret string used for the hashing. If none is provided a random one can be generated. Use only numbers and letters (characters matching V([./0-9A-Za-z]+)).",
       "type": "string"
      }
     },
     "positional": "_input",
     "short_description": "convert input password into password_hash",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# pwdhash => \"$6$/bQCntzQ7VrgVcFa$VaMkmevkY1dqrx8neaenUDlVU.6L/.ojRbrnI4ID.yBHU6XON1cB422scCiXfUL5wRucMdLgJU0Fn38uoeBni/\"\npwdhash: \"{{ 'testing' | password_hash }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The resulting password hash.",
      "type": "string"
     }
    }
   },
   "ansible.builtin.path_join": {
    "doc": {
     "author": "Anthony Bourguignon (@Toniob)",
     "collection": "ansible.builtin",
     "description": [
      "Returns a path obtained by joining one or more path components.",
      "If a path component is an absolute path, then all previous components are ignored and joining continues from the absolute path. See examples for details."
     ],
     "filename": "/ansible/plugins/filter/path_join.yml",
     "name": "path_join",
     "options": {
      "_input": {
       "description": "A path, or a list of paths.",
       "elements": "str",
       "required": true,
       "type": "list"
      }
     },
     "positional": "_input",
     "short_description": "Join one or more path components",
     "version_added": "2.10",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# If path == 'foo/bar' and file == 'baz.txt', the result is '/etc/foo/bar/subdir/baz.txt'\n{{ ('/etc', path, 'subdir', file) | path_join }}\n\n# equivalent to '/etc/subdir/{{filename}}'\nwheremyfile: \"{{ ['/etc', 'subdir', filename] | path_join }}\"\n\n# trustme => '/etc/apt/trusted.d/mykey.gpg'\ntrustme: \"{{ ['/etc', 'apt', 'trusted.d', 'mykey.gpg'] | path_join }}\"\n\n# If one of the paths is absolute, then path_join ignores all previous path components\n# If backup_dir == '/tmp' and backup_file == '/sample/baz.txt', the result is '/sample/baz.txt'\n# backup_path => \"/sample/baz.txt\"\nbackup_path: \"{{ ('/etc', backup_dir, backup_file) | path_join }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The concatenated path.",
      "type": "str"
     }
    }
   },
   "ansible.builtin.permutations": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Create a list of the permutations of lists from the elements of a list.",
      "Unlike combinations, in permutations order is significant."
     ],
     "filename": "/ansible/plugins/filter/permutations.yml",
     "name": "permutations",
     "options": {
      "_input": {
       "description": "Elements to base the permutations on.",
       "required": true,
       "type": "list"
      },
      "list_size": {
       "description": "The size of the list for each permutation.",
       "required": true,
       "type": "int"
      }
     },
     "positional": "_input, list_size",
     "short_description": "permutations from the elements of a list",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# ptrs_of_two => [ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 1, 5 ], [ 2, 1 ], [ 2, 3 ], [ 2, 4 ], [ 2, 5 ], [ 3, 1 ], [ 3, 2 ], [ 3, 4 ], [ 3, 5 ], [ 4, 1 ], [ 4, 2 ], [ 4, 3 ], [ 4, 5 ], [ 5, 1 ], [ 5, 2 ], [ 5, 3 ], [ 5, 4 ] ]\nprts_of_two:  \"{{ [1,2,3,4,5] | permutations(2) }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "List of permutations lists resulting from the supplied elements and list size.",
      "type": "list"
     }
    }
   },
   "ansible.builtin.pow": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Math operation that returns the Nth power of inputed number, C(X ^ N)."
     ],
     "filename": "/ansible/plugins/filter/pow.yml",
     "name": "pow",
     "notes": [
      "This is a passthrough to Python's C(math.pow)."
     ],
     "options": {
      "_input": {
       "description": "The base.",
       "required": true,
       "type": "float"
      },
      "_power": {
       "description": "Which power (exponent) to use.",
       "required": true,
       "type": "float"
      }
     },
     "positional": "_input, _power",
     "short_description": "power of (math operation)",
     "version_added": "1.9",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# => 32768\neight_power_five: \"{{ 8 | pow(5) }}\"\n\n# 4\nsquare_of_2: \"{{ 2 | pow(2) }}\"\n\n# me ^ 3\ncube_me: \"{{ me | pow(3) }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Resulting number.",
      "type": "float"
     }
    }
   },
   "ansible.builtin.product": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Combines two lists into one with each element being the product of the elements of the input lists.",
      "Creates 'nested loops'. Looping over C(listA) and C(listB) is the same as looping over C(listA | product(listB))."
     ],
     "filename": "/ansible/plugins/filter/product.yml",
     "name": "product",
     "notes": [
      "This is a passthrough to Python's C(itertools.product)"
     ],
     "options": {
      "_additional_lists": {
       "description": "Additional list for the product.",
       "required": false,
       "type": "list"
      },
      "_input": {
       "description": "First list.",
       "required": true,
       "type": "list"
      },
      "repeat": {
       "default": 1,
       "description": "Number of times to repeat the product against itself.",
       "type": "int"
      }
     },
     "positional": "_input, _additional_lists, repeat",
     "short_description": "cartesian product of lists",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# product => [ [ 1, \"a\" ], [ 1, \"b\" ], [ 1, \"c\" ], [ 2, \"a\" ], [ 2, \"b\" ], [ 2, \"c\" ], [ 3, \"a\" ], [ 3, \"b\" ], [ 3, \"c\" ], [ 4, \"a\" ], [ 4, \"b\" ], [ 4, \"c\" ], [ 5, \"a\" ], [ 5, \"b\" ], [ 5, \"c\" ] ]\nproduct:  \"{{ [1,2,3,4,5] | product(['a', 'b', 'c']) }}\"\n\n# repeat_original => [ [ 1, 1 ], [ 1, 2 ], [ 2, 1 ], [ 2, 2 ] ]\nrepeat_original: \"{{ [1,2] | product(repeat=2) }}\"\n\n# repeat_product => [ [ 1, \"a\", 1, \"a\" ], [ 1, \"a\", 1, \"b\" ], [ 1, \"a\", 2, \"a\" ], [ 1, \"a\", 2, \"b\" ], [ 1, \"b\", 1, \"a\" ], [ 1, \"b\", 1, \"b\" ], [ 1, \"b\", 2, \"a\" ], [ 1, \"b\", 2, \"b\" ], [ 2, \"a\", 1, \"a\" ], [ 2, \"a\", 1, \"b\" ], [ 2, \"a\", 2, \"a\" ], [ 2, \"a\", 2, \"b\" ], [ 2, \"b\", 1, \"a\" ], [ 2, \"b\", 1, \"b\" ], [ 2, \"b\", 2, \"a\" ], [ 2, \"b\", 2, \"b\" ] ]\nrepeat_product:  \"{{ [1,2] | product(['a', 'b'], repeat=2) }}\"\n\n# domains => [ 'example.com', 'ansible.com', 'redhat.com' ]\ndomains: \"{{ [ 'example', 'ansible', 'redhat'] | product(['com']) | map('join', '.') }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "List of lists of combined elements from the input lists.",
      "elements": "list",
      "type": "list"
     }
    }
   },
   "ansible.builtin.quote": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Quote a string to safely use as in a POSIX shell."
     ],
     "filename": "/ansible/plugins/filter/quote.yml",
     "name": "quote",
     "notes": [
      "This is a passthrough to Python's C(shlex.quote)."
     ],
     "options": {
      "_input": {
       "description": "String to quote.",
       "required": true,
       "type": "str"
      }
     },
     "positional": "_input",
     "short_description": "shell quoting",
     "version_added": "2.10",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "- name: Run a shell command\n  shell: echo {{ string_value | quote }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Quoted string.",
      "type": "str"
     }
    }
   },
   "ansible.builtin.random": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Use the input to either select a random element of a list or generate a random number."
     ],
     "filename": "/ansible/plugins/filter/random.yml",
     "name": "random",
     "options": {
      "_input": {
       "description": "A number or list/sequence, if it is a number it is the top bound for random  number generation, if it is a sequence or list, the source of the random element selected.",
       "required": true,
       "type": "raw"
      },
      "seed": {
       "description": "If specified use a pseudo random selection instead (repeatable).",
       "type": "str"
      },
      "start": {
       "description": "Bottom bound for the random number/element generated.",
       "type": "int"
      },
      "step": {
       "default": 1,
       "description": "Subsets the defined range by only using this value to select the increments of it between start and end.",
       "type": "int"
      }
     },
     "positional": "_input, start, step, seed",
     "short_description": "random number or list item",
     "version_added": "2.6",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# can be any item from the list\nrandom_item: \"{{ ['a','b','c'] | random }}\"\n\n# cron line, select random minute repeatable for each host\n\"{{ 60 | random(seed=inventory_hostname) }} * * * * root /script/from/cron\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Random number or list element.",
      "type": "raw"
     }
    }
   },
   "ansible.builtin.realpath": {
    "doc": {
     "author": "darkone23 (@darkone23)",
     "collection": "ansible.builtin",
     "description": [
      "Resolves/follows symlinks to return the 'real path' from a given path.",
      "Filters always run on the controller so this path is resolved using the controller's filesystem."
     ],
     "filename": "/ansible/plugins/filter/realpath.yml",
     "name": "realpath",
     "options": {
      "_input": {
       "description": "A path.",
       "required": true,
       "type": "path"
      }
     },
     "short_description": "Turn path into real path",
     "version_added": "1.8",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# realpath => /usr/bin/somebinary\nrealpath: {{ '/path/to/synlink' | realpath }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The canonical path.",
      "type": "path"
     }
    }
   },
   "ansible.builtin.regex_escape": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Escape special characters in a string for use in a regular expression."
     ],
     "filename": "/ansible/plugins/filter/regex_escape.yml",
     "name": "regex_escape",
     "notes": [
      "posix_extended is not implemented yet"
     ],
     "options": {
      "_input": {
       "description": "String to escape.",
       "required": true,
       "type": "str"
      },
      "re_type": {
       "choices": [
        "python",
        "posix_basic"
       ],
       "default": "python",
       "description": "Which type of escaping to use.",
       "type": "str"
      }
     },
     "positional": "_input, re_type",
     "short_description": "escape regex chars",
     "version_added": "2.8",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# safe_for_regex => '\\^f\\.\\*o\\(\\.\\*\\)\\$'\nsafe_for_regex: \"{{ '^f.*o(.*)$' | regex_escape() }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Escaped string.",
      "type": "str"
     }
    }
   },
   "ansible.builtin.regex_findall": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Search in a string or extract all the parts of a string matching a regular expression."
     ],
     "filename": "/ansible/plugins/filter/regex_findall.yml",
     "name": "regex_findall",
     "options": {
      "_input": {
       "description": "String to match against.",
       "required": true,
       "type": "str"
      },
      "_regex": {
       "description": "Regular expression string that defines the match.",
       "type": "str"
      },
      "ignorecase": {
       "default": false,
       "description": "Force the search to be case insensitive if V(True), case sensitive otherwise.",
       "type": "bool"
      },
      "multiline": {
       "default": false,
       "description": "Search across line endings if V(True), do not if otherwise.",
       "type": "bool"
      }
     },
     "positional": "_input, _regex",
     "short_description": "extract all regex matches from string",
     "version_added": "2.0",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# all_pirates => ['CAR', 'tar', 'bar']\nall_pirates: \"{{ 'CAR\\ntar\\nfoo\\nbar\\n' | regex_findall('^.ar$', multiline=True, ignorecase=True) }}\"\n\n# Using inline regex flags instead of passing options to filter\n# See https://docs.python.org/3/library/re.html for more information\n# on inline regex flags\n# all_pirates => ['CAR', 'tar', 'bar']\nall_pirates: \"{{ 'CAR\\ntar\\nfoo\\nbar\\n' | regex_findall('(?im)^.ar$') }}\"\n\n# get_ips => ['8.8.8.8', '8.8.4.4']\nget_ips: \"{{ 'Some DNS servers are 8.8.8.8 and 8.8.4.4' | regex_findall('\\\\b(?:[0-9]{1,3}\\\\.){3}[0-9]{1,3}\\\\b') }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "List of matched strings.",
      "elements": "str",
      "type": "list"
     }
    }
   },
   "ansible.builtin.regex_replace": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Replace a substring defined by a regular expression with another defined by another regular expression based on the first match."
     ],
     "filename": "/ansible/plugins/filter/regex_replace.yml",
     "name": "regex_replace",
     "notes": [
      "Maps to Python's C(re.sub)."
     ],
     "options": {
      "_input": {
       "description": "String to match against.",
       "required": true,
       "type": "str"
      },
      "_regex_match": {
       "description": "Regular expression string that defines the match.",
       "required": true,
       "type": "int"
      },
      "_regex_replace": {
       "description": "Regular expression string that defines the replacement.",
       "required": true,
       "type": "int"
      },
      "count": {
       "default": 0,
       "description": "Maximum number of pattern occurrences to replace. If zero, replace all occurrences.",
       "type": "int",
       "version_added": "2.17",
       "version_added_collection": "ansible.builtin"
      },
      "ignorecase": {
       "default": false,
       "description": "Force the search to be case insensitive if V(True), case sensitive otherwise.",
       "type": "bool"
      },
      "mandatory_count": {
       "default": 0,
       "description": "Except a certain number of replacements. Raises an error otherwise. If zero, ignore.",
       "type": "int",
       "version_added": "2.17",
       "version_added_collection": "ansible.builtin"
      },
      "multiline": {
       "default": false,
       "description": "Search across line endings if V(True), do not if otherwise.",
       "type": "bool"
      }
     },
     "positional": "_input, _regex_match, _regex_replace",
     "short_description": "replace a string via regex",
     "version_added": "2.0",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# whatami => 'able'\nwhatami: \"{{ 'ansible' | regex_replace('^a.*i(.*)$', 'a\\\\1') }}\"\n\n# commalocal => 'localhost, 80'\ncommalocal: \"{{ 'localhost:80' | regex_replace('^(?P<host>.+):(?P<port>\\\\d+)$', '\\\\g<host>, \\\\g<port>') }}\"\n\n# piratecomment => '#CAR\\n#tar\\nfoo\\n#bar\\n'\npiratecomment: \"{{ 'CAR\\ntar\\nfoo\\nbar\\n' | regex_replace('^(.ar)$', '#\\\\1', multiline=True, ignorecase=True) }}\"\n\n# Using inline regex flags instead of passing options to filter\n# See https://docs.python.org/3/library/re.html for more information\n# on inline regex flags\n# piratecomment => '#CAR\\n#tar\\nfoo\\n#bar\\n'\npiratecomment: \"{{ 'CAR\\ntar\\nfoo\\nbar\\n' | regex_replace('(?im)^(.ar)$', '#\\\\1') }}\"\n\n# 'foo=bar=baz' => 'foo:bar=baz'\nkey_value: \"{{ 'foo=bar=baz' | regex_replace('=', ':', count=1) }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "String with substitution (or original if no match).",
      "type": "str"
     }
    }
   },
   "ansible.builtin.regex_search": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Search in a string to extract the part that matches the regular expression."
     ],
     "filename": "/ansible/plugins/filter/regex_search.yml",
     "name": "regex_search",
     "notes": [
      "Maps to Python's C(re.search)."
     ],
     "options": {
      "_input": {
       "description": "String to match against.",
       "required": true,
       "type": "str"
      },
      "_regex": {
       "description": "Regular expression string that defines the match.",
       "type": "str"
      },
      "ignorecase": {
       "default": false,
       "description": "Force the search to be case insensitive if V(True), case sensitive otherwise.",
       "type": "bool"
      },
      "multiline": {
       "default": false,
       "description": "Search across line endings if V(True), do not if otherwise.",
       "type": "bool"
      }
     },
     "positional": "_input, _regex",
     "short_description": "extract regex match from string",
     "version_added": "2.0",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# db => 'database42'\ndb: \"{{ 'server1/database42' | regex_search('database[0-9]+') }}\"\n\n# Using inline regex flags instead of passing options to filter\n# See https://docs.python.org/3/library/re.html for more information\n# on inline regex flags\n# server => 'sErver1'\ndb: \"{{ 'sErver1/database42' | regex_search('(?i)server([0-9]+)') }}\"\n\n# drinkat => 'BAR'\ndrinkat: \"{{ 'foo\\nBAR' | regex_search('^bar', multiline=True, ignorecase=True) }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Matched string or empty string if no match.",
      "type": "str"
     }
    }
   },
   "ansible.builtin.rekey_on_member": {
    "doc": {
     "collection": "ansible.builtin",
     "description": "Iterate over several iterables in parallel, producing tuples with an item from each one.",
     "filename": "/ansible/plugins/filter/rekey_on_member.yml",
     "name": "rekey_on_member",
     "options": {
      "_input": {
       "description": "Original dictionary.",
       "required": true,
       "type": "dict"
      },
      "_key": {
       "description": "The key to rekey.",
       "required": true,
       "type": "str"
      },
      "duplicates": {
       "choices": [
        "overwrite",
        "error"
       ],
       "default": "error",
       "description": "How to handle duplicates.",
       "type": "str"
      }
     },
     "positional": "_input, '_key', duplicates",
     "short_description": "Rekey a list of dicts into a dict using a member",
     "version_added": "2.13",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# mydict => {'eigrp': {'state': 'enabled', 'proto': 'eigrp'}, 'ospf': {'state': 'enabled', 'proto': 'ospf'}}\n mydict: '{{ [{\"proto\": \"eigrp\", \"state\": \"enabled\"}, {\"proto\": \"ospf\", \"state\": \"enabled\"}] | rekey_on_member(\"proto\") }}'\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The resulting dictionary.",
      "type": "dict"
     }
    }
   },
   "ansible.builtin.relpath": {
    "doc": {
     "author": "Jakub Jirutka (@jirutka)",
     "collection": "ansible.builtin",
     "description": [
      "Converts the given path to a relative path from the O(start), or relative to the directory given in O(start)."
     ],
     "filename": "/ansible/plugins/filter/relpath.yml",
     "name": "relpath",
     "options": {
      "_input": {
       "description": "A path.",
       "required": true,
       "type": "str"
      },
      "start": {
       "description": "The directory the path should be relative to. If not supplied the current working directory will be used.",
       "type": "str"
      }
     },
     "positional": "_input, start",
     "short_description": "Make a path relative",
     "version_added": "1.7",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# foobar => ../test/me.txt\ntesting: \"{{ '/tmp/test/me.txt' | relpath('/tmp/other/') }}\"\notherrelpath: \"{{ mypath | relpath(mydir) }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The relative path.",
      "type": "str"
     }
    }
   },
   "ansible.builtin.root": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Math operation that returns the Nth root of inputed number C(X ^^ N)."
     ],
     "filename": "/ansible/plugins/filter/root.yml",
     "name": "root",
     "options": {
      "_input": {
       "description": "Number to operate on.",
       "required": true,
       "type": "float"
      },
      "base": {
       "default": 2,
       "description": "Which root to take.",
       "type": "float"
      }
     },
     "positional": "_input, base",
     "short_description": "root of (math operation)",
     "version_added": "1.9",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# => 8\nfiveroot: \"{{ 32768 | root(5) }}\"\n\n# 2\nsqrt_of_2: \"{{ 4 | root }}\"\n\n# me ^^ 3\ncuberoot_me: \"{{ me | root(3) }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Resulting number.",
      "type": "float"
     }
    }
   },
   "ansible.builtin.sha1": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Returns a L(SHA-1 hash, https://en.wikipedia.org/wiki/SHA-1) of the input data."
     ],
     "filename": "/ansible/plugins/filter/sha1.yml",
     "name": "sha1",
     "notes": [
      "This requires the SHA-1 algorithm to be available on the system, security contexts like FIPS might prevent this.",
      "SHA-1 has been deemed insecure and is not recommended for security related uses."
     ],
     "options": {
      "_input": {
       "description": "Data to hash.",
       "required": true,
       "type": "raw"
      }
     },
     "positional": "_input",
     "short_description": "SHA-1 hash of input data",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# sha1hash => \"dc724af18fbdd4e59189f5fe768a5f8311527050\"\nsha1hash: \"{{ 'testing' | sha1 }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The SHA-1 hash of the input.",
      "type": "string"
     }
    }
   },
   "ansible.builtin.shuffle": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Take the elements of the input list and return in a random order."
     ],
     "filename": "/ansible/plugins/filter/shuffle.yml",
     "name": "shuffle",
     "options": {
      "_input": {
       "description": "A number or list to randomize.",
       "elements": "any",
       "required": true,
       "type": "list"
      },
      "seed": {
       "description": "If specified use a pseudo random selection instead (repeatable).",
       "type": "str"
      }
     },
     "positional": "_input",
     "short_description": "randomize a list",
     "version_added": "2.6",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\nrandomized_list: \"{{ ['a','b','c'] | shuffle}}\"\nper_host_repeatable: \"{{ ['a','b','c'] | shuffle(seed=inventory_hostname) }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Random number or list element.",
      "elements": "any",
      "type": "list"
     }
    }
   },
   "ansible.builtin.split": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Using Python's text object method C(split) we turn strings into lists via a 'splitting character'."
     ],
     "filename": "/ansible/plugins/filter/split.yml",
     "name": "split",
     "notes": [
      "This is a passthrough to Python's C(str.split)."
     ],
     "options": {
      "_input": {
       "description": "A string to split.",
       "required": true,
       "type": "str"
      },
      "_split_string": {
       "default": " ",
       "description": "A string on which to split the original.",
       "type": "str"
      }
     },
     "positional": "_input, _split_string",
     "short_description": "split a string into a list",
     "version_added": 2.11,
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# listjojo => [ \"jojo\", \"is\", \"a\" ]\nlistjojo: \"{{ 'jojo is a' | split }}\"\n\n# listjojocomma => [ \"jojo is\", \"a\" ]\nlistjojocomma: \"{{ 'jojo is, a' | split(',') }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "List of substrings split from the original.",
      "elements": "str",
      "type": "list"
     }
    }
   },
   "ansible.builtin.splitext": {
    "doc": {
     "author": "Matt Martz (@sivel)",
     "collection": "ansible.builtin",
     "description": [
      "Returns a list of two, with the elements consisting of filename root and extension."
     ],
     "filename": "/ansible/plugins/filter/splitext.yml",
     "name": "splitext",
     "options": {
      "_input": {
       "description": "A path.",
       "required": true,
       "type": "str"
      }
     },
     "positional": "_input",
     "short_description": "split a path into root and file extension",
     "version_added": "2.0",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# gobble => [ '/etc/make', 'conf' ]\ngobble: \"{{ '/etc/make.conf' | splitext }}\"\n\n# file_n_ext => [ 'ansible', 'cfg' ]\nfile_n_ext: \"{{ 'ansible.cfg' | splitext }}\"\n\n# hoax => ['/etc/hoasdf', '']\nhoax: '{{ \"/etc//hoasdf/\" | splitext }}'\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "A list consisting of root of the path and the extension.",
      "elements": "str",
      "type": "list"
     }
    }
   },
   "ansible.builtin.strftime": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Using Python's C(strftime) function, take a data formating string and a date/time to create a formated date."
     ],
     "filename": "/ansible/plugins/filter/strftime.yml",
     "name": "strftime",
     "notes": [
      "This is a passthrough to Python's C(stftime), for a complete set of formatting options go to https://strftime.org/."
     ],
     "options": {
      "_input": {
       "description": [
        "A formating string following C(stftime) conventions.",
        "See L(the Python documentation, https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior) for a reference."
       ],
       "required": true,
       "type": "str"
      },
      "second": {
       "description": "Datetime in seconds from C(epoch) to format, if not supplied C(gmttime/localtime) will be used.",
       "type": "int"
      },
      "utc": {
       "default": false,
       "description": "Whether time supplied is in UTC.",
       "type": "bool"
      }
     },
     "positional": "_input, second, utc",
     "short_description": "date formating",
     "version_added": "2.4",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# for a complete set of features go to  https://strftime.org/\n\n# Display year-month-day\n{{ '%Y-%m-%d' | strftime }}\n# => \"2021-03-19\"\n\n# Display hour:min:sec\n{{ '%H:%M:%S' | strftime }}\n# => \"21:51:04\"\n\n# Use ansible_date_time.epoch fact\n{{ '%Y-%m-%d %H:%M:%S' | strftime(ansible_date_time.epoch) }}\n# => \"2021-03-19 21:54:09\"\n\n# Use arbitrary epoch value\n{{ '%Y-%m-%d' | strftime(0) }}          # => 1970-01-01\n{{ '%Y-%m-%d' | strftime(1441357287) }} # => 2015-09-04\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "A formatted date/time string.",
      "type": "str"
     }
    }
   },
   "ansible.builtin.subelements": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "This produces a product of an object and the subelement values of that object, similar to the subelements lookup. This lets you specify individual subelements to use in a template O(_input)."
     ],
     "filename": "/ansible/plugins/filter/subelements.yml",
     "name": "subelements",
     "options": {
      "_input": {
       "description": "Original list.",
       "elements": "any",
       "required": true,
       "type": "list"
      },
      "_subelement": {
       "description": "Label of property to extract from original list items.",
       "required": true,
       "type": "str"
      },
      "skip_missing": {
       "default": false,
       "description": "If V(True), ignore missing subelements, otherwise missing subelements generate an error.",
       "type": "bool"
      }
     },
     "positional": "_input, _subelement, skip_missing",
     "short_description": "returns a product of a list and its elements",
     "version_added": "2.7",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# data\nusers:\n  - groups: [1,2,3]\n    name: lola\n  - name: fernando\n    groups: [2,3,4]\n\n# user_w_groups =>[ { \"groups\": [ 1, 2, 3 ], \"name\": \"lola\" }, 1 ], [ { \"groups\": [ 1, 2, 3 ], \"name\": \"lola\" }, 2 ], [ { \"groups\": [ 1, 2, 3 ], \"name\": \"lola\" }, 3 ], [ { \"groups\": [ 2, 3, 4 ], \"name\": \"fernando\" }, 2 ], [ { \"groups\": [ 2, 3, 4 ], \"name\": \"fernando\" }, 3 ], [ { \"groups\": [ 2, 3, 4 ], \"name\": \"fernando\" }, 4 ] ]\nusers_w_groups: {{ users | subelements('groups', skip_missing=True) }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "List made of original list and product of the subelement list.",
      "elements": "any",
      "type": "list"
     }
    }
   },
   "ansible.builtin.symmetric_difference": {
    "doc": {
     "author": "Brian Coca (@bcoca)",
     "collection": "ansible.builtin",
     "description": [
      "Provide a unique list of all the elements unique to each list.",
      "Items in the resulting list are returned in arbitrary order."
     ],
     "filename": "/ansible/plugins/filter/symmetric_difference.yml",
     "name": "symmetric_difference",
     "options": {
      "_input": {
       "description": "A list.",
       "required": true,
       "type": "list"
      },
      "_second_list": {
       "description": "A list.",
       "required": true,
       "type": "list"
      }
     },
     "seealso": [
      {
       "plugin": "ansible.builtin.difference",
       "plugin_type": "filter"
      },
      {
       "plugin": "ansible.builtin.intersect",
       "plugin_type": "filter"
      },
      {
       "plugin": "ansible.builtin.union",
       "plugin_type": "filter"
      },
      {
       "plugin": "ansible.builtin.unique",
       "plugin_type": "filter"
      }
     ],
     "short_description": "different items from two lists",
     "version_added": "1.4",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# return the elements of list1 not in list2 and the elements in list2 not in list1\n# list1: [1, 2, 5, 1, 3, 4, 10]\n# list2: [1, 2, 3, 4, 5, 11, 99]\n{{ list1 | symmetric_difference(list2) }}\n# => [10, 11, 99]\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "A unique list of the elements from two lists that are unique to each one.",
      "type": "list"
     }
    }
   },
   "ansible.builtin.ternary": {
    "doc": {
     "author": "Brian Coca (@bcoca)",
     "collection": "ansible.builtin",
     "description": [
      "Return the first value if the input is V(True), the second if V(False)."
     ],
     "filename": "/ansible/plugins/filter/ternary.yml",
     "name": "ternary",
     "notes": [
      "Vars as values are evaluated even when not returned. This is due to them being evaluated before being passed into the filter."
     ],
     "options": {
      "_input": {
       "description": "A boolean expression, must evaluate to V(True) or V(False).",
       "required": true,
       "type": "bool"
      },
      "false_val": {
       "description": "Value to return if the input is V(False).",
       "type": "any"
      },
      "none_val": {
       "description": "Value to return if the input is V(None). If not set, V(None) will be treated as V(False).",
       "type": "any",
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      },
      "true_val": {
       "description": "Value to return if the input is V(True).",
       "required": true,
       "type": "any"
      }
     },
     "positional": "true_val, false_val",
     "short_description": "Ternary operation filter",
     "version_added": "1.9",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# set first 10 volumes rw, rest as dp\nvolume_mode: \"{{ (item|int < 11)|ternary('rw', 'dp') }}\"\n\n# choose correct vpc subnet id, note that vars as values are evaluated even if not returned\nvpc_subnet_id: \"{{ (ec2_subnet_type == 'public') | ternary(ec2_vpc_public_subnet_id, ec2_vpc_private_subnet_id) }}\"\n\n- name: service-foo, use systemd module unless upstart is present, then use old service module\n  service:\n    state: restarted\n    enabled: yes\n    use: \"{{ (ansible_service_mgr == 'upstart') | ternary('service', 'systemd') }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The value indicated by the input.",
      "type": "any"
     }
    }
   },
   "ansible.builtin.to_datetime": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Using the input string attempt to create a matching Python C(datetime) object."
     ],
     "filename": "/ansible/plugins/filter/to_datetime.yml",
     "name": "to_datetime",
     "notes": [
      "For a full list of format codes for working with Python date format strings, see L(the Python documentation, https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior)."
     ],
     "options": {
      "_input": {
       "description": "A string containing date time information.",
       "required": true,
       "type": "str"
      },
      "format": {
       "description": "C(strformat) formatted string that describes the expected format of the input string.",
       "type": "str"
      }
     },
     "positional": "_input",
     "short_description": "Get C(datetime) from string",
     "version_added": "2.4",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# Get total amount of seconds between two dates. Default date format is %Y-%m-%d %H:%M:%S but you can pass your own format\nsecsdiff: '{{ ((\"2016-08-14 20:00:12\" | to_datetime) - (\"2015-12-25\" | to_datetime(\"%Y-%m-%d\"))).total_seconds()  }}'\n\n# Get remaining seconds after delta has been calculated. NOTE: This does NOT convert years, days, hours, and so on to seconds. For that, use total_seconds()\n{{ ((\"2016-08-14 20:00:12\" | to_datetime) - (\"2016-08-14 18:00:00\" | to_datetime)).seconds  }}\n# This expression evaluates to \"12\" and not \"132\". Delta is 2 hours, 12 seconds\n\n# get amount of days between two dates. This returns only number of days and discards remaining hours, minutes, and seconds\n{{ ((\"2016-08-14 20:00:12\" | to_datetime) - (\"2015-12-25\" | to_datetime('%Y-%m-%d'))).days  }}\n\n# difference between to dotnet (100ns precision) and iso8601 microsecond timestamps\n# the date1_short regex replace will work for any timestamp that has a higher than microsecond precision\n# by cutting off anything more precise than microseconds\nvars:\n  date1: '2022-11-15T03:23:13.6869568Z'\n  date2: '2021-12-15T16:06:24.400087Z'\n  date1_short: '{{ date1|regex_replace(\"([^.]+)(\\.\\d{6})(\\d*)(.+)\", \"\\1\\2\\4\") }}' # shorten to microseconds\n  iso8601format: '%Y-%m-%dT%H:%M:%S.%fZ'\n  date_diff_isoed: '{{ (date1_short|to_datetime(iso8601format) - date2|to_datetime(iso8601format)).total_seconds() }}'\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "C(datetime) object from the represented value.",
      "type": "raw"
     }
    }
   },
   "ansible.builtin.to_json": {
    "doc": {
     "author": "core team",
     "collection": "ansible.builtin",
     "description": [
      "Converts an Ansible variable into a JSON string representation.",
      "This filter functions as a wrapper to the Python C(json.dumps) function.",
      "Ansible internally auto-converts JSON strings into variable structures so this plugin is used to force it into a JSON string."
     ],
     "filename": "/ansible/plugins/filter/to_json.yml",
     "name": "to_json",
     "notes": [
      "Both O(vault_to_text) and O(preprocess_unsafe) defaulted to V(False) between Ansible 2.9 and 2.12.",
      "These parameters to C(json.dumps) will be ignored, as they are overridden internally: I(cls), I(default)"
     ],
     "options": {
      "_input": {
       "description": "A variable or expression that returns a data structure.",
       "required": true,
       "type": "raw"
      },
      "allow_nan": {
       "default": true,
       "description": "When V(False), strict adherence to float value limits of the JSON specifications, so C(nan), C(inf) and C(-inf) values will produce errors. When V(True), JavaScript equivalents will be used (C(NaN), C(Infinity), C(-Infinity)).",
       "type": "bool"
      },
      "check_circular": {
       "default": true,
       "description": "Controls the usage of the internal circular reference detection, if off can result in overflow errors.",
       "type": "bool"
      },
      "ensure_ascii": {
       "default": true,
       "description": "Escapes all non ASCII characters.",
       "type": "bool"
      },
      "indent": {
       "default": 0,
       "description": "Number of spaces to indent Python structures, mainly used for display to humans.",
       "type": "integer"
      },
      "preprocess_unsafe": {
       "default": true,
       "description": "Toggle to represent unsafe values directly in JSON or create a unsafe object in JSON.",
       "type": "bool",
       "version_added": "2.9",
       "version_added_collection": "ansible.builtin"
      },
      "separators": {
       "default": "(', ', ': ')",
       "description": "The C(item) and C(key) separator to be used in the serialized output, default may change depending on O(indent) and Python version.",
       "type": "tuple"
      },
      "skipkeys": {
       "default": false,
       "description": "If V(True), keys that are not basic Python types will be skipped.",
       "type": "bool"
      },
      "sort_keys": {
       "default": false,
       "description": "Affects sorting of dictionary keys.",
       "type": "bool"
      },
      "vault_to_text": {
       "default": true,
       "description": "Toggle to either unvault a vault or create the JSON version of a vaulted object.",
       "type": "bool",
       "version_added": "2.9",
       "version_added_collection": "ansible.builtin"
      }
     },
     "short_description": "Convert variable to JSON string",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# dump variable in a template to create a JSON document\n{{ docker_config | to_json }}\n\n# same as above but 'prettier' (equivalent to to_nice_json filter)\n{{ docker_config | to_json(indent=4, sort_keys=True) }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The JSON serialized string representing the variable structure inputted.",
      "type": "string"
     }
    }
   },
   "ansible.builtin.to_nice_json": {
    "doc": {
     "author": "core team",
     "collection": "ansible.builtin",
     "description": [
      "Converts an Ansible variable into a 'nicely formatted' JSON string representation",
      "This filter functions as a wrapper to the Python C(json.dumps) function.",
      "Ansible automatically converts JSON strings into variable structures so this plugin is used to forcibly retain a JSON string."
     ],
     "filename": "/ansible/plugins/filter/to_nice_json.yml",
     "name": "to_nice_json",
     "notes": [
      "Both O(vault_to_text) and O(preprocess_unsafe) defaulted to V(False) between Ansible 2.9 and 2.12.",
      "These parameters to C(json.dumps) will be ignored, they are overridden for internal use: I(cls), I(default), I(indent), I(separators), I(sort_keys)."
     ],
     "options": {
      "_input": {
       "description": "A variable or expression that returns a data structure.",
       "required": true,
       "type": "raw"
      },
      "allow_nan": {
       "default": true,
       "description": "When V(False), strict adherence to float value limits of the JSON specification, so C(nan), C(inf) and C(-inf) values will produce errors. When V(True), JavaScript equivalents will be used (C(NaN), C(Infinity), C(-Infinity)).",
       "type": "bool"
      },
      "check_circular": {
       "default": true,
       "description": "Controls the usage of the internal circular reference detection, if off can result in overflow errors.",
       "type": "bool"
      },
      "ensure_ascii": {
       "default": true,
       "description": "Escapes all non ASCII characters.",
       "type": "bool"
      },
      "preprocess_unsafe": {
       "default": true,
       "description": "Toggle to represent unsafe values directly in JSON or create a unsafe object in JSON.",
       "type": "bool",
       "version_added": "2.9",
       "version_added_collection": "ansible.builtin"
      },
      "skipkeys": {
       "default": false,
       "description": "If V(True), keys that are not basic Python types will be skipped.",
       "type": "bool"
      },
      "vault_to_text": {
       "default": true,
       "description": "Toggle to either unvault a vault or create the JSON version of a vaulted object.",
       "type": "bool",
       "version_added": "2.9",
       "version_added_collection": "ansible.builtin"
      }
     },
     "short_description": "Convert variable to 'nicely formatted' JSON string",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# dump variable in a template to create a nicely formatted JSON document\n{{ docker_config | to_nice_json }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The 'nicely formatted' JSON serialized string representing the variable structure inputted.",
      "type": "string"
     }
    }
   },
   "ansible.builtin.to_nice_yaml": {
    "doc": {
     "author": "core team",
     "collection": "ansible.builtin",
     "description": [
      "Converts an Ansible variable into a YAML string representation.",
      "This filter functions as a wrapper to the L(Python PyYAML library, https://pypi.org/project/PyYAML/)'s C(yaml.dump) function.",
      "Ansible internally auto-converts YAML strings into variable structures so this plugin is used to force it into a YAML string."
     ],
     "filename": "/ansible/plugins/filter/to_nice_yaml.yml",
     "name": "to_yaml",
     "notes": [
      "More options may be available, see L(PyYAML documentation, https://pyyaml.org/wiki/PyYAMLDocumentation) for details.",
      "These parameters to C(yaml.dump) will be ignored, as they are overridden internally: I(default_flow_style)"
     ],
     "options": {
      "_input": {
       "description": "A variable or expression that returns a data structure.",
       "required": true,
       "type": "raw"
      },
      "indent": {
       "description": "Number of spaces to indent Python structures, mainly used for display to humans.",
       "type": "integer"
      },
      "sort_keys": {
       "default": true,
       "description": "Affects sorting of dictionary keys.",
       "type": "bool"
      }
     },
     "positional": "_input",
     "short_description": "Convert variable to YAML string",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# dump variable in a template to create a YAML document\n{{ github_workflow | to_nice_yaml }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The YAML serialized string representing the variable structure inputted.",
      "type": "string"
     }
    }
   },
   "ansible.builtin.to_uuid": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Use to generate namespeced Universal Unique ID."
     ],
     "filename": "/ansible/plugins/filter/to_uuid.yml",
     "name": "to_uuid",
     "options": {
      "_input": {
       "description": "String to use as base fo the UUID.",
       "required": true,
       "type": "str"
      },
      "namespace": {
       "default": "361E6D51-FAEC-444A-9079-341386DA8E2E",
       "description": "UUID namespace to use.",
       "type": "str"
      }
     },
     "positional": "_input, namespace",
     "short_description": "namespaced UUID generator",
     "version_added": "2.9",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# To create a namespaced UUIDv5\nuuid: \"{{ string | to_uuid(namespace='11111111-2222-3333-4444-555555555555') }}\"\n\n\n# To create a namespaced UUIDv5 using the default Ansible namespace '361E6D51-FAEC-444A-9079-341386DA8E2E'\nuuid: \"{{ string | to_uuid }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Generated UUID.",
      "type": "string"
     }
    }
   },
   "ansible.builtin.to_yaml": {
    "doc": {
     "author": "core team",
     "collection": "ansible.builtin",
     "description": [
      "Converts an Ansible variable into a YAML string representation.",
      "This filter functions as a wrapper to the L(Python PyYAML library, https://pypi.org/project/PyYAML/)'s C(yaml.dump) function.",
      "Ansible automatically converts YAML strings into variable structures so this plugin is used to forcibly retain a YAML string."
     ],
     "filename": "/ansible/plugins/filter/to_yaml.yml",
     "name": "to_yaml",
     "notes": [
      "More options may be available, see L(PyYAML documentation, https://pyyaml.org/wiki/PyYAMLDocumentation) for details."
     ],
     "options": {
      "_input": {
       "description": "A variable or expression that returns a data structure.",
       "required": true,
       "type": "raw"
      },
      "indent": {
       "description": "Number of spaces to indent Python structures, mainly used for display to humans.",
       "type": "integer"
      },
      "sort_keys": {
       "default": true,
       "description": "Affects sorting of dictionary keys.",
       "type": "bool"
      }
     },
     "positional": "_input",
     "short_description": "Convert variable to YAML string",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# dump variable in a template to create a YAML document\n{{ github_workflow | to_yaml }}\n\n# same as above but 'prettier' (equivalent to to_nice_yaml filter)\n{{ docker_config | to_yaml(indent=4) }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The YAML serialized string representing the variable structure inputted.",
      "type": "string"
     }
    }
   },
   "ansible.builtin.type_debug": {
    "doc": {
     "author": "Adrian Likins (@alikins)",
     "collection": "ansible.builtin",
     "description": [
      "Returns the equivalent of Python's C(type) function."
     ],
     "filename": "/ansible/plugins/filter/type_debug.yml",
     "name": "type_debug",
     "options": {
      "_input": {
       "description": "Variable or expression of which you want to determine type.",
       "required": true,
       "type": "any"
      }
     },
     "short_description": "show input data type",
     "version_added": "2.3",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# get type of 'myvar'\n{{ myvar | type_debug }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The Python 'type' of the O(_input) provided.",
      "type": "string"
     }
    }
   },
   "ansible.builtin.union": {
    "doc": {
     "author": "Brian Coca (@bcoca)",
     "collection": "ansible.builtin",
     "description": [
      "Provide a unique list of all the elements of two lists.",
      "Items in the resulting list are returned in arbitrary order."
     ],
     "filename": "/ansible/plugins/filter/union.yml",
     "name": "union",
     "options": {
      "_input": {
       "description": "A list.",
       "required": true,
       "type": "list"
      },
      "_second_list": {
       "description": "A list.",
       "required": true,
       "type": "list"
      }
     },
     "seealso": [
      {
       "plugin": "ansible.builtin.difference",
       "plugin_type": "filter"
      },
      {
       "plugin": "ansible.builtin.intersect",
       "plugin_type": "filter"
      },
      {
       "plugin": "ansible.builtin.symmetric_difference",
       "plugin_type": "filter"
      },
      {
       "plugin": "ansible.builtin.unique",
       "plugin_type": "filter"
      }
     ],
     "short_description": "union of lists",
     "version_added": "1.4",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# return the unique elements of list1 added to list2\n# list1: [1, 2, 5, 1, 3, 4, 10]\n# list2: [1, 2, 3, 4, 5, 11, 99]\n{{ list1 | union(list2) }}\n# => [1, 2, 5, 3, 4, 10, 11, 99]\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "A unique list of all the elements from both lists.",
      "type": "list"
     }
    }
   },
   "ansible.builtin.unique": {
    "doc": {
     "author": "Brian Coca (@bcoca)",
     "collection": "ansible.builtin",
     "description": [
      "Creates a list of unique elements (a set) from the provided input list."
     ],
     "filename": "/ansible/plugins/filter/unique.yml",
     "name": "unique",
     "options": {
      "_input": {
       "description": "A list.",
       "required": true,
       "type": "list"
      }
     },
     "seealso": [
      {
       "plugin": "ansible.builtin.difference",
       "plugin_type": "filter"
      },
      {
       "plugin": "ansible.builtin.intersect",
       "plugin_type": "filter"
      },
      {
       "plugin": "ansible.builtin.symmetric_difference",
       "plugin_type": "filter"
      },
      {
       "plugin": "ansible.builtin.union",
       "plugin_type": "filter"
      }
     ],
     "short_description": "set of unique items of a list",
     "version_added": "1.4",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# return only the unique elements of list1\n# list1: [1, 2, 5, 1, 3, 4, 10]\n{{ list1 | unique }}\n# => [1, 2, 5, 3, 4, 10]\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "A list with unique elements, also known as a set.",
      "type": "list"
     }
    }
   },
   "ansible.builtin.unvault": {
    "doc": {
     "author": "Brian Coca (@bcoca)",
     "collection": "ansible.builtin",
     "description": [
      "Retrieve your information from an encrypted Ansible Vault."
     ],
     "filename": "/ansible/plugins/filter/unvault.yml",
     "name": "unvault",
     "options": {
      "_input": {
       "description": "Vault string, or an C(AnsibleVaultEncryptedUnicode) string object.",
       "required": true,
       "type": "string"
      },
      "secret": {
       "description": "Vault secret, the key that lets you open the vault.",
       "required": true,
       "type": "string"
      },
      "vault_id": {
       "default": "filter_default",
       "description": "Secret identifier, used internally to try to best match a secret when multiple are provided.",
       "type": "string"
      }
     },
     "positional": "secret",
     "short_description": "Open an Ansible Vault",
     "version_added": "2.12",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# simply decrypt my key from a vault\nvars:\n  mykey: \"{{ myvaultedkey | unvault(passphrase) }} \"\n\n- name: save templated unvaulted data\n  template: src=dump_template_data.j2 dest=/some/key/clear.txt\n  vars:\n    template_data: '{{ secretdata | unvault(vaultsecret) }}'\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The string that was contained in the vault.",
      "type": "string"
     }
    }
   },
   "ansible.builtin.urldecode": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Replace %xx escapes with their single-character equivalent in the given string.",
      "Also replace plus signs with spaces, as required for unquoting HTML form values."
     ],
     "filename": "/ansible/plugins/filter/urldecode.yml",
     "name": "urldecode",
     "options": {
      "_input": {
       "description": "URL encoded string to decode.",
       "required": true,
       "type": "str"
      }
     },
     "positional": "_input",
     "short_description": "Decode percent-encoded sequences",
     "version_added": "2.4",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# Decode urlencoded string\n{{ '%7e/abc+def' | urldecode }}\n# => \"~/abc def\"\n\n# Decode plus sign as well\n{{ 'El+Ni%C3%B1o' | urldecode }}\n# => \"El Ni\u00f1o\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": [
       "URL decoded value for the given string"
      ],
      "type": "any"
     }
    }
   },
   "ansible.builtin.urlsplit": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Split a URL into its component parts."
     ],
     "filename": "/ansible/plugins/filter/urlsplit.py",
     "name": "urlsplit",
     "options": {
      "_input": {
       "description": "URL string to split.",
       "required": true,
       "type": "str"
      },
      "query": {
       "choices": [
        "fragment",
        "hostname",
        "netloc",
        "password",
        "path",
        "port",
        "query",
        "scheme",
        "username"
       ],
       "description": "Specify a single component to return.",
       "type": "str"
      }
     },
     "positional": "_input, query",
     "short_description": "get components from URL",
     "version_added": "2.4",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n\n    parts: '{{ \"http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment\" | urlsplit }}'\n    # =>\n    #   {\n    #       \"fragment\": \"fragment\",\n    #       \"hostname\": \"www.acme.com\",\n    #       \"netloc\": \"user:password@www.acme.com:9000\",\n    #       \"password\": \"password\",\n    #       \"path\": \"/dir/index.html\",\n    #       \"port\": 9000,\n    #       \"query\": \"query=term\",\n    #       \"scheme\": \"http\",\n    #       \"username\": \"user\"\n    #   }\n\n    hostname: '{{ \"http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment\" | urlsplit(\"hostname\") }}'\n    # => 'www.acme.com'\n\n    query: '{{ \"http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment\" | urlsplit(\"query\") }}'\n    # => 'query=term'\n\n    path: '{{ \"http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment\" | urlsplit(\"path\") }}'\n    # => '/dir/index.html'\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": [
       "A dictionary with components as keyword and their value.",
       "If O(query) is provided, a string or integer will be returned instead, depending on O(query)."
      ],
      "type": "any"
     }
    }
   },
   "ansible.builtin.vault": {
    "doc": {
     "author": "Brian Coca (@bcoca)",
     "collection": "ansible.builtin",
     "description": [
      "Put your information into an encrypted Ansible Vault."
     ],
     "filename": "/ansible/plugins/filter/vault.yml",
     "name": "vault",
     "options": {
      "_input": {
       "description": "Data to vault.",
       "required": true,
       "type": "string"
      },
      "salt": {
       "description": [
        "Encryption salt, will be random if not provided.",
        "While providing one makes the resulting encrypted string reproducible, it can lower the security of the vault."
       ],
       "type": "string"
      },
      "secret": {
       "description": "Vault secret, the key that lets you open the vault.",
       "required": true,
       "type": "string"
      },
      "vault_id": {
       "default": "filter_default",
       "description": "Secret identifier, used internally to try to best match a secret when multiple are provided.",
       "type": "string"
      },
      "wrap_object": {
       "default": false,
       "description": [
        "This toggle can force the return of an C(AnsibleVaultEncryptedUnicode) string object, when V(False), you get a simple string.",
        "Mostly useful when combining with the C(to_yaml) filter to output the 'inline vault' format."
       ],
       "type": "bool"
      }
     },
     "positional": "secret",
     "short_description": "vault your secrets",
     "version_added": "2.12",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# simply encrypt my key in a vault\nvars:\n  myvaultedkey: \"{{ keyrawdata|vault(passphrase) }} \"\n\n- name: save templated vaulted data\n  template: src=dump_template_data.j2 dest=/some/key/vault.txt\n  vars:\n    mysalt: '{{2**256|random(seed=inventory_hostname)}}'\n    template_data: '{{ secretdata|vault(vaultsecret, salt=mysalt) }}'\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The vault string that contains the secret data (or C(AnsibleVaultEncryptedUnicode) string object).",
      "type": "string"
     }
    }
   },
   "ansible.builtin.win_basename": {
    "doc": {
     "author": "ansible core team",
     "collection": "ansible.builtin",
     "description": [
      "Returns the last name component of a Windows path, what is left in the string that is not 'win_dirname'."
     ],
     "filename": "/ansible/plugins/filter/win_basename.yml",
     "name": "win_basename",
     "options": {
      "_input": {
       "description": "A Windows path.",
       "required": true,
       "type": "str"
      }
     },
     "seealso": [
      {
       "plugin": "ansible.builtin.win_dirname",
       "plugin_type": "filter"
      }
     ],
     "short_description": "Get a Windows path's base name",
     "version_added": "2.0",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# To get the last name of a file Windows path, like 'foo.txt' out of 'C:\\Users\\asdf\\foo.txt'\n{{ mypath | win_basename }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The base name from the Windows path provided.",
      "type": "str"
     }
    }
   },
   "ansible.builtin.win_dirname": {
    "doc": {
     "author": "ansible core team",
     "collection": "ansible.builtin",
     "description": [
      "Returns the directory component of a Windows path, what is left in the string that is not 'win_basename'."
     ],
     "filename": "/ansible/plugins/filter/win_dirname.yml",
     "name": "win_dirname",
     "options": {
      "_input": {
       "description": "A Windows path.",
       "required": true,
       "type": "str"
      }
     },
     "seealso": [
      {
       "plugin": "ansible.builtin.win_basename",
       "plugin_type": "filter"
      }
     ],
     "short_description": "Get a Windows path's directory",
     "version_added": "2.0",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# To get the last name of a file Windows path, like 'C:\\users\\asdf' out of 'C:\\Users\\asdf\\foo.txt'\n{{ mypath | win_dirname }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The directory from the Windows path provided.",
      "type": "str"
     }
    }
   },
   "ansible.builtin.win_splitdrive": {
    "doc": {
     "author": "ansible core team",
     "collection": "ansible.builtin",
     "description": [
      "Returns a list with the first component being the drive letter and the second, the rest of the path."
     ],
     "filename": "/ansible/plugins/filter/win_splitdrive.yml",
     "name": "win_splitdrive",
     "options": {
      "_input": {
       "description": "A Windows path.",
       "required": true,
       "type": "str"
      }
     },
     "short_description": "Split a Windows path by the drive letter",
     "version_added": "2.0",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# To get the last name of a file Windows path, like ['C', '\\Users\\asdf\\foo.txt'] out of 'C:\\Users\\asdf\\foo.txt'\n{{ mypath | win_splitdrive }}\n\n# just the drive letter\n{{ mypath | win_splitdrive | first }}\n\n# path w/o drive letter\n{{ mypath | win_splitdrive | last }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "List in which the first element is the drive letter and the second the rest of the path.",
      "elements": "str",
      "type": "list"
     }
    }
   },
   "ansible.builtin.zip": {
    "doc": {
     "collection": "ansible.builtin",
     "description": "Iterate over several iterables in parallel, producing tuples with an item from each one.",
     "filename": "/ansible/plugins/filter/zip.yml",
     "name": "zip",
     "notes": [
      "This is mostly a passthrough to Python's C(zip) function."
     ],
     "options": {
      "_additional_lists": {
       "description": "Additional list(s).",
       "elements": "any",
       "required": true,
       "type": "list"
      },
      "_input": {
       "description": "Original list.",
       "elements": "any",
       "required": true,
       "type": "list"
      },
      "strict": {
       "default": false,
       "description": "If V(True) return an error on mismatching list length, otherwise shortest list determines output.",
       "type": "bool"
      }
     },
     "positional": "_input, _additional_lists",
     "short_description": "combine list elements",
     "version_added": "2.3",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# two => [[1, \"a\"], [2, \"b\"], [3, \"c\"], [4, \"d\"], [5, \"e\"], [6, \"f\"]]\ntwo: \"{{ [1,2,3,4,5,6] | zip(['a','b','c','d','e','f']) }}\"\n\n# three => [ [ 1, \"a\", \"d\" ], [ 2, \"b\", \"e\" ], [ 3, \"c\", \"f\" ] ]\nthree: \"{{ [1,2,3] | zip(['a','b','c'], ['d','e','f']) }}\"\n\n# shorter => [[1, \"a\"], [2, \"b\"], [3, \"c\"]]\nshorter: \"{{ [1,2,3] | zip(['a','b','c','d','e','f']) }}\"\n\n# compose dict from lists of keys and values\nmydcit: \"{{ dict(keys_list | zip(values_list)) }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "List of lists made of elements matching the positions of the input lists.",
      "elements": "list",
      "type": "list"
     }
    }
   },
   "ansible.builtin.zip_longest": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Make an iterator that aggregates elements from each of the iterables. If the iterables are of uneven length, missing values are filled-in with O(fillvalue). Iteration continues until the longest iterable is exhausted."
     ],
     "filename": "/ansible/plugins/filter/zip_longest.yml",
     "name": "zip_longest",
     "notes": [
      "This is mostly a passthrough to Python's C(itertools.zip_longest) function"
     ],
     "options": {
      "_additional_lists": {
       "description": "Additional list(s).",
       "elements": "any",
       "required": true,
       "type": "list"
      },
      "_input": {
       "description": "Original list.",
       "elements": "any",
       "required": true,
       "type": "list"
      },
      "fillvalue": {
       "description": "Filler value to add to output when one of the lists does not contain enough elements to match the others.",
       "type": "any"
      }
     },
     "positional": "_input, _additional_lists",
     "short_description": "combine list elements, with filler",
     "version_added": "2.3",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# X_fill => [[1, \"a\", 21], [2, \"b\", 22], [3, \"c\", 23], [\"X\", \"d\", \"X\"], [\"X\", \"e\", \"X\"], [\"X\", \"f\", \"X\"]]\nX_fill: \"{{ [1,2,3] | zip_longest(['a','b','c','d','e','f'], [21, 22, 23], fillvalue='X') }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "List of lists made of elements matching the positions of the input lists.",
      "elements": "list",
      "type": "list"
     }
    }
   },
   "ns2.col.bar": {
    "doc": {
     "collection": "ns2.col",
     "description": [
      "Do some barring."
     ],
     "filename": "ansible_collections/ns2/col/plugins/filter/bar.yml",
     "name": "bar",
     "options": {
      "_input": {
       "description": "The main input.",
       "required": true,
       "type": "dict"
      },
      "bar": {
       "default": false,
       "description": "And some bar.",
       "type": "bool"
      },
      "baz": {
       "choices": {
        "a": "Whatever C(a) is.",
        "b": "What is C(b)? I don't know.",
        "cde": "This is some more unknown. There are rumors this is related to the alphabet.",
        "foo": [
         "Our default value, the glorious C(foo).",
         "Even has two paragraphs."
        ]
       },
       "default": "foo",
       "description": "Something else.",
       "type": "str"
      },
      "foo": {
       "description": "Some foo.",
       "elements": "dictionary",
       "required": true,
       "type": "list"
      }
     },
     "positional": "foo, bar",
     "short_description": "The bar filter",
     "version_added": "2.0.0",
     "version_added_collection": "ns2.col"
    },
    "examples": "\n{'a': 1} | ns2.col.bar({'b': 2}, baz='cde')\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The result.",
      "type": "dict"
     }
    }
   },
   "ns2.col.foo": {
    "doc": {
     "collection": "ns2.col",
     "description": [
      "Do some fooing."
     ],
     "filename": "ansible_collections/ns2/col/plugins/filter/foo.py",
     "name": "foo",
     "options": {
      "_input": {
       "description": "The main input.",
       "required": true,
       "type": "str"
      },
      "bar": {
       "description": "Some bar.",
       "type": "string"
      },
      "foo": {
       "description": "Some foo.",
       "elements": "dictionary",
       "required": true,
       "type": "list"
      }
     },
     "short_description": "The foo filter O(bar)",
     "version_added": "1.3.0",
     "version_added_collection": "ns2.col"
    },
    "examples": "\nsome_var: \"{{ 'foo' | ns2.col.foo }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "The result.",
      "type": "str"
     }
    }
   }
  },
  "httpapi": {},
  "inventory": {
   "ansible.builtin.advanced_host_list": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Parses a host list string as a comma separated values of hosts and supports host ranges.",
      "This plugin only applies to inventory sources that are not paths and contain at least one comma."
     ],
     "filename": "/ansible/plugins/inventory/advanced_host_list.py",
     "name": "advanced_host_list",
     "short_description": "Parses a 'host list' with ranges",
     "version_added": "2.4",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n    # simple range\n    # ansible -i 'host[1:10],' -m ping\n\n    # still supports w/o ranges also\n    # ansible-playbook -i 'localhost,' play.yml\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.auto": {
    "doc": {
     "author": [
      "Matt Davis (@nitzmahone)"
     ],
     "collection": "ansible.builtin",
     "description": [
      "By enabling the C(auto) inventory plugin, any YAML inventory config file with a C(plugin) key at its root will automatically cause the named plugin to be loaded and executed with that config. This effectively provides automatic enabling of all installed/accessible inventory plugins.",
      "To disable this behavior, remove C(auto) from the C(INVENTORY_ENABLED) config element."
     ],
     "filename": "/ansible/plugins/inventory/auto.py",
     "name": "auto",
     "short_description": "Loads and executes an inventory plugin specified in a YAML config",
     "version_added": "2.5",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# This plugin is not intended for direct use; it is a fallback mechanism for automatic enabling of\n# all installed inventory plugins.\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.constructed": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Uses a YAML configuration file with a valid YAML or C(.config) extension to define var expressions and group conditionals",
      "The Jinja2 conditionals that qualify a host for membership.",
      "The Jinja2 expressions are calculated and assigned to the variables",
      "Only variables already available from previous inventories or the fact cache can be used for templating.",
      "When O(strict) is False, failed expressions will be ignored (assumes vars were missing)."
     ],
     "filename": "/ansible/plugins/inventory/constructed.py",
     "name": "constructed",
     "options": {
      "compose": {
       "default": {},
       "description": "Create vars from jinja2 expressions.",
       "type": "dict"
      },
      "groups": {
       "default": {},
       "description": "Add hosts to group based on Jinja2 conditionals.",
       "type": "dict"
      },
      "keyed_groups": {
       "default": [],
       "description": "Add hosts to group based on the values of a variable.",
       "elements": "dict",
       "suboptions": {
        "default_value": {
         "description": [
          "The default value when the host variable's value is an empty string.",
          "This option is mutually exclusive with O(keyed_groups[].trailing_separator)."
         ],
         "type": "str",
         "version_added": "2.12",
         "version_added_collection": "ansible.builtin"
        },
        "key": {
         "description": [
          "The key from input dictionary used to generate groups"
         ],
         "type": "str"
        },
        "parent_group": {
         "description": "parent group for keyed group",
         "type": "str"
        },
        "prefix": {
         "default": "",
         "description": "A keyed group name will start with this prefix",
         "type": "str"
        },
        "separator": {
         "default": "_",
         "description": "separator used to build the keyed group name",
         "type": "str"
        },
        "trailing_separator": {
         "default": true,
         "description": [
          "Set this option to V(False) to omit the O(keyed_groups[].separator) after the host variable when the value is an empty string.",
          "This option is mutually exclusive with O(keyed_groups[].default_value)."
         ],
         "type": "bool",
         "version_added": "2.12",
         "version_added_collection": "ansible.builtin"
        }
       },
       "type": "list"
      },
      "leading_separator": {
       "default": true,
       "description": [
        "Use in conjunction with keyed_groups.",
        "By default, a keyed group that does not have a prefix or a separator provided will have a name that starts with an underscore.",
        "This is because the default prefix is \"\" and the default separator is \"_\".",
        "Set this option to False to omit the leading underscore (or other separator) if no prefix is given.",
        "If the group name is derived from a mapping the separator is still used to concatenate the items.",
        "To not use a separator in the group name at all, set the separator for the keyed group to an empty string instead."
       ],
       "type": "boolean",
       "version_added": "2.11",
       "version_added_collection": "ansible.builtin"
      },
      "plugin": {
       "choices": [
        "ansible.builtin.constructed",
        "constructed"
       ],
       "description": "token that ensures this is a source file for the 'constructed' plugin.",
       "required": true
      },
      "strict": {
       "default": false,
       "description": [
        "If V(yes) make invalid entries a fatal error, otherwise skip and continue.",
        "Since it is possible to use facts in the expressions they might not always be available and we ignore those errors by default."
       ],
       "type": "bool"
      },
      "use_extra_vars": {
       "default": false,
       "description": "Merge extra vars into the available variables for composition (highest precedence).",
       "env": [
        {
         "name": "ANSIBLE_INVENTORY_USE_EXTRA_VARS"
        }
       ],
       "ini": [
        {
         "key": "use_extra_vars",
         "section": "inventory_plugins"
        }
       ],
       "type": "bool",
       "version_added": "2.11",
       "version_added_collection": "ansible.builtin"
      },
      "use_vars_plugins": {
       "default": false,
       "description": [
        "Normally, for performance reasons, vars plugins get executed after the inventory sources complete the base inventory, this option allows for getting vars related to hosts/groups from those plugins.",
        "The host_group_vars (enabled by default) 'vars plugin' is the one responsible for reading host_vars/ and group_vars/ directories.",
        "This will execute all vars plugins, even those that are not supposed to execute at the 'inventory' stage. See vars plugins docs for details on 'stage'.",
        "Implicit groups, such as 'all' or 'ungrouped', need to be explicitly defined in any previous inventory to apply the corresponding group_vars"
       ],
       "required": false,
       "type": "boolean",
       "version_added": "2.11",
       "version_added_collection": "ansible.builtin"
      }
     },
     "short_description": "Uses Jinja2 to construct vars and groups based on existing inventory.",
     "version_added": "2.4",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n    # inventory.config file in YAML format\n    plugin: ansible.builtin.constructed\n    strict: False\n    compose:\n        var_sum: var1 + var2\n\n        # this variable will only be set if I have a persistent fact cache enabled (and have non expired facts)\n        # `strict: False` will skip this instead of producing an error if it is missing facts.\n        server_type: \"ansible_hostname | regex_replace ('(.{6})(.{2}).*', '\\\\2')\"\n    groups:\n        # simple name matching\n        webservers: inventory_hostname.startswith('web')\n\n        # using ec2 'tags' (assumes aws inventory)\n        development: \"'devel' in (ec2_tags|list)\"\n\n        # using other host properties populated in inventory\n        private_only: not (public_dns_name is defined or ip_address is defined)\n\n        # complex group membership\n        multi_group: (group_names | intersect(['alpha', 'beta', 'omega'])) | length >= 2\n\n    keyed_groups:\n        # this creates a group per distro (distro_CentOS, distro_Debian) and assigns the hosts that have matching values to it,\n        # using the default separator \"_\"\n        - prefix: distro\n          key: ansible_distribution\n\n        # the following examples assume the first inventory is from the `aws_ec2` plugin\n        # this creates a group per ec2 architecture and assign hosts to the matching ones (arch_x86_64, arch_sparc, etc)\n        - prefix: arch\n          key: architecture\n\n        # this creates a group per ec2 region like \"us_west_1\"\n        - prefix: \"\"\n          separator: \"\"\n          key: placement.region\n\n        # this creates a common parent group for all ec2 availability zones\n        - key: placement.availability_zone\n          parent_group: all_ec2_zones\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.generator": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Uses a YAML configuration file with a valid YAML or C(.config) extension to define var expressions and group conditionals",
      "Create a template pattern that describes each host, and then use independent configuration layers",
      "Every element of every layer is combined to create a host for every layer combination",
      "Parent groups can be defined with reference to hosts and other groups using the same template variables"
     ],
     "filename": "/ansible/plugins/inventory/generator.py",
     "name": "generator",
     "options": {
      "hosts": {
       "description": [
        "The C(name) key is a template used to generate hostnames based on the C(layers) option. Each variable in the name is expanded to create a cartesian product of all possible layer combinations.",
        "The C(parents) are a list of parent groups that the host belongs to. Each C(parent) item contains a C(name) key, again expanded from the template, and an optional C(parents) key that lists its parents.",
        "Parents can also contain C(vars), which is a dictionary of vars that is then always set for that variable. This can provide easy access to the group name. E.g set an C(application) variable that is set to the value of the C(application) layer name."
       ]
      },
      "layers": {
       "description": [
        "A dictionary of layers, with the key being the layer name, used as a variable name in the C(host) C(name) and C(parents) keys. Each layer value is a list of possible values for that layer."
       ]
      },
      "plugin": {
       "choices": [
        "ansible.builtin.generator",
        "generator"
       ],
       "description": "token that ensures this is a source file for the 'generator' plugin.",
       "required": true
      }
     },
     "short_description": "Uses Jinja2 to construct hosts and groups from patterns",
     "version_added": "2.6",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n    # inventory.config file in YAML format\n    # remember to enable this inventory plugin in the ansible.cfg before using\n    # View the output using `ansible-inventory -i inventory.config --list`\n    plugin: ansible.builtin.generator\n    hosts:\n        name: \"{{ operation }}_{{ application }}_{{ environment }}_runner\"\n        parents:\n          - name: \"{{ operation }}_{{ application }}_{{ environment }}\"\n            parents:\n              - name: \"{{ operation }}_{{ application }}\"\n                parents:\n                  - name: \"{{ operation }}\"\n                  - name: \"{{ application }}\"\n              - name: \"{{ application }}_{{ environment }}\"\n                parents:\n                  - name: \"{{ application }}\"\n                    vars:\n                      application: \"{{ application }}\"\n                  - name: \"{{ environment }}\"\n                    vars:\n                      environment: \"{{ environment }}\"\n          - name: runner\n    layers:\n        operation:\n            - build\n            - launch\n        environment:\n            - dev\n            - test\n            - prod\n        application:\n            - web\n            - api\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.host_list": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Parses a host list string as a comma separated values of hosts",
      "This plugin only applies to inventory strings that are not paths and contain a comma."
     ],
     "filename": "/ansible/plugins/inventory/host_list.py",
     "name": "host_list",
     "short_description": "Parses a 'host list' string",
     "version_added": "2.4",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n    # define 2 hosts in command line\n    # ansible -i '10.10.2.6, 10.10.2.4' -m ping all\n\n    # DNS resolvable names\n    # ansible -i 'host1.example.com, host2' -m user -a 'name=me state=absent' all\n\n    # just use localhost\n    # ansible-playbook -i 'localhost,' play.yml -c local\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.ini": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "INI file based inventory, sections are groups or group related with special C(:modifiers).",
      "Entries in sections C([group_1]) are hosts, members of the group.",
      "Hosts can have variables defined inline as key/value pairs separated by C(=).",
      "The C(children) modifier indicates that the section contains groups.",
      "The C(vars) modifier indicates that the section contains variables assigned to members of the group.",
      "Anything found outside a section is considered an 'ungrouped' host.",
      "Values passed in the INI format using the C(key=value) syntax are interpreted differently depending on where they are declared within your inventory.",
      "When declared inline with the host, INI values are processed by Python's ast.literal_eval function (U(https://docs.python.org/3/library/ast.html#ast.literal_eval)) and interpreted as Python literal structures (strings, numbers, tuples, lists, dicts, booleans, None). If you want a number to be treated as a string, you must quote it. Host lines accept multiple C(key=value) parameters per line. Therefore they need a way to indicate that a space is part of a value rather than a separator.",
      "When declared in a C(:vars) section, INI values are interpreted as strings. For example C(var=FALSE) would create a string equal to C(FALSE). Unlike host lines, C(:vars) sections accept only a single entry per line, so everything after the C(=) must be the value for the entry.",
      "Do not rely on types set during definition, always make sure you specify type with a filter when needed when consuming the variable.",
      "See the Examples for proper quoting to prevent changes to variable type."
     ],
     "filename": "/ansible/plugins/inventory/ini.py",
     "name": "ini",
     "notes": [
      "Enabled in configuration by default.",
      "Consider switching to YAML format for inventory sources to avoid confusion on the actual type of a variable. The YAML inventory plugin processes variable values consistently and correctly."
     ],
     "short_description": "Uses an Ansible INI file as inventory source.",
     "version_added": "2.4",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# fmt: ini\n# Example 1\n[web]\nhost1\nhost2 ansible_port=222 # defined inline, interpreted as an integer\n\n[web:vars]\nhttp_port=8080 # all members of 'web' will inherit these\nmyvar=23 # defined in a :vars section, interpreted as a string\n\n[web:children] # child groups will automatically add their hosts to parent group\napache\nnginx\n\n[apache]\ntomcat1\ntomcat2 myvar=34 # host specific vars override group vars\ntomcat3 mysecret=\"'03#pa33w0rd'\" # proper quoting to prevent value changes\n\n[nginx]\njenkins1\n\n[nginx:vars]\nhas_java = True # vars in child groups override same in parent\n\n[all:vars]\nhas_java = False # 'all' is 'top' parent\n\n# Example 2\nhost1 # this is 'ungrouped'\n\n# both hosts have same IP but diff ports, also 'ungrouped'\nhost2 ansible_host=127.0.0.1 ansible_port=44\nhost3 ansible_host=127.0.0.1 ansible_port=45\n\n[g1]\nhost4\n\n[g2]\nhost4 # same host as above, but member of 2 groups, will inherit vars from both\n      # inventory hostnames are unique\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.script": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "The source provided must be an executable that returns Ansible inventory JSON",
      "The source must accept C(--list) and C(--host <hostname>) as arguments. C(--host) will only be used if no C(_meta) key is present. This is a performance optimization as the script would be called one additional time per host otherwise."
     ],
     "filename": "/ansible/plugins/inventory/script.py",
     "name": "script",
     "notes": [
      "Enabled in configuration by default.",
      "The plugin does not cache results because external inventory scripts are responsible for their own caching.",
      "To write your own inventory script see (R(Developing dynamic inventory,developing_inventory) from the documentation site.",
      "To find the scripts that used to be part of the code release, go to U(https://github.com/ansible-community/contrib-scripts/)."
     ],
     "options": {
      "always_show_stderr": {
       "default": true,
       "description": "Toggle display of stderr even when script was successful",
       "env": [
        {
         "name": "ANSIBLE_INVENTORY_PLUGIN_SCRIPT_STDERR"
        }
       ],
       "ini": [
        {
         "key": "always_show_stderr",
         "section": "inventory_plugin_script"
        }
       ],
       "type": "boolean",
       "version_added": "2.5.1",
       "version_added_collection": "ansible.builtin"
      }
     },
     "short_description": "Executes an inventory script that returns JSON",
     "version_added": "2.4",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# fmt: code\n\n### simple bash script\n\n   #!/usr/bin/env bash\n\n   if [ \"$1\" == \"--list\" ]; then\n   cat<<EOF\n   {\n     \"bash_hosts\": {\n       \"hosts\": [\n         \"myhost.domain.com\",\n         \"myhost2.domain.com\"\n       ],\n       \"vars\": {\n         \"host_test\": \"test-value\"\n       }\n     },\n     \"_meta\": {\n       \"hostvars\": {\n         \"myhost.domain.com\": {\n           \"host_specific_test_var\": \"test-value\"\n         }\n       }\n     }\n   }\n   EOF\n   elif [ \"$1\" == \"--host\" ]; then\n     # this should not normally be called by Ansible as we return _meta above\n     if [ \"$2\" == \"myhost.domain.com\" ]; then\n        echo '{\"_meta\": {hostvars\": {\"myhost.domain.com\": {\"host_specific-test_var\": \"test-value\"}}}}'\n     else\n        echo '{\"_meta\": {hostvars\": {}}}'\n     fi\n   else\n     echo \"Invalid option: use --list or --host <hostname>\"\n     exit 1\n   fi\n\n\n### python example with ini config\n\n    #!/usr/bin/env python\n    \"\"\"\n    # ansible_inventory.py\n    \"\"\"\n    import argparse\n    import json\n    import os.path\n    import sys\n    from configparser import ConfigParser\n    from inventories.custom import MyInventoryAPI\n\n    def load_config() -> ConfigParser:\n        cp = ConfigParser()\n        config_file = os.path.expanduser(\"~/.config/ansible_inventory_script.cfg\")\n        cp.read(config_file)\n        if not cp.has_option('DEFAULT', 'namespace'):\n            raise ValueError(\"Missing configuration option: DEFAULT -> namespace\")\n        return cp\n\n\n    def get_api_data(namespace: str, pretty=False) -> str:\n        \"\"\"\n        :param namespace: parameter for our custom api\n        :param pretty: Human redable JSON vs machine readable\n        :return: JSON string\n        \"\"\"\n        found_data = list(MyInventoryAPI(namespace))\n        hostvars = {}\n        data = { '_meta': { 'hostvars': {}},}\n\n        groups = found_data['groups'].keys()\n        for group in groups:\n            groups[group]['hosts'] = found_data[groups].get('host_list', [])\n            if group not in data:\n                data[group] = {}\n            data[group]['hosts'] = found_data[groups].get('host_list', [])\n            data[group]['vars'] = found_data[groups].get('info', [])\n            data[group]['children'] = found_data[group].get('subgroups', [])\n\n        for host_data in found_data['hosts']:\n            for name in host_data.items():\n                # turn info into vars\n                data['_meta'][name] = found_data[name].get('info', {})\n                # set ansible_host if possible\n                if 'address' in found_data[name]:\n                    data[name]['_meta']['ansible_host'] = found_data[name]['address']\n        data['_meta']['hostvars'] = hostvars\n\n        return json.dumps(data, indent=pretty)\n\n    if __name__ == '__main__':\n\n        arg_parser = argparse.ArgumentParser( description=__doc__, prog=__file__)\n        arg_parser.add_argument('--pretty', action='store_true', default=False, help=\"Pretty JSON\")\n        mandatory_options = arg_parser.add_mutually_exclusive_group()\n        mandatory_options.add_argument('--list', action='store', nargs=\"*\", help=\"Get inventory JSON from our API\")\n        mandatory_options.add_argument('--host', action='store',\n                                       help=\"Get variables for specific host, not used but kept for compatability\")\n\n        try:\n            config = load_config()\n            namespace = config.get('DEFAULT', 'namespace')\n\n            args = arg_parser.parse_args()\n            if args.host:\n                print('{\"_meta\":{}}')\n                sys.stderr.write('This script already provides _meta via --list, so this option is really ignored')\n            elif len(args.list) >= 0:\n                print(get_api_data(namespace, args.pretty))\n            else:\n                raise ValueError(\"Valid options are --list or --host <HOSTNAME>\")\n\n        except ValueError:\n            raise\n\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.toml": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "TOML based inventory format",
      "File MUST have a valid '.toml' file extension"
     ],
     "filename": "/ansible/plugins/inventory/toml.py",
     "name": "toml",
     "notes": [
      "Requires one of the following python libraries: 'toml', 'tomli', or 'tomllib'\n"
     ],
     "short_description": "Uses a specific TOML file as an inventory source.",
     "version_added": "2.8",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# fmt: toml\n# Example 1\n[all.vars]\nhas_java = false\n\n[web]\nchildren = [\n    \"apache\",\n    \"nginx\"\n]\nvars = { http_port = 8080, myvar = 23 }\n\n[web.hosts]\nhost1 = {}\nhost2 = { ansible_port = 222 }\n\n[apache.hosts]\ntomcat1 = {}\ntomcat2 = { myvar = 34 }\ntomcat3 = { mysecret = \"03#pa33w0rd\" }\n\n[nginx.hosts]\njenkins1 = {}\n\n[nginx.vars]\nhas_java = true\n\n# Example 2\n[all.vars]\nhas_java = false\n\n[web]\nchildren = [\n    \"apache\",\n    \"nginx\"\n]\n\n[web.vars]\nhttp_port = 8080\nmyvar = 23\n\n[web.hosts.host1]\n[web.hosts.host2]\nansible_port = 222\n\n[apache.hosts.tomcat1]\n\n[apache.hosts.tomcat2]\nmyvar = 34\n\n[apache.hosts.tomcat3]\nmysecret = \"03#pa33w0rd\"\n\n[nginx.hosts.jenkins1]\n\n[nginx.vars]\nhas_java = true\n\n# Example 3\n[ungrouped.hosts]\nhost1 = {}\nhost2 = { ansible_host = \"127.0.0.1\", ansible_port = 44 }\nhost3 = { ansible_host = \"127.0.0.1\", ansible_port = 45 }\n\n[g1.hosts]\nhost4 = {}\n\n[g2.hosts]\nhost4 = {}\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.yaml": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "YAML-based inventory, should start with the C(all) group and contain hosts/vars/children entries.",
      "Host entries can have sub-entries defined, which will be treated as variables.",
      "Vars entries are normal group vars.",
      "Children are 'child groups', which can also have their own vars/hosts/children and so on.",
      "File MUST have a valid extension, defined in configuration."
     ],
     "filename": "/ansible/plugins/inventory/yaml.py",
     "name": "yaml",
     "notes": [
      "If you want to set vars for the C(all) group inside the inventory file, the C(all) group must be the first entry in the file.",
      "Enabled in configuration by default."
     ],
     "options": {
      "yaml_extensions": {
       "default": [
        ".yaml",
        ".yml",
        ".json"
       ],
       "description": "list of 'valid' extensions for files containing YAML",
       "elements": "string",
       "env": [
        {
         "name": "ANSIBLE_YAML_FILENAME_EXT"
        },
        {
         "name": "ANSIBLE_INVENTORY_PLUGIN_EXTS"
        }
       ],
       "ini": [
        {
         "key": "yaml_valid_extensions",
         "section": "defaults"
        },
        {
         "key": "yaml_valid_extensions",
         "section": "inventory_plugin_yaml"
        }
       ],
       "type": "list"
      }
     },
     "short_description": "Uses a specific YAML file as an inventory source.",
     "version_added": "2.4",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\nall: # keys must be unique, i.e. only one 'hosts' per group\n    hosts:\n        test1:\n        test2:\n            host_var: value\n    vars:\n        group_all_var: value\n    children:   # key order does not matter, indentation does\n        other_group:\n            children:\n                group_x:\n                    hosts:\n                        test5   # Note that one machine will work without a colon\n                #group_x:\n                #    hosts:\n                #        test5  # But this won't\n                #        test7  #\n                group_y:\n                    hosts:\n                        test6:  # So always use a colon\n            vars:\n                g2_var2: value3\n            hosts:\n                test4:\n                    ansible_host: 127.0.0.1\n        last_group:\n            hosts:\n                test1 # same host as above, additional group membership\n            vars:\n                group_last_var: value\n",
    "metadata": null,
    "return": null
   },
   "ns2.col.foo": {
    "doc": {
     "collection": "ns2.col",
     "description": [
      "Loads inventory from foo."
     ],
     "filename": "ansible_collections/ns2/col/plugins/inventory/foo.py",
     "name": "foo",
     "options": {
      "bar": {
       "description": "Foo bar.",
       "type": "string"
      }
     },
     "short_description": "The foo inventory O(bar)",
     "version_added": "0.5.0",
     "version_added_collection": "ns2.col"
    },
    "examples": "\nfoo:\n    bar!\n",
    "metadata": null,
    "return": null
   }
  },
  "keyword": {
   "accelerate": {
    "applies_to": [],
    "description": "*DEPRECATED*, set to True to use accelerate connection plugin."
   },
   "accelerate_ipv6": {
    "applies_to": [],
    "description": "*DEPRECATED*, set to True to force accelerate plugin to use ipv6 for its connection."
   },
   "accelerate_port": {
    "applies_to": [],
    "description": "*DEPRECATED*, set to override default port use for accelerate connection."
   },
   "action": {
    "applies_to": [
     "Task"
    ],
    "description": "The 'action' to execute for a task, it normally translates into a C(module) or action plugin.",
    "priority": 0,
    "template": "explicit",
    "type": "string"
   },
   "always": {
    "applies_to": [
     "Block"
    ],
    "description": "List of tasks, in a block, that execute no matter if there is an error in the block or not.",
    "priority": 0,
    "template": "explicit",
    "type": "list"
   },
   "any_errors_fatal": {
    "applies_to": [
     "Play",
     "Role",
     "Block",
     "Task"
    ],
    "description": "Force any un-handled task errors on any host to propagate to all hosts and end the play.",
    "priority": 0,
    "template": "explicit",
    "type": "bool"
   },
   "args": {
    "applies_to": [
     "Task"
    ],
    "description": "A secondary way to add arguments into a task. Takes a dictionary in which keys map to options and values.",
    "priority": 0,
    "template": "explicit",
    "type": "dict"
   },
   "async": {
    "alias": "async",
    "applies_to": [
     "Task"
    ],
    "description": "Run a task asynchronously if the C(action) supports this; the value is the maximum runtime in seconds.",
    "priority": 0,
    "template": "explicit",
    "type": "int"
   },
   "become": {
    "applies_to": [
     "Play",
     "Role",
     "Block",
     "Task"
    ],
    "description": "Boolean that controls if privilege escalation is used or not on :term:`Task` execution. Implemented by the become plugin. See :ref:`become_plugins`.",
    "priority": 0,
    "template": "explicit",
    "type": "bool"
   },
   "become_exe": {
    "applies_to": [
     "Play",
     "Role",
     "Block",
     "Task"
    ],
    "description": "Path to the executable used to elevate privileges. Implemented by the become plugin. See :ref:`become_plugins`.",
    "priority": 0,
    "template": "explicit",
    "type": "string"
   },
   "become_flags": {
    "applies_to": [
     "Play",
     "Role",
     "Block",
     "Task"
    ],
    "description": "A string of flag(s) to pass to the privilege escalation program when :term:`become` is True.",
    "priority": 0,
    "template": "explicit",
    "type": "string"
   },
   "become_method": {
    "applies_to": [
     "Play",
     "Role",
     "Block",
     "Task"
    ],
    "description": "Which method of privilege escalation to use (such as sudo or su).",
    "priority": 0,
    "template": "explicit",
    "type": "string"
   },
   "become_user": {
    "applies_to": [
     "Play",
     "Role",
     "Block",
     "Task"
    ],
    "description": "User that you 'become' after using privilege escalation. The remote/login user must have permissions to become this user.",
    "priority": 0,
    "template": "explicit",
    "type": "string"
   },
   "block": {
    "applies_to": [
     "Block"
    ],
    "description": "List of tasks in a block.",
    "priority": 0,
    "template": "explicit",
    "type": "list"
   },
   "changed_when": {
    "applies_to": [
     "Task"
    ],
    "description": "Conditional expression that overrides the task's normal 'changed' status.",
    "priority": 0,
    "template": "implicit",
    "type": "list"
   },
   "check_mode": {
    "applies_to": [
     "Play",
     "Role",
     "Block",
     "Task"
    ],
    "description": "A boolean that controls if a task is executed in 'check' mode. See :ref:`check_mode_dry`.",
    "priority": 0,
    "template": "explicit",
    "type": "bool"
   },
   "collections": {
    "applies_to": [
     "Play",
     "Role",
     "Block",
     "Task"
    ],
    "description": "List of collection namespaces to search for modules, plugins, and roles. See :ref:`collections_using_playbook`\n\n.. note::\n\n    Tasks within a role do not inherit the value of ``collections`` from the play. To have a role search a list of collections, use the ``collections`` keyword in ``meta/main.yml`` within a role.\n",
    "priority": 100,
    "template": "static",
    "type": "list"
   },
   "connection": {
    "applies_to": [
     "Play",
     "Role",
     "Block",
     "Task"
    ],
    "description": "Allows you to change the connection plugin used for tasks to execute on the target. See :ref:`using_connection`.",
    "priority": 0,
    "template": "explicit",
    "type": "string"
   },
   "debugger": {
    "applies_to": [
     "Play",
     "Role",
     "Block",
     "Task"
    ],
    "description": "Enable debugging tasks based on the state of the task result. See :ref:`playbook_debugger`.",
    "priority": 0,
    "template": "explicit",
    "type": "string"
   },
   "delay": {
    "applies_to": [
     "Task"
    ],
    "description": "Number of seconds to delay between retries. This setting is only used in combination with :term:`until`.",
    "priority": 0,
    "template": "explicit",
    "type": "int"
   },
   "delegate_facts": {
    "applies_to": [
     "Role",
     "Block",
     "Task"
    ],
    "description": "Boolean that allows you to apply facts to a delegated host instead of inventory_hostname.",
    "priority": 0,
    "template": "explicit",
    "type": "bool"
   },
   "delegate_to": {
    "applies_to": [
     "Role",
     "Block",
     "Task"
    ],
    "description": "Host to execute task instead of the target (inventory_hostname). Connection vars from the delegated host will also be used for the task.",
    "priority": 0,
    "template": "explicit",
    "type": "string"
   },
   "diff": {
    "applies_to": [
     "Play",
     "Role",
     "Block",
     "Task"
    ],
    "description": "Toggle to make tasks return 'diff' information or not.",
    "priority": 0,
    "template": "explicit",
    "type": "bool"
   },
   "environment": {
    "applies_to": [
     "Play",
     "Role",
     "Block",
     "Task"
    ],
    "description": "A dictionary that gets converted into environment vars to be provided for the task upon execution. This can ONLY be used with modules. This is not supported for any other type of plugins nor Ansible itself nor its configuration, it just sets the variables for the code responsible for executing the task. This is not a recommended way to pass in confidential data.",
    "priority": 0,
    "template": "explicit",
    "type": "list"
   },
   "fact_path": {
    "applies_to": [
     "Play"
    ],
    "description": "Set the fact path option for the fact gathering plugin controlled by :term:`gather_facts`.",
    "priority": 0,
    "template": "explicit",
    "type": "string"
   },
   "failed_when": {
    "applies_to": [
     "Task"
    ],
    "description": "Conditional expression that overrides the task's normal 'failed' status.",
    "priority": 0,
    "template": "implicit",
    "type": "list"
   },
   "force_handlers": {
    "applies_to": [
     "Play"
    ],
    "description": "Will force notified handler execution for hosts even if they failed during the play. Will not trigger if the play itself fails.",
    "priority": 0,
    "template": "explicit",
    "type": "bool"
   },
   "gather_facts": {
    "applies_to": [
     "Play"
    ],
    "description": "A boolean that controls if the play will automatically run the 'setup' task to gather facts for the hosts.",
    "priority": 0,
    "template": "explicit",
    "type": "bool"
   },
   "gather_subset": {
    "applies_to": [
     "Play"
    ],
    "description": "Allows you to pass subset options to the fact gathering plugin controlled by :term:`gather_facts`.",
    "priority": 0,
    "template": "explicit",
    "type": "list"
   },
   "gather_timeout": {
    "applies_to": [
     "Play"
    ],
    "description": "Allows you to set the timeout for the fact gathering plugin controlled by :term:`gather_facts`.",
    "priority": 0,
    "template": "explicit",
    "type": "int"
   },
   "handlers": {
    "applies_to": [
     "Play"
    ],
    "description": "A section with tasks that are treated as handlers, these won't get executed normally, only when notified after each section of tasks is complete. A handler's `listen` field is not templatable.",
    "priority": -1,
    "template": "explicit",
    "type": "list"
   },
   "hosts": {
    "applies_to": [
     "Play"
    ],
    "description": "A list of groups, hosts or host pattern that translates into a list of hosts that are the play's target.",
    "priority": -2,
    "template": "explicit",
    "type": "list"
   },
   "ignore_errors": {
    "applies_to": [
     "Play",
     "Role",
     "Block",
     "Task"
    ],
    "description": "Boolean that allows you to ignore task failures and continue with play. It does not affect connection errors.",
    "priority": 0,
    "template": "explicit",
    "type": "bool"
   },
   "ignore_unreachable": {
    "applies_to": [
     "Play",
     "Role",
     "Block",
     "Task"
    ],
    "description": "Boolean that allows you to ignore task failures due to an unreachable host and continue with the play. This does not affect other task errors (see :term:`ignore_errors`) but is useful for groups of volatile/ephemeral hosts.",
    "priority": 0,
    "template": "explicit",
    "type": "bool"
   },
   "loop": {
    "applies_to": [
     "Task"
    ],
    "description": "Takes a list for the task to iterate over, saving each list element into the ``item`` variable (configurable via loop_control)",
    "priority": 0,
    "template": "explicit",
    "type": "list"
   },
   "loop_control": {
    "applies_to": [
     "Task"
    ],
    "description": "Several keys here allow you to modify/set loop behavior in a task. See :ref:`loop_control`.",
    "priority": 0,
    "template": "explicit",
    "type": "class"
   },
   "max_fail_percentage": {
    "applies_to": [
     "Play"
    ],
    "description": "can be used to abort the run after a given percentage of hosts in the current batch has failed. This only works on linear or linear-derived strategies.",
    "priority": 0,
    "template": "explicit",
    "type": "percent"
   },
   "module_defaults": {
    "applies_to": [
     "Play",
     "Role",
     "Block",
     "Task"
    ],
    "description": "Specifies default parameter values for modules.",
    "priority": 0,
    "template": "explicit",
    "type": "list"
   },
   "name": {
    "applies_to": [
     "Play",
     "Role",
     "Block",
     "Task"
    ],
    "description": "Identifier. Can be used for documentation, or in tasks/handlers.",
    "priority": 0,
    "template": "explicit",
    "type": "string"
   },
   "no_log": {
    "applies_to": [
     "Play",
     "Role",
     "Block",
     "Task"
    ],
    "description": "Boolean that controls information disclosure.",
    "priority": 0,
    "template": "explicit",
    "type": "bool"
   },
   "notify": {
    "applies_to": [
     "Block",
     "Task"
    ],
    "description": "List of handlers to notify when the task returns a 'changed=True' status.",
    "priority": 0,
    "template": "explicit",
    "type": "list"
   },
   "order": {
    "applies_to": [
     "Play"
    ],
    "description": "Controls the sorting of hosts as they are used for executing the play. Possible values are inventory (default), sorted, reverse_sorted, reverse_inventory and shuffle.",
    "priority": 0,
    "template": "explicit",
    "type": "string"
   },
   "poll": {
    "applies_to": [
     "Task"
    ],
    "description": "Sets the polling interval in seconds for async tasks (default 10s).",
    "priority": 0,
    "template": "explicit",
    "type": "int"
   },
   "port": {
    "applies_to": [
     "Play",
     "Role",
     "Block",
     "Task"
    ],
    "description": "Used to override the default port used in a connection.",
    "priority": 0,
    "template": "explicit",
    "type": "int"
   },
   "post_tasks": {
    "applies_to": [
     "Play"
    ],
    "description": "A list of tasks to execute after the :term:`tasks` section.",
    "priority": -1,
    "template": "explicit",
    "type": "list"
   },
   "pre_tasks": {
    "applies_to": [
     "Play"
    ],
    "description": "A list of tasks to execute before :term:`roles`.",
    "priority": -1,
    "template": "explicit",
    "type": "list"
   },
   "register": {
    "applies_to": [
     "Task"
    ],
    "description": "Name of variable that will contain task status and module return data.",
    "priority": 0,
    "template": "static",
    "type": "string"
   },
   "remote_user": {
    "applies_to": [
     "Play",
     "Role",
     "Block",
     "Task"
    ],
    "description": "User used to log into the target via the connection plugin.",
    "priority": 0,
    "template": "explicit",
    "type": "string"
   },
   "rescue": {
    "applies_to": [
     "Block"
    ],
    "description": "List of tasks in a :term:`block` that run if there is a task error in the main :term:`block` list.",
    "priority": 0,
    "template": "explicit",
    "type": "list"
   },
   "retries": {
    "applies_to": [
     "Task"
    ],
    "description": "Number of retries before giving up in a :term:`until` loop. This setting is only used in combination with :term:`until`.",
    "priority": 0,
    "template": "explicit",
    "type": "int"
   },
   "roles": {
    "applies_to": [
     "Play"
    ],
    "description": "List of roles to be imported into the play",
    "priority": 90,
    "template": "explicit",
    "type": "list"
   },
   "run_once": {
    "applies_to": [
     "Play",
     "Role",
     "Block",
     "Task"
    ],
    "description": "Boolean that will bypass the host loop, forcing the task to attempt to execute on the first host available and afterward apply any results and facts to all active hosts in the same batch.",
    "priority": 0,
    "template": "explicit",
    "type": "bool"
   },
   "serial": {
    "applies_to": [
     "Play"
    ],
    "description": "Explicitly define how Ansible batches the execution of the current play on the play's target. See :ref:`rolling_update_batch_size`.",
    "priority": 0,
    "template": "explicit",
    "type": "list"
   },
   "strategy": {
    "applies_to": [
     "Play"
    ],
    "description": "Allows you to choose the strategy plugin to use for the play. See :ref:`strategy_plugins`.",
    "priority": 0,
    "template": "explicit",
    "type": "string"
   },
   "tags": {
    "applies_to": [
     "Play",
     "Role",
     "Block",
     "Task"
    ],
    "description": "Tags applied to the task or included tasks, this allows selecting subsets of tasks from the command line.",
    "priority": 0,
    "template": "explicit",
    "type": "list"
   },
   "tasks": {
    "applies_to": [
     "Play"
    ],
    "description": "Main list of tasks to execute in the play, they run after :term:`roles` and before :term:`post_tasks`.",
    "priority": -1,
    "template": "explicit",
    "type": "list"
   },
   "throttle": {
    "applies_to": [
     "Play",
     "Role",
     "Block",
     "Task"
    ],
    "description": "Limit the number of concurrent task runs on task, block and playbook level. This is independent of the forks and serial settings, but cannot be set higher than those limits. For example, if forks is set to 10 and the throttle is set to 15, at most 10 hosts will be operated on in parallel.",
    "priority": 0,
    "template": "explicit",
    "type": "int"
   },
   "timeout": {
    "applies_to": [
     "Play",
     "Role",
     "Block",
     "Task"
    ],
    "description": "Time limit for the task to execute in, if exceeded Ansible will interrupt and fail the task.",
    "priority": 0,
    "template": "explicit",
    "type": "int"
   },
   "until": {
    "applies_to": [
     "Task"
    ],
    "description": "This keyword implies a ':term:`retries` loop' that will go on until the condition supplied here is met or we hit the :term:`retries` limit.",
    "priority": 0,
    "template": "implicit",
    "type": "list"
   },
   "vars": {
    "applies_to": [
     "Play",
     "Role",
     "Block",
     "Task"
    ],
    "description": "Dictionary/map of variables",
    "priority": 100,
    "template": "static",
    "type": "dict"
   },
   "vars_files": {
    "applies_to": [
     "Play"
    ],
    "description": "List of files that contain vars to include in the play.",
    "priority": 99,
    "template": "explicit",
    "type": "list"
   },
   "vars_prompt": {
    "applies_to": [
     "Play"
    ],
    "description": "list of variables to prompt for.",
    "priority": 0,
    "template": "explicit",
    "type": "list"
   },
   "when": {
    "applies_to": [
     "Role",
     "Block",
     "Task"
    ],
    "description": "Conditional expression, determines if an iteration of a task is run or not.",
    "priority": 0,
    "template": "implicit",
    "type": "list"
   }
  },
  "lookup": {
   "ansible.builtin.config": {
    "doc": {
     "author": "Ansible Core Team",
     "collection": "ansible.builtin",
     "description": [
      "Retrieves the value of an Ansible configuration setting, resolving all sources, from defaults, ansible.cfg, envirionmnet, CLI, and variables, but not keywords.",
      "The values returned assume the context of the current host or C(inventory_hostname).",
      "You can use C(ansible-config list) to see the global available settings, add C(-t all) to also show plugin options."
     ],
     "filename": "/ansible/plugins/lookup/config.py",
     "name": "config",
     "notes": [
      "Be aware that currently this lookup cannot take keywords nor delegation into account, so for options that support keywords or are affected by delegation, it is at best a good guess or approximation."
     ],
     "options": {
      "_terms": {
       "description": "The option(s) to look up.",
       "required": true
      },
      "on_missing": {
       "choices": {
        "error": "Issue an error message and raise fatal signal",
        "skip": "Silently ignore",
        "warn": "Issue a warning message and continue"
       },
       "default": "error",
       "description": "Action to take if term is missing from config",
       "type": "string"
      },
      "plugin_name": {
       "description": "The name of the plugin for which you want to retrieve configuration settings.",
       "type": "string",
       "version_added": "2.12",
       "version_added_collection": "ansible.builtin"
      },
      "plugin_type": {
       "choices": [
        "become",
        "cache",
        "callback",
        "cliconf",
        "connection",
        "httpapi",
        "inventory",
        "lookup",
        "netconf",
        "shell",
        "vars"
       ],
       "description": "The type of the plugin referenced by 'plugin_name' option.",
       "type": "string",
       "version_added": "2.12",
       "version_added_collection": "ansible.builtin"
      },
      "show_origin": {
       "description": "Set this to return what configuration subsystem the value came from (defaults, config file, environment, CLI, or variables).",
       "type": "bool",
       "version_added": "2.16",
       "version_added_collection": "ansible.builtin"
      }
     },
     "short_description": "Display the 'resolved' Ansible option values.",
     "version_added": "2.5",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n    - name: Show configured default become user\n      ansible.builtin.debug: msg=\"{{ lookup('ansible.builtin.config', 'DEFAULT_BECOME_USER')}}\"\n\n    - name: print out role paths\n      ansible.builtin.debug:\n        msg: \"These are the configured role paths: {{lookup('ansible.builtin.config', 'DEFAULT_ROLES_PATH')}}\"\n\n    - name: find retry files, skip if missing that key\n      ansible.builtin.find:\n        paths: \"{{lookup('ansible.builtin.config', 'RETRY_FILES_SAVE_PATH')|default(playbook_dir, True)}}\"\n        patterns: \"*.retry\"\n\n    - name: see the colors\n      ansible.builtin.debug: msg=\"{{item}}\"\n      loop: \"{{lookup('ansible.builtin.config', 'COLOR_OK', 'COLOR_CHANGED', 'COLOR_SKIP', wantlist=True)}}\"\n\n    - name: skip if bad value in var\n      ansible.builtin.debug: msg=\"{{ lookup('ansible.builtin.config', config_in_var, on_missing='skip')}}\"\n      var:\n        config_in_var: UNKNOWN\n\n    - name: show remote user and port for ssh connection\n      ansible.builtin.debug: msg={{q(\"ansible.builtin.config\", \"remote_user\", \"port\", plugin_type=\"connection\", plugin_name=\"ssh\", on_missing='skip')}}\n\n    - name: show remote_tmp setting for shell (sh) plugin\n      ansible.builtin.debug: msg={{q(\"ansible.builtin.config\", \"remote_tmp\", plugin_type=\"shell\", plugin_name=\"sh\")}}\n",
    "metadata": null,
    "return": {
     "_raw": {
      "description": [
       "A list of value(s) of the key(s) in the config if show_origin is false (default)",
       "Optionally, a list of 2 element lists (value, origin) if show_origin is true"
      ],
      "type": "raw"
     }
    }
   },
   "ansible.builtin.csvfile": {
    "doc": {
     "author": "Jan-Piet Mens (@jpmens) <jpmens(at)gmail.com>",
     "collection": "ansible.builtin",
     "description": [
      "The csvfile lookup reads the contents of a file in CSV (comma-separated value) format. The lookup looks for the row where the first column matches keyname (which can be multiple words) and returns the value in the O(col) column (default 1, which indexed from 0 means the second column in the file)."
     ],
     "filename": "/ansible/plugins/lookup/csvfile.py",
     "name": "csvfile",
     "notes": [
      "The default is for TSV files (tab delimited) not CSV (comma delimited) ... yes the name is misleading.",
      "As of version 2.11, the search parameter (text that must match the first column of the file) and filename parameter can be multi-word.",
      "For historical reasons, in the search keyname, quotes are treated literally and cannot be used around the string unless they appear (escaped as required) in the first column of the file you are parsing."
     ],
     "options": {
      "col": {
       "default": "1",
       "description": "column to return (0 indexed)."
      },
      "default": {
       "description": "what to return if the value is not found in the file."
      },
      "delimiter": {
       "default": "TAB",
       "description": "field separator in the file, for a tab you can specify V(TAB) or V(\\\\t)."
      },
      "encoding": {
       "default": "utf-8",
       "description": "Encoding (character set) of the used CSV file.",
       "version_added": "2.1",
       "version_added_collection": "ansible.builtin"
      },
      "file": {
       "default": "ansible.csv",
       "description": "name of the CSV/TSV file to open."
      },
      "keycol": {
       "default": 0,
       "description": "column to search in (0 indexed).",
       "type": "int",
       "version_added": "2.17",
       "version_added_collection": "ansible.builtin"
      }
     },
     "seealso": [
      {
       "description": "Search paths used for relative files.",
       "ref": "playbook_task_paths"
      }
     ],
     "short_description": "read data from a TSV or CSV file",
     "version_added": "1.5",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name:  Match 'Li' on the first column, return the second column (0 based index)\n  ansible.builtin.debug: msg=\"The atomic number of Lithium is {{ lookup('ansible.builtin.csvfile', 'Li file=elements.csv delimiter=,') }}\"\n\n- name: msg=\"Match 'Li' on the first column, but return the 3rd column (columns start counting after the match)\"\n  ansible.builtin.debug: msg=\"The atomic mass of Lithium is {{ lookup('ansible.builtin.csvfile', 'Li file=elements.csv delimiter=, col=2') }}\"\n\n- name: Define Values From CSV File, this reads file in one go, but you could also use col= to read each in it's own lookup.\n  ansible.builtin.set_fact:\n    loop_ip: \"{{ csvline[0] }}\"\n    int_ip: \"{{ csvline[1] }}\"\n    int_mask: \"{{ csvline[2] }}\"\n    int_name: \"{{ csvline[3] }}\"\n    local_as: \"{{ csvline[4] }}\"\n    neighbor_as: \"{{ csvline[5] }}\"\n    neigh_int_ip: \"{{ csvline[6] }}\"\n  vars:\n    csvline: \"{{ lookup('ansible.builtin.csvfile', bgp_neighbor_ip, file='bgp_neighbors.csv', delimiter=',') }}\"\n  delegate_to: localhost\n",
    "metadata": null,
    "return": {
     "_raw": {
      "description": [
       "value(s) stored in file column"
      ],
      "elements": "str",
      "type": "list"
     }
    }
   },
   "ansible.builtin.dict": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Takes dictionaries as input and returns a list with each item in the list being a dictionary with 'key' and 'value' as keys to the previous dictionary's structure."
     ],
     "filename": "/ansible/plugins/lookup/dict.py",
     "name": "dict",
     "options": {
      "_terms": {
       "description": [
        "A list of dictionaries"
       ],
       "required": true
      }
     },
     "short_description": "returns key/value pair items from dictionaries",
     "version_added": "1.5",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\nvars:\n  users:\n    alice:\n      name: Alice Appleworth\n      telephone: 123-456-7890\n    bob:\n      name: Bob Bananarama\n      telephone: 987-654-3210\ntasks:\n  # with predefined vars\n  - name: Print phone records\n    ansible.builtin.debug:\n      msg: \"User {{ item.key }} is {{ item.value.name }} ({{ item.value.telephone }})\"\n    loop: \"{{ lookup('ansible.builtin.dict', users) }}\"\n  # with inline dictionary\n  - name: show dictionary\n    ansible.builtin.debug:\n      msg: \"{{item.key}}: {{item.value}}\"\n    with_dict: {a: 1, b: 2, c: 3}\n  # Items from loop can be used in when: statements\n  - name: set_fact when alice in key\n    ansible.builtin.set_fact:\n      alice_exists: true\n    loop: \"{{ lookup('ansible.builtin.dict', users) }}\"\n    when: \"'alice' in item.key\"\n",
    "metadata": null,
    "return": {
     "_list": {
      "description": [
       "list of composed dictionaries with key and value"
      ],
      "type": "list"
     }
    }
   },
   "ansible.builtin.env": {
    "doc": {
     "author": "Jan-Piet Mens (@jpmens) <jpmens(at)gmail.com>",
     "collection": "ansible.builtin",
     "description": [
      "Allows you to query the environment variables available on the controller when you invoked Ansible."
     ],
     "filename": "/ansible/plugins/lookup/env.py",
     "name": "env",
     "notes": [
      "You can pass the C(Undefined) object as O(default) to force an undefined error"
     ],
     "options": {
      "_terms": {
       "description": [
        "Environment variable or list of them to lookup the values for."
       ],
       "required": true
      },
      "default": {
       "default": "",
       "description": "What return when the variable is undefined",
       "type": "raw",
       "version_added": "2.13",
       "version_added_collection": "ansible.builtin"
      }
     },
     "short_description": "Read the value of environment variables",
     "version_added": "0.9",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Basic usage\n  ansible.builtin.debug:\n    msg: \"'{{ lookup('ansible.builtin.env', 'HOME') }}' is the HOME environment variable.\"\n\n- name: Before 2.13, how to set default value if the variable is not defined.\n        This cannot distinguish between USR undefined and USR=''.\n  ansible.builtin.debug:\n    msg: \"{{ lookup('ansible.builtin.env', 'USR')|default('nobody', True) }} is the user.\"\n\n- name: Example how to set default value if the variable is not defined, ignores USR=''\n  ansible.builtin.debug:\n    msg: \"{{ lookup('ansible.builtin.env', 'USR', default='nobody') }} is the user.\"\n\n- name: Set default value to Undefined, if the variable is not defined\n  ansible.builtin.debug:\n    msg: \"{{ lookup('ansible.builtin.env', 'USR', default=Undefined) }} is the user.\"\n\n- name: Set default value to undef(), if the variable is not defined\n  ansible.builtin.debug:\n    msg: \"{{ lookup('ansible.builtin.env', 'USR', default=undef()) }} is the user.\"\n",
    "metadata": null,
    "return": {
     "_list": {
      "description": [
       "Values from the environment variables."
      ],
      "type": "list"
     }
    }
   },
   "ansible.builtin.file": {
    "doc": {
     "author": "Daniel Hokka Zakrisson (!UNKNOWN) <daniel@hozac.com>",
     "collection": "ansible.builtin",
     "description": [
      "This lookup returns the contents from a file on the Ansible controller's file system."
     ],
     "filename": "/ansible/plugins/lookup/file.py",
     "name": "file",
     "notes": [
      "if read in variable context, the file can be interpreted as YAML if the content is valid to the parser.",
      "this lookup does not understand 'globbing', use the fileglob lookup instead."
     ],
     "options": {
      "_terms": {
       "description": "path(s) of files to read",
       "required": true
      },
      "lstrip": {
       "default": false,
       "description": "whether or not to remove whitespace from the beginning of the looked-up file",
       "required": false,
       "type": "bool"
      },
      "rstrip": {
       "default": true,
       "description": "whether or not to remove whitespace from the ending of the looked-up file",
       "required": false,
       "type": "bool"
      }
     },
     "seealso": [
      {
       "description": "Search paths used for relative files.",
       "ref": "playbook_task_paths"
      }
     ],
     "short_description": "read file contents",
     "version_added": "0.9",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- ansible.builtin.debug:\n    msg: \"the value of foo.txt is {{ lookup('ansible.builtin.file', '/etc/foo.txt') }}\"\n\n- name: display multiple file contents\n  ansible.builtin.debug: var=item\n  with_file:\n    - \"/path/to/foo.txt\"\n    - \"bar.txt\"  # will be looked in files/ dir relative to play or in role\n    - \"/path/to/biz.txt\"\n",
    "metadata": null,
    "return": {
     "_raw": {
      "description": [
       "content of file(s)"
      ],
      "elements": "str",
      "type": "list"
     }
    }
   },
   "ansible.builtin.fileglob": {
    "doc": {
     "author": "Michael DeHaan",
     "collection": "ansible.builtin",
     "description": [
      "Matches all files in a single directory, non-recursively, that match a pattern. It calls Python's \"glob\" library."
     ],
     "filename": "/ansible/plugins/lookup/fileglob.py",
     "name": "fileglob",
     "notes": [
      "Patterns are only supported on files, not directory/paths.",
      "See R(Ansible task paths,playbook_task_paths) to understand how file lookup occurs with paths.",
      "Matching is against local system files on the Ansible controller. To iterate a list of files on a remote node, use the M(ansible.builtin.find) module.",
      "Returns a string list of paths joined by commas, or an empty list if no files match. For a 'true list' pass O(ignore:wantlist=True) to the lookup."
     ],
     "options": {
      "_terms": {
       "description": "path(s) of files to read",
       "required": true
      }
     },
     "seealso": [
      {
       "description": "Search paths used for relative files.",
       "ref": "playbook_task_paths"
      }
     ],
     "short_description": "list files matching a pattern",
     "version_added": "1.4",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Display paths of all .txt files in dir\n  ansible.builtin.debug: msg={{ lookup('ansible.builtin.fileglob', '/my/path/*.txt') }}\n\n- name: Copy each file over that matches the given pattern\n  ansible.builtin.copy:\n    src: \"{{ item }}\"\n    dest: \"/etc/fooapp/\"\n    owner: \"root\"\n    mode: 0600\n  with_fileglob:\n    - \"/playbooks/files/fooapp/*\"\n",
    "metadata": null,
    "return": {
     "_list": {
      "description": [
       "list of files"
      ],
      "elements": "path",
      "type": "list"
     }
    }
   },
   "ansible.builtin.first_found": {
    "doc": {
     "author": "Seth Vidal (!UNKNOWN) <skvidal@fedoraproject.org>",
     "collection": "ansible.builtin",
     "description": [
      "This lookup checks a list of files and paths and returns the full path to the first combination found.",
      "As all lookups, when fed relative paths it will try use the current task's location first and go up the chain to the containing locations of role / play / include and so on.",
      "The list of files has precedence over the paths searched. For example, A task in a role has a 'file1' in the play's relative path, this will be used, 'file2' in role's relative path will not.",
      "Either a list of files O(_terms) or a key O(files) with a list of files is required for this plugin to operate."
     ],
     "filename": "/ansible/plugins/lookup/first_found.py",
     "name": "first_found",
     "notes": [
      "This lookup can be used in 'dual mode', either passing a list of file names or a dictionary that has O(files) and O(paths)."
     ],
     "options": {
      "_terms": {
       "description": "A list of file names."
      },
      "files": {
       "default": [],
       "description": "A list of file names.",
       "elements": "string",
       "type": "list"
      },
      "paths": {
       "default": [],
       "description": "A list of paths in which to look for the files.",
       "elements": "string",
       "type": "list"
      },
      "skip": {
       "default": false,
       "description": [
        "When V(True), return an empty list when no files are matched.",
        "This is useful when used with C(with_first_found), as an empty list return to C(with_) calls causes the calling task to be skipped.",
        "When used as a template via C(lookup) or C(query), setting O(skip=True) will *not* cause the task to skip. Tasks must handle the empty list return from the template.",
        "When V(False) and C(lookup) or C(query) specifies O(ignore:errors='ignore') all errors (including no file found, but potentially others) return an empty string or an empty list respectively.",
        "When V(True) and C(lookup) or C(query) specifies O(ignore:errors='ignore'), no file found will return an empty list and other potential errors return an empty string or empty list depending on the template call (in other words return values of C(lookup) vs C(query))."
       ],
       "type": "boolean"
      }
     },
     "seealso": [
      {
       "description": "Search paths used for relative paths/files.",
       "ref": "playbook_task_paths"
      }
     ],
     "short_description": "return first file found from list",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Set _found_file to the first existing file, raising an error if a file is not found\n  ansible.builtin.set_fact:\n    _found_file: \"{{ lookup('ansible.builtin.first_found', findme) }}\"\n  vars:\n    findme:\n      - /path/to/foo.txt\n      - bar.txt  # will be looked in files/ dir relative to role and/or play\n      - /path/to/biz.txt\n\n- name: Set _found_file to the first existing file, or an empty list if no files found\n  ansible.builtin.set_fact:\n    _found_file: \"{{ lookup('ansible.builtin.first_found', files, paths=['/extra/path'], skip=True) }}\"\n  vars:\n    files:\n      - /path/to/foo.txt\n      - /path/to/bar.txt\n\n- name: Include tasks only if one of the files exist, otherwise skip the task\n  ansible.builtin.include_tasks:\n    file: \"{{ item }}\"\n  with_first_found:\n    - files:\n      - path/tasks.yaml\n      - path/other_tasks.yaml\n      skip: True\n\n- name: Include tasks only if one of the files exists, otherwise skip\n  ansible.builtin.include_tasks: '{{ tasks_file }}'\n  when: tasks_file != \"\"\n  vars:\n    tasks_file: \"{{ lookup('ansible.builtin.first_found', files=['tasks.yaml', 'other_tasks.yaml'], errors='ignore') }}\"\n\n- name: |\n        copy first existing file found to /some/file,\n        looking in relative directories from where the task is defined and\n        including any play objects that contain it\n  ansible.builtin.copy:\n    src: \"{{ lookup('ansible.builtin.first_found', findme) }}\"\n    dest: /some/file\n  vars:\n    findme:\n      - foo\n      - \"{{ inventory_hostname }}\"\n      - bar\n\n- name: same copy but specific paths\n  ansible.builtin.copy:\n    src: \"{{ lookup('ansible.builtin.first_found', params) }}\"\n    dest: /some/file\n  vars:\n    params:\n      files:\n        - foo\n        - \"{{ inventory_hostname }}\"\n        - bar\n      paths:\n        - /tmp/production\n        - /tmp/staging\n\n- name: INTERFACES | Create Ansible header for /etc/network/interfaces\n  ansible.builtin.template:\n    src: \"{{ lookup('ansible.builtin.first_found', findme)}}\"\n    dest: \"/etc/foo.conf\"\n  vars:\n    findme:\n      - \"{{ ansible_virtualization_type }}_foo.conf\"\n      - \"default_foo.conf\"\n\n- name: read vars from first file found, use 'vars/' relative subdir\n  ansible.builtin.include_vars: \"{{lookup('ansible.builtin.first_found', params)}}\"\n  vars:\n    params:\n      files:\n        - '{{ ansible_distribution }}.yml'\n        - '{{ ansible_os_family }}.yml'\n        - default.yml\n      paths:\n        - 'vars'\n",
    "metadata": null,
    "return": {
     "_raw": {
      "description": [
       "path to file found"
      ],
      "elements": "path",
      "type": "list"
     }
    }
   },
   "ansible.builtin.indexed_items": {
    "doc": {
     "author": "Michael DeHaan",
     "collection": "ansible.builtin",
     "description": [
      "use this lookup if you want to loop over an array and also get the numeric index of where you are in the array as you go",
      "any list given will be transformed with each resulting element having the it's previous position in item.0 and its value in item.1"
     ],
     "filename": "/ansible/plugins/lookup/indexed_items.py",
     "name": "indexed_items",
     "options": {
      "_terms": {
       "description": "list of items",
       "required": true
      }
     },
     "short_description": "rewrites lists to return 'indexed items'",
     "version_added": "1.3",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: indexed loop demo\n  ansible.builtin.debug:\n    msg: \"at array position {{ item.0 }} there is a value {{ item.1 }}\"\n  with_indexed_items:\n    - \"{{ some_list }}\"\n",
    "metadata": null,
    "return": {
     "_raw": {
      "description": [
       "list with each item.0 giving you the position and item.1 the value"
      ],
      "elements": "list",
      "type": "list"
     }
    }
   },
   "ansible.builtin.ini": {
    "doc": {
     "author": "Yannig Perre (!UNKNOWN) <yannig.perre(at)gmail.com>",
     "collection": "ansible.builtin",
     "description": [
      "The ini lookup reads the contents of a file in INI format C(key1=value1). This plugin retrieves the value on the right side after the equal sign C('=') of a given section C([section]).",
      "You can also read a property file which - in this case - does not contain section."
     ],
     "filename": "/ansible/plugins/lookup/ini.py",
     "name": "ini",
     "options": {
      "_terms": {
       "description": "The key(s) to look up.",
       "required": true
      },
      "allow_no_value": {
       "aliases": [
        "allow_none"
       ],
       "default": false,
       "description": [
        "Read an ini file which contains key without value and without '=' symbol."
       ],
       "type": "bool",
       "version_added": "2.12",
       "version_added_collection": "ansible.builtin"
      },
      "case_sensitive": {
       "default": false,
       "description": "Whether key names read from O(file) should be case sensitive. This prevents duplicate key errors if keys only differ in case.",
       "version_added": "2.12",
       "version_added_collection": "ansible.builtin"
      },
      "default": {
       "default": "",
       "description": "Return value if the key is not in the ini file."
      },
      "encoding": {
       "default": "utf-8",
       "description": "Text encoding to use."
      },
      "file": {
       "default": "ansible.ini",
       "description": "Name of the file to load."
      },
      "re": {
       "default": false,
       "description": "Flag to indicate if the key supplied is a regexp.",
       "type": "boolean"
      },
      "section": {
       "default": "global",
       "description": "Section where to lookup the key."
      },
      "type": {
       "choices": [
        "ini",
        "properties"
       ],
       "default": "ini",
       "description": "Type of the file. 'properties' refers to the Java properties files."
      }
     },
     "seealso": [
      {
       "description": "Search paths used for relative files.",
       "ref": "playbook_task_paths"
      }
     ],
     "short_description": "read data from an ini file",
     "version_added": "2.0",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- ansible.builtin.debug: msg=\"User in integration is {{ lookup('ansible.builtin.ini', 'user', section='integration', file='users.ini') }}\"\n\n- ansible.builtin.debug: msg=\"User in production  is {{ lookup('ansible.builtin.ini', 'user', section='production',  file='users.ini') }}\"\n\n- ansible.builtin.debug: msg=\"user.name is {{ lookup('ansible.builtin.ini', 'user.name', type='properties', file='user.properties') }}\"\n\n- ansible.builtin.debug:\n    msg: \"{{ item }}\"\n  loop: \"{{ q('ansible.builtin.ini', '.*', section='section1', file='test.ini', re=True) }}\"\n\n- name: Read an ini file with allow_no_value\n  ansible.builtin.debug:\n    msg: \"{{ lookup('ansible.builtin.ini', 'user', file='mysql.ini', section='mysqld', allow_no_value=True) }}\"\n",
    "metadata": null,
    "return": {
     "_raw": {
      "description": [
       "value(s) of the key(s) in the ini file"
      ],
      "elements": "str",
      "type": "list"
     }
    }
   },
   "ansible.builtin.inventory_hostnames": {
    "doc": {
     "author": [
      "Michael DeHaan",
      "Steven Dossett (!UNKNOWN) <sdossett@panath.com>"
     ],
     "collection": "ansible.builtin",
     "description": [
      "This lookup understands 'host patterns' as used by the C(hosts:) keyword in plays and can return a list of matching hosts from inventory"
     ],
     "filename": "/ansible/plugins/lookup/inventory_hostnames.py",
     "name": "inventory_hostnames",
     "notes": [
      "this is only worth for 'hostname patterns' it is easier to loop over the group/group_names variables otherwise."
     ],
     "short_description": "list of inventory hosts matching a host pattern",
     "version_added": "1.3",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: show all the hosts matching the pattern, i.e. all but the group www\n  ansible.builtin.debug:\n    msg: \"{{ item }}\"\n  with_inventory_hostnames:\n    - all:!www\n",
    "metadata": null,
    "return": {
     "_hostnames": {
      "description": "list of hostnames that matched the host pattern in inventory",
      "type": "list"
     }
    }
   },
   "ansible.builtin.items": {
    "doc": {
     "author": "Michael DeHaan",
     "collection": "ansible.builtin",
     "description": [
      "this lookup returns a list of items given to it, if any of the top level items is also a list it will flatten it, but it will not recurse"
     ],
     "filename": "/ansible/plugins/lookup/items.py",
     "name": "items",
     "notes": [
      "this is the standard lookup used for loops in most examples",
      "check out the 'flattened' lookup for recursive flattening",
      "if you do not want flattening nor any other transformation look at the 'list' lookup."
     ],
     "options": {
      "_terms": {
       "description": "list of items",
       "required": true
      }
     },
     "short_description": "list of items",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: \"loop through list\"\n  ansible.builtin.debug:\n    msg: \"An item: {{ item }}\"\n  with_items:\n    - 1\n    - 2\n    - 3\n\n- name: add several users\n  ansible.builtin.user:\n    name: \"{{ item }}\"\n    groups: \"wheel\"\n    state: present\n  with_items:\n     - testuser1\n     - testuser2\n\n- name: \"loop through list from a variable\"\n  ansible.builtin.debug:\n    msg: \"An item: {{ item }}\"\n  with_items: \"{{ somelist }}\"\n\n- name: more complex items to add several users\n  ansible.builtin.user:\n    name: \"{{ item.name }}\"\n    uid: \"{{ item.uid }}\"\n    groups: \"{{ item.groups }}\"\n    state: present\n  with_items:\n     - { name: testuser1, uid: 1002, groups: \"wheel, staff\" }\n     - { name: testuser2, uid: 1003, groups: staff }\n\n",
    "metadata": null,
    "return": {
     "_raw": {
      "description": [
       "once flattened list"
      ],
      "type": "list"
     }
    }
   },
   "ansible.builtin.lines": {
    "doc": {
     "author": "Daniel Hokka Zakrisson (!UNKNOWN) <daniel@hozac.com>",
     "collection": "ansible.builtin",
     "description": [
      "Run one or more commands and split the output into lines, returning them as a list"
     ],
     "filename": "/ansible/plugins/lookup/lines.py",
     "name": "lines",
     "notes": [
      "Like all lookups, this runs on the Ansible controller and is unaffected by other keywords such as 'become'. If you need to use different permissions, you must change the command or run Ansible as another user.",
      "Alternatively, you can use a shell/command task that runs against localhost and registers the result.",
      "The directory of the play is used as the current working directory."
     ],
     "options": {
      "_terms": {
       "description": "command(s) to run",
       "required": true
      }
     },
     "short_description": "read lines from command",
     "version_added": "0.9",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: We could read the file directly, but this shows output from command\n  ansible.builtin.debug: msg=\"{{ item }} is an output line from running cat on /etc/motd\"\n  with_lines: cat /etc/motd\n\n- name: More useful example of looping over a command result\n  ansible.builtin.shell: \"/usr/bin/frobnicate {{ item }}\"\n  with_lines:\n    - \"/usr/bin/frobnications_per_host --param {{ inventory_hostname }}\"\n",
    "metadata": null,
    "return": {
     "_list": {
      "description": [
       "lines of stdout from command"
      ],
      "elements": "str",
      "type": "list"
     }
    }
   },
   "ansible.builtin.list": {
    "doc": {
     "author": "Ansible Core Team",
     "collection": "ansible.builtin",
     "description": [
      "this is mostly a noop, to be used as a with_list loop when you dont want the content transformed in any way."
     ],
     "filename": "/ansible/plugins/lookup/list.py",
     "name": "list",
     "short_description": "simply returns what it is given.",
     "version_added": "2.0",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: unlike with_items you will get 3 items from this loop, the 2nd one being a list\n  ansible.builtin.debug: var=item\n  with_list:\n    - 1\n    - [2,3]\n    - 4\n",
    "metadata": null,
    "return": {
     "_list": {
      "description": "basically the same as you fed in",
      "elements": "raw",
      "type": "list"
     }
    }
   },
   "ansible.builtin.nested": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Takes the input lists and returns a list with elements that are lists composed of the elements of the input lists"
     ],
     "filename": "/ansible/plugins/lookup/nested.py",
     "name": "nested",
     "options": {
      "_raw": {
       "description": [
        "a set of lists"
       ],
       "required": true
      }
     },
     "short_description": "composes a list with nested elements of other lists",
     "version_added": "1.1",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: give users access to multiple databases\n  community.mysql.mysql_user:\n    name: \"{{ item[0] }}\"\n    priv: \"{{ item[1] }}.*:ALL\"\n    append_privs: yes\n    password: \"foo\"\n  with_nested:\n    - [ 'alice', 'bob' ]\n    - [ 'clientdb', 'employeedb', 'providerdb' ]\n# As with the case of 'with_items' above, you can use previously defined variables.:\n\n- name: here, 'users' contains the above list of employees\n  community.mysql.mysql_user:\n    name: \"{{ item[0] }}\"\n    priv: \"{{ item[1] }}.*:ALL\"\n    append_privs: yes\n    password: \"foo\"\n  with_nested:\n    - \"{{ users }}\"\n    - [ 'clientdb', 'employeedb', 'providerdb' ]\n",
    "metadata": null,
    "return": {
     "_list": {
      "description": [
       "A list composed of lists paring the elements of the input lists"
      ],
      "type": "list"
     }
    }
   },
   "ansible.builtin.password": {
    "doc": {
     "author": [
      "Daniel Hokka Zakrisson (!UNKNOWN) <daniel@hozac.com>",
      "Javier Candeira (!UNKNOWN) <javier@candeira.com>",
      "Maykel Moya (!UNKNOWN) <mmoya@speedyrails.com>"
     ],
     "collection": "ansible.builtin",
     "description": [
      "Generates a random plaintext password and stores it in a file at a given filepath.",
      "If the file exists previously, it will retrieve its contents, behaving just like with_file.",
      "Usage of variables like C(\"{{ inventory_hostname }}\") in the filepath can be used to set up random passwords per host, which simplifies password management in C(\"host_vars\") variables.",
      "A special case is using /dev/null as a path. The password lookup will generate a new random password each time, but will not write it to /dev/null. This can be used when you need a password without storing it on the controller."
     ],
     "filename": "/ansible/plugins/lookup/password.py",
     "name": "password",
     "notes": [
      "A great alternative to the password lookup plugin, if you don't need to generate random passwords on a per-host basis, would be to use Vault in playbooks. Read the documentation there and consider using it first, it will be more desirable for most applications.",
      "If the file already exists, no data will be written to it. If the file has contents, those contents will be read in as the password. Empty files cause the password to return as an empty string.",
      "As all lookups, this runs on the Ansible host as the user running the playbook, and \"become\" does not apply, the target file must be readable by the playbook user, or, if it does not exist, the playbook user must have sufficient privileges to create it. (So, for example, attempts to write into areas such as /etc will fail unless the entire playbook is being run as root)."
     ],
     "options": {
      "_terms": {
       "description": [
        "path to the file that stores/will store the passwords"
       ],
       "required": true
      },
      "chars": {
       "default": [
        "ascii_letters",
        "digits",
        ".,:-_"
       ],
       "description": [
        "A list of names that compose a custom character set in the generated passwords.",
        "This parameter defines the possible character sets in the resulting password, not the required character sets. If you want to require certain character sets for passwords, you can use the P(community.general.random_string#lookup) lookup plugin.",
        "By default generated passwords contain a random mix of upper and lowercase ASCII letters, the numbers 0-9, and punctuation (\". , : - _\").",
        "They can be either parts of Python's string module attributes or represented literally ( :, -).",
        "Though string modules can vary by Python version, valid values for both major releases include: 'ascii_lowercase', 'ascii_uppercase', 'digits', 'hexdigits', 'octdigits', 'printable', 'punctuation' and 'whitespace'.",
        "Be aware that Python's 'hexdigits' includes lower and upper case versions of a-f, so it is not a good choice as it doubles the chances of those values for systems that won't distinguish case, distorting the expected entropy.",
        "when using a comma separated string, to enter comma use two commas ',,' somewhere - preferably at the end. Quotes and double quotes are not supported."
       ],
       "elements": "str",
       "type": "list",
       "version_added": "1.4",
       "version_added_collection": "ansible.builtin"
      },
      "encrypt": {
       "description": [
        "Which hash scheme to encrypt the returning password, should be one hash scheme from C(passlib.hash); V(md5_crypt), V(bcrypt), V(sha256_crypt), V(sha512_crypt).",
        "If not provided, the password will be returned in plain text.",
        "Note that the password is always stored as plain text, only the returning password is encrypted.",
        "Encrypt also forces saving the salt value for idempotence.",
        "Note that before 2.6 this option was incorrectly labeled as a boolean for a long time."
       ]
      },
      "ident": {
       "description": [
        "Specify version of Bcrypt algorithm to be used while using O(encrypt) as V(bcrypt).",
        "The parameter is only available for V(bcrypt) - U(https://passlib.readthedocs.io/en/stable/lib/passlib.hash.bcrypt.html#passlib.hash.bcrypt).",
        "Other hash types will simply ignore this parameter.",
        "Valid values for this parameter are: V(2), V(2a), V(2y), V(2b)."
       ],
       "type": "string",
       "version_added": "2.12",
       "version_added_collection": "ansible.builtin"
      },
      "length": {
       "default": 20,
       "description": "The length of the generated password.",
       "type": "integer"
      },
      "seed": {
       "description": [
        "A seed to initialize the random number generator.",
        "Identical seeds will yield identical passwords.",
        "Use this for random-but-idempotent password generation."
       ],
       "type": "str",
       "version_added": "2.12",
       "version_added_collection": "ansible.builtin"
      }
     },
     "short_description": "retrieve or generate a random password, stored in a file",
     "version_added": "1.1",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: create a mysql user with a random password\n  community.mysql.mysql_user:\n    name: \"{{ client }}\"\n    password: \"{{ lookup('ansible.builtin.password', 'credentials/' + client + '/' + tier + '/' + role + '/mysqlpassword', length=15) }}\"\n    priv: \"{{ client }}_{{ tier }}_{{ role }}.*:ALL\"\n\n- name: create a mysql user with a random password using only ascii letters\n  community.mysql.mysql_user:\n    name: \"{{ client }}\"\n    password: \"{{ lookup('ansible.builtin.password', '/tmp/passwordfile', chars=['ascii_letters']) }}\"\n    priv: '{{ client }}_{{ tier }}_{{ role }}.*:ALL'\n\n- name: create a mysql user with an 8 character random password using only digits\n  community.mysql.mysql_user:\n    name: \"{{ client }}\"\n    password: \"{{ lookup('ansible.builtin.password', '/tmp/passwordfile', length=8, chars=['digits']) }}\"\n    priv: \"{{ client }}_{{ tier }}_{{ role }}.*:ALL\"\n\n- name: create a mysql user with a random password using many different char sets\n  community.mysql.mysql_user:\n    name: \"{{ client }}\"\n    password: \"{{ lookup('ansible.builtin.password', '/tmp/passwordfile', chars=['ascii_letters', 'digits', 'punctuation']) }}\"\n    priv: \"{{ client }}_{{ tier }}_{{ role }}.*:ALL\"\n\n- name: create lowercase 8 character name for Kubernetes pod name\n  ansible.builtin.set_fact:\n    random_pod_name: \"web-{{ lookup('ansible.builtin.password', '/dev/null', chars=['ascii_lowercase', 'digits'], length=8) }}\"\n\n- name: create random but idempotent password\n  ansible.builtin.set_fact:\n    password: \"{{ lookup('ansible.builtin.password', '/dev/null', seed=inventory_hostname) }}\"\n",
    "metadata": null,
    "return": {
     "_raw": {
      "description": [
       "a password"
      ],
      "elements": "str",
      "type": "list"
     }
    }
   },
   "ansible.builtin.pipe": {
    "doc": {
     "author": "Daniel Hokka Zakrisson (!UNKNOWN) <daniel@hozac.com>",
     "collection": "ansible.builtin",
     "description": [
      "Run a command and return the output."
     ],
     "filename": "/ansible/plugins/lookup/pipe.py",
     "name": "pipe",
     "notes": [
      "Like all lookups this runs on the Ansible controller and is unaffected by other keywords, such as become, so if you need to different permissions you must change the command or run Ansible as another user.",
      "Alternatively you can use a shell/command task that runs against localhost and registers the result.",
      "Pipe lookup internally invokes Popen with shell=True (this is required and intentional). This type of invocation is considered a security issue if appropriate care is not taken to sanitize any user provided or variable input. It is strongly recommended to pass user input or variable input via quote filter before using with pipe lookup. See example section for this. Read more about this L(Bandit B602 docs,https://bandit.readthedocs.io/en/latest/plugins/b602_subprocess_popen_with_shell_equals_true.html)",
      "The directory of the play is used as the current working directory."
     ],
     "options": {
      "_terms": {
       "description": "command(s) to run.",
       "required": true
      }
     },
     "short_description": "read output from a command",
     "version_added": "0.9",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: raw result of running date command\n  ansible.builtin.debug:\n    msg: \"{{ lookup('ansible.builtin.pipe', 'date') }}\"\n\n- name: Always use quote filter to make sure your variables are safe to use with shell\n  ansible.builtin.debug:\n    msg: \"{{ lookup('ansible.builtin.pipe', 'getent passwd ' + myuser | quote ) }}\"\n",
    "metadata": null,
    "return": {
     "_string": {
      "description": [
       "stdout from command"
      ],
      "elements": "str",
      "type": "list"
     }
    }
   },
   "ansible.builtin.random_choice": {
    "doc": {
     "author": "Michael DeHaan",
     "collection": "ansible.builtin",
     "description": [
      "The 'random_choice' feature can be used to pick something at random. While it's not a load balancer (there are modules for those), it can somewhat be used as a poor man's load balancer in a MacGyver like situation.",
      "At a more basic level, they can be used to add chaos and excitement to otherwise predictable automation environments."
     ],
     "filename": "/ansible/plugins/lookup/random_choice.py",
     "name": "random_choice",
     "short_description": "return random element from list",
     "version_added": "1.1",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Magic 8 ball for MUDs\n  ansible.builtin.debug:\n    msg: \"{{ item }}\"\n  with_random_choice:\n     - \"go through the door\"\n     - \"drink from the goblet\"\n     - \"press the red button\"\n     - \"do nothing\"\n",
    "metadata": null,
    "return": {
     "_raw": {
      "description": [
       "random item"
      ],
      "type": "raw"
     }
    }
   },
   "ansible.builtin.sequence": {
    "doc": {
     "author": "Jayson Vantuyl (!UNKNOWN) <jayson@aggressive.ly>",
     "collection": "ansible.builtin",
     "description": [
      "generates a sequence of items. You can specify a start value, an end value, an optional \"stride\" value that specifies the number of steps to increment the sequence, and an optional printf-style format string.",
      "Arguments can be specified as key=value pair strings or as a shortcut form of the arguments string is also accepted: [start-]end[/stride][:format].",
      "Numerical values can be specified in decimal, hexadecimal (0x3f8) or octal (0600).",
      "Starting at version 1.9.2, negative strides are allowed.",
      "Generated items are strings. Use Jinja2 filters to convert items to preferred type, e.g. C({{ 1 + item|int }}).",
      "See also Jinja2 C(range) filter as an alternative."
     ],
     "filename": "/ansible/plugins/lookup/sequence.py",
     "name": "sequence",
     "options": {
      "count": {
       "description": "number of elements in the sequence, this is not to be used with end",
       "type": "integer"
      },
      "end": {
       "description": "number at which to end the sequence, dont use this with count",
       "type": "integer"
      },
      "format": {
       "default": "%d",
       "description": "return a string with the generated number formatted in"
      },
      "start": {
       "default": 1,
       "description": "number at which to start the sequence",
       "type": "integer"
      },
      "stride": {
       "default": 1,
       "description": "increments between sequence numbers, the default is 1 unless the end is less than the start, then it is -1.",
       "type": "integer"
      }
     },
     "short_description": "generate a list based on a number sequence",
     "version_added": "1.0",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: create some test users\n  ansible.builtin.user:\n    name: \"{{ item }}\"\n    state: present\n    groups: \"evens\"\n  with_sequence: start=0 end=32 format=testuser%02x\n\n- name: create a series of directories with even numbers for some reason\n  ansible.builtin.file:\n    dest: \"/var/stuff/{{ item }}\"\n    state: directory\n  with_sequence: start=4 end=16 stride=2\n\n- name: a simpler way to use the sequence plugin create 4 groups\n  ansible.builtin.group:\n    name: \"group{{ item }}\"\n    state: present\n  with_sequence: count=4\n\n- name: the final countdown\n  ansible.builtin.debug:\n    msg: \"{{item}} seconds to detonation\"\n  with_sequence: start=10 end=0 stride=-1\n\n- name: Use of variable\n  ansible.builtin.debug:\n    msg: \"{{ item }}\"\n  with_sequence: start=1 end=\"{{ end_at }}\"\n  vars:\n    - end_at: 10\n",
    "metadata": null,
    "return": {
     "_list": {
      "description": [
       "A list containing generated sequence of items"
      ],
      "elements": "str",
      "type": "list"
     }
    }
   },
   "ansible.builtin.subelements": {
    "doc": {
     "author": "Serge van Ginderachter (!UNKNOWN) <serge@vanginderachter.be>",
     "collection": "ansible.builtin",
     "description": [
      "Subelements walks a list of hashes (aka dictionaries) and then traverses a list with a given (nested sub-)key inside of those records."
     ],
     "filename": "/ansible/plugins/lookup/subelements.py",
     "name": "subelements",
     "options": {
      "_terms": {
       "description": "tuple of list of dictionaries and dictionary key to extract",
       "required": true
      },
      "skip_missing": {
       "default": false,
       "description": [
        "Lookup accepts this flag from a dictionary as optional. See Example section for more information.",
        "If set to V(True), the lookup plugin will skip the lists items that do not contain the given subkey.",
        "If set to V(False), the plugin will yield an error and complain about the missing subkey."
       ]
      }
     },
     "short_description": "traverse nested key from a list of dictionaries",
     "version_added": "1.4",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: show var structure as it is needed for example to make sense\n  hosts: all\n  vars:\n    users:\n      - name: alice\n        authorized:\n          - /tmp/alice/onekey.pub\n          - /tmp/alice/twokey.pub\n        mysql:\n            password: mysql-password\n            hosts:\n              - \"%\"\n              - \"127.0.0.1\"\n              - \"::1\"\n              - \"localhost\"\n            privs:\n              - \"*.*:SELECT\"\n              - \"DB1.*:ALL\"\n        groups:\n          - wheel\n      - name: bob\n        authorized:\n          - /tmp/bob/id_rsa.pub\n        mysql:\n            password: other-mysql-password\n            hosts:\n              - \"db1\"\n            privs:\n              - \"*.*:SELECT\"\n              - \"DB2.*:ALL\"\n  tasks:\n    - name: Set authorized ssh key, extracting just that data from 'users'\n      ansible.posix.authorized_key:\n        user: \"{{ item.0.name }}\"\n        key: \"{{ lookup('file', item.1) }}\"\n      with_subelements:\n         - \"{{ users }}\"\n         - authorized\n\n    - name: Setup MySQL users, given the mysql hosts and privs subkey lists\n      community.mysql.mysql_user:\n        name: \"{{ item.0.name }}\"\n        password: \"{{ item.0.mysql.password }}\"\n        host: \"{{ item.1 }}\"\n        priv: \"{{ item.0.mysql.privs | join('/') }}\"\n      with_subelements:\n        - \"{{ users }}\"\n        - mysql.hosts\n\n    - name: list groups for users that have them, don't error if groups key is missing\n      ansible.builtin.debug: var=item\n      loop: \"{{ q('ansible.builtin.subelements', users, 'groups', {'skip_missing': True}) }}\"\n",
    "metadata": null,
    "return": {
     "_list": {
      "description": "list of subelements extracted"
     }
    }
   },
   "ansible.builtin.template": {
    "doc": {
     "author": "Michael DeHaan",
     "collection": "ansible.builtin",
     "description": [
      "Returns a list of strings; for each template in the list of templates you pass in, returns a string containing the results of processing that template."
     ],
     "filename": "/ansible/plugins/lookup/template.py",
     "name": "template",
     "options": {
      "_terms": {
       "description": "list of files to template"
      },
      "comment_end_string": {
       "default": "#}",
       "description": "The string marking the end of a comment statement.",
       "type": "str",
       "version_added": "2.12",
       "version_added_collection": "ansible.builtin"
      },
      "comment_start_string": {
       "default": "{#",
       "description": "The string marking the beginning of a comment statement.",
       "type": "str",
       "version_added": "2.12",
       "version_added_collection": "ansible.builtin"
      },
      "convert_data": {
       "default": true,
       "description": [
        "Whether to convert YAML into data. If False, strings that are YAML will be left untouched.",
        "Mutually exclusive with the jinja2_native option."
       ],
       "type": "bool"
      },
      "jinja2_native": {
       "default": false,
       "description": [
        "Controls whether to use Jinja2 native types.",
        "It is off by default even if global jinja2_native is True.",
        "Has no effect if global jinja2_native is False.",
        "This offers more flexibility than the template module which does not use Jinja2 native types at all.",
        "Mutually exclusive with the convert_data option."
       ],
       "type": "bool",
       "version_added": "2.11",
       "version_added_collection": "ansible.builtin"
      },
      "template_vars": {
       "default": {},
       "description": "A dictionary, the keys become additional variables available for templating.",
       "type": "dict",
       "version_added": "2.3",
       "version_added_collection": "ansible.builtin"
      },
      "variable_end_string": {
       "default": "}}",
       "description": "The string marking the end of a print statement.",
       "type": "str",
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      },
      "variable_start_string": {
       "default": "{{",
       "description": "The string marking the beginning of a print statement.",
       "type": "str",
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      }
     },
     "seealso": [
      {
       "description": "Search paths used for relative templates.",
       "ref": "playbook_task_paths"
      }
     ],
     "short_description": "retrieve contents of file after templating with Jinja2",
     "version_added": "0.9",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: show templating results\n  ansible.builtin.debug:\n    msg: \"{{ lookup('ansible.builtin.template', './some_template.j2') }}\"\n\n- name: show templating results with different variable start and end string\n  ansible.builtin.debug:\n    msg: \"{{ lookup('ansible.builtin.template', './some_template.j2', variable_start_string='[%', variable_end_string='%]') }}\"\n\n- name: show templating results with different comment start and end string\n  ansible.builtin.debug:\n    msg: \"{{ lookup('ansible.builtin.template', './some_template.j2', comment_start_string='[#', comment_end_string='#]') }}\"\n",
    "metadata": null,
    "return": {
     "_raw": {
      "description": "file(s) content after templating",
      "elements": "raw",
      "type": "list"
     }
    }
   },
   "ansible.builtin.together": {
    "doc": {
     "author": "Bradley Young (!UNKNOWN) <young.bradley@gmail.com>",
     "collection": "ansible.builtin",
     "description": [
      "Creates a list with the iterated elements of the supplied lists",
      "To clarify with an example, [ 'a', 'b' ] and [ 1, 2 ] turn into [ ('a',1), ('b', 2) ]",
      "This is basically the same as the 'zip_longest' filter and Python function",
      "Any 'unbalanced' elements will be substituted with 'None'"
     ],
     "filename": "/ansible/plugins/lookup/together.py",
     "name": "together",
     "options": {
      "_terms": {
       "description": "list of lists to merge",
       "required": true
      }
     },
     "short_description": "merges lists into synchronized list",
     "version_added": "1.3",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: item.0 returns from the 'a' list, item.1 returns from the '1' list\n  ansible.builtin.debug:\n    msg: \"{{ item.0 }} and {{ item.1 }}\"\n  with_together:\n    - ['a', 'b', 'c', 'd']\n    - [1, 2, 3, 4]\n",
    "metadata": null,
    "return": {
     "_list": {
      "description": "synchronized list",
      "elements": "list",
      "type": "list"
     }
    }
   },
   "ansible.builtin.unvault": {
    "doc": {
     "author": "Ansible Core Team",
     "collection": "ansible.builtin",
     "description": [
      "This lookup returns the contents from vaulted (or not) file(s) on the Ansible controller's file system."
     ],
     "filename": "/ansible/plugins/lookup/unvault.py",
     "name": "unvault",
     "notes": [
      "This lookup does not understand 'globbing' nor shell environment variables."
     ],
     "options": {
      "_terms": {
       "description": "path(s) of files to read",
       "required": true
      }
     },
     "seealso": [
      {
       "description": "Search paths used for relative files.",
       "ref": "playbook_task_paths"
      }
     ],
     "short_description": "read vaulted file(s) contents",
     "version_added": "2.10",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- ansible.builtin.debug: msg=\"the value of foo.txt is {{ lookup('ansible.builtin.unvault', '/etc/foo.txt') | string | trim }}\"\n",
    "metadata": null,
    "return": {
     "_raw": {
      "description": [
       "content of file(s) as bytes"
      ],
      "elements": "raw",
      "type": "list"
     }
    }
   },
   "ansible.builtin.url": {
    "doc": {
     "author": "Brian Coca (@bcoca)",
     "collection": "ansible.builtin",
     "description": [
      "Returns the content of the URL requested to be used as data in play."
     ],
     "filename": "/ansible/plugins/lookup/url.py",
     "name": "url",
     "options": {
      "_terms": {
       "description": "urls to query"
      },
      "ca_path": {
       "description": "String of file system path to CA cert bundle to use",
       "env": [
        {
         "name": "ANSIBLE_LOOKUP_URL_CA_PATH"
        }
       ],
       "ini": [
        {
         "key": "ca_path",
         "section": "url_lookup"
        }
       ],
       "type": "string",
       "vars": [
        {
         "name": "ansible_lookup_url_ca_path"
        }
       ],
       "version_added": "2.10",
       "version_added_collection": "ansible.builtin"
      },
      "ciphers": {
       "description": [
        "SSL/TLS Ciphers to use for the request",
        "When a list is provided, all ciphers are joined in order with C(:)",
        "See the L(OpenSSL Cipher List Format,https://www.openssl.org/docs/manmaster/man1/openssl-ciphers.html#CIPHER-LIST-FORMAT) for more details.",
        "The available ciphers is dependent on the Python and OpenSSL/LibreSSL versions"
       ],
       "elements": "string",
       "env": [
        {
         "name": "ANSIBLE_LOOKUP_URL_CIPHERS"
        }
       ],
       "ini": [
        {
         "key": "ciphers",
         "section": "url_lookup"
        }
       ],
       "type": "list",
       "vars": [
        {
         "name": "ansible_lookup_url_ciphers"
        }
       ],
       "version_added": "2.14",
       "version_added_collection": "ansible.builtin"
      },
      "follow_redirects": {
       "choices": [
        "urllib2",
        "all",
        "yes",
        "safe",
        "none",
        "no"
       ],
       "default": "urllib2",
       "description": "String of urllib2, all/yes, safe, none to determine how redirects are followed",
       "env": [
        {
         "name": "ANSIBLE_LOOKUP_URL_FOLLOW_REDIRECTS"
        }
       ],
       "ini": [
        {
         "key": "follow_redirects",
         "section": "url_lookup"
        }
       ],
       "type": "string",
       "vars": [
        {
         "name": "ansible_lookup_url_follow_redirects"
        }
       ],
       "version_added": "2.10",
       "version_added_collection": "ansible.builtin"
      },
      "force": {
       "default": false,
       "description": "Whether or not to set \"cache-control\" header with value \"no-cache\"",
       "env": [
        {
         "name": "ANSIBLE_LOOKUP_URL_FORCE"
        }
       ],
       "ini": [
        {
         "key": "force",
         "section": "url_lookup"
        }
       ],
       "type": "boolean",
       "vars": [
        {
         "name": "ansible_lookup_url_force"
        }
       ],
       "version_added": "2.10",
       "version_added_collection": "ansible.builtin"
      },
      "force_basic_auth": {
       "default": false,
       "description": "Force basic authentication",
       "env": [
        {
         "name": "ANSIBLE_LOOKUP_URL_FORCE_BASIC_AUTH"
        }
       ],
       "ini": [
        {
         "key": "force_basic_auth",
         "section": "url_lookup"
        }
       ],
       "type": "boolean",
       "vars": [
        {
         "name": "ansible_lookup_url_force_basic_auth"
        }
       ],
       "version_added": "2.10",
       "version_added_collection": "ansible.builtin"
      },
      "headers": {
       "default": {},
       "description": "HTTP request headers",
       "type": "dictionary",
       "version_added": "2.9",
       "version_added_collection": "ansible.builtin"
      },
      "http_agent": {
       "default": "ansible-httpget",
       "description": "User-Agent to use in the request. The default was changed in 2.11 to V(ansible-httpget).",
       "env": [
        {
         "name": "ANSIBLE_LOOKUP_URL_AGENT"
        }
       ],
       "ini": [
        {
         "key": "agent",
         "section": "url_lookup"
        }
       ],
       "type": "string",
       "vars": [
        {
         "name": "ansible_lookup_url_agent"
        }
       ],
       "version_added": "2.10",
       "version_added_collection": "ansible.builtin"
      },
      "password": {
       "description": "Password to use for HTTP authentication.",
       "type": "string",
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      },
      "split_lines": {
       "default": true,
       "description": "Flag to control if content is returned as a list of lines or as a single text blob",
       "type": "boolean"
      },
      "timeout": {
       "default": 10,
       "description": "How long to wait for the server to send data before giving up",
       "env": [
        {
         "name": "ANSIBLE_LOOKUP_URL_TIMEOUT"
        }
       ],
       "ini": [
        {
         "key": "timeout",
         "section": "url_lookup"
        }
       ],
       "type": "float",
       "vars": [
        {
         "name": "ansible_lookup_url_timeout"
        }
       ],
       "version_added": "2.10",
       "version_added_collection": "ansible.builtin"
      },
      "unix_socket": {
       "description": "String of file system path to unix socket file to use when establishing connection to the provided url",
       "env": [
        {
         "name": "ANSIBLE_LOOKUP_URL_UNIX_SOCKET"
        }
       ],
       "ini": [
        {
         "key": "unix_socket",
         "section": "url_lookup"
        }
       ],
       "type": "string",
       "vars": [
        {
         "name": "ansible_lookup_url_unix_socket"
        }
       ],
       "version_added": "2.10",
       "version_added_collection": "ansible.builtin"
      },
      "unredirected_headers": {
       "description": "A list of headers to not attach on a redirected request",
       "elements": "string",
       "env": [
        {
         "name": "ANSIBLE_LOOKUP_URL_UNREDIR_HEADERS"
        }
       ],
       "ini": [
        {
         "key": "unredirected_headers",
         "section": "url_lookup"
        }
       ],
       "type": "list",
       "vars": [
        {
         "name": "ansible_lookup_url_unredir_headers"
        }
       ],
       "version_added": "2.10",
       "version_added_collection": "ansible.builtin"
      },
      "use_gssapi": {
       "default": false,
       "description": [
        "Use GSSAPI handler of requests",
        "As of Ansible 2.11, GSSAPI credentials can be specified with O(username) and O(password)."
       ],
       "env": [
        {
         "name": "ANSIBLE_LOOKUP_URL_USE_GSSAPI"
        }
       ],
       "ini": [
        {
         "key": "use_gssapi",
         "section": "url_lookup"
        }
       ],
       "type": "boolean",
       "vars": [
        {
         "name": "ansible_lookup_url_use_gssapi"
        }
       ],
       "version_added": "2.10",
       "version_added_collection": "ansible.builtin"
      },
      "use_netrc": {
       "default": true,
       "description": [
        "Determining whether to use credentials from ``~/.netrc`` file",
        "By default .netrc is used with Basic authentication headers",
        "When set to False, .netrc credentials are ignored"
       ],
       "env": [
        {
         "name": "ANSIBLE_LOOKUP_URL_USE_NETRC"
        }
       ],
       "ini": [
        {
         "key": "use_netrc",
         "section": "url_lookup"
        }
       ],
       "type": "boolean",
       "vars": [
        {
         "name": "ansible_lookup_url_use_netrc"
        }
       ],
       "version_added": "2.14",
       "version_added_collection": "ansible.builtin"
      },
      "use_proxy": {
       "default": true,
       "description": "Flag to control if the lookup will observe HTTP proxy environment variables when present.",
       "type": "boolean"
      },
      "username": {
       "description": "Username to use for HTTP authentication.",
       "type": "string",
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      },
      "validate_certs": {
       "default": true,
       "description": "Flag to control SSL certificate validation",
       "type": "boolean"
      }
     },
     "short_description": "return contents from URL",
     "version_added": "1.9",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: url lookup splits lines by default\n  ansible.builtin.debug: msg=\"{{item}}\"\n  loop: \"{{ lookup('ansible.builtin.url', 'https://github.com/gremlin.keys', wantlist=True) }}\"\n\n- name: display ip ranges\n  ansible.builtin.debug: msg=\"{{ lookup('ansible.builtin.url', 'https://ip-ranges.amazonaws.com/ip-ranges.json', split_lines=False) }}\"\n\n- name: url lookup using authentication\n  ansible.builtin.debug: msg=\"{{ lookup('ansible.builtin.url', 'https://some.private.site.com/file.txt', username='bob', password='hunter2') }}\"\n\n- name: url lookup using basic authentication\n  ansible.builtin.debug:\n    msg: \"{{ lookup('ansible.builtin.url', 'https://some.private.site.com/file.txt', username='bob', password='hunter2', force_basic_auth='True') }}\"\n\n- name: url lookup using headers\n  ansible.builtin.debug:\n    msg: \"{{ lookup('ansible.builtin.url', 'https://some.private.site.com/api/service', headers={'header1':'value1', 'header2':'value2'} ) }}\"\n",
    "metadata": null,
    "return": {
     "_list": {
      "description": "list of list of lines or content of url(s)",
      "elements": "str",
      "type": "list"
     }
    }
   },
   "ansible.builtin.varnames": {
    "doc": {
     "author": "Ansible Core Team",
     "collection": "ansible.builtin",
     "description": [
      "Retrieves a list of matching Ansible variable names."
     ],
     "filename": "/ansible/plugins/lookup/varnames.py",
     "name": "varnames",
     "options": {
      "_terms": {
       "description": "List of Python regex patterns to search for in variable names.",
       "required": true
      }
     },
     "short_description": "Lookup matching variable names",
     "version_added": "2.8",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: List variables that start with qz_\n  ansible.builtin.debug: msg=\"{{ lookup('ansible.builtin.varnames', '^qz_.+')}}\"\n  vars:\n    qz_1: hello\n    qz_2: world\n    qa_1: \"I won't show\"\n    qz_: \"I won't show either\"\n\n- name: Show all variables\n  ansible.builtin.debug: msg=\"{{ lookup('ansible.builtin.varnames', '.+')}}\"\n\n- name: Show variables with 'hosts' in their names\n  ansible.builtin.debug: msg=\"{{ lookup('ansible.builtin.varnames', 'hosts')}}\"\n\n- name: Find several related variables that end specific way\n  ansible.builtin.debug: msg=\"{{ lookup('ansible.builtin.varnames', '.+_zone$', '.+_location$') }}\"\n\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": [
       "List of the variable names requested."
      ],
      "type": "list"
     }
    }
   },
   "ansible.builtin.vars": {
    "doc": {
     "author": "Ansible Core Team",
     "collection": "ansible.builtin",
     "description": [
      "Retrieves the value of an Ansible variable. Note: Only returns top level variable names."
     ],
     "filename": "/ansible/plugins/lookup/vars.py",
     "name": "vars",
     "options": {
      "_terms": {
       "description": "The variable names to look up.",
       "required": true
      },
      "default": {
       "description": [
        "What to return if a variable is undefined.",
        "If no default is set, it will result in an error if any of the variables is undefined."
       ]
      }
     },
     "short_description": "Lookup templated value of variables",
     "version_added": "2.5",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Show value of 'variablename'\n  ansible.builtin.debug: msg=\"{{ lookup('ansible.builtin.vars', 'variabl' + myvar) }}\"\n  vars:\n    variablename: hello\n    myvar: ename\n\n- name: Show default empty since i dont have 'variablnotename'\n  ansible.builtin.debug: msg=\"{{ lookup('ansible.builtin.vars', 'variabl' + myvar, default='')}}\"\n  vars:\n    variablename: hello\n    myvar: notename\n\n- name: Produce an error since i dont have 'variablnotename'\n  ansible.builtin.debug: msg=\"{{ lookup('ansible.builtin.vars', 'variabl' + myvar)}}\"\n  ignore_errors: True\n  vars:\n    variablename: hello\n    myvar: notename\n\n- name: find several related variables\n  ansible.builtin.debug: msg=\"{{ lookup('ansible.builtin.vars', 'ansible_play_hosts', 'ansible_play_batch', 'ansible_play_hosts_all') }}\"\n\n- name: Access nested variables\n  ansible.builtin.debug: msg=\"{{ lookup('ansible.builtin.vars', 'variabl' + myvar).sub_var }}\"\n  ignore_errors: True\n  vars:\n    variablename:\n        sub_var: 12\n    myvar: ename\n\n- name: alternate way to find some 'prefixed vars' in loop\n  ansible.builtin.debug: msg=\"{{ lookup('ansible.builtin.vars', 'ansible_play_' + item) }}\"\n  loop:\n    - hosts\n    - batch\n    - hosts_all\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": [
       "value of the variables requested."
      ],
      "elements": "raw",
      "type": "list"
     }
    }
   },
   "ns2.col.foo": {
    "doc": {
     "author": "Felix Fontein (@felixfontein)",
     "collection": "ns2.col",
     "description": [
      "This looks up some foo.",
      "Whatever that is."
     ],
     "filename": "ansible_collections/ns2/col/plugins/lookup/foo.py",
     "name": "foo",
     "options": {
      "_terms": {
       "description": "The stuff to look up.",
       "elements": "str",
       "required": true,
       "type": "list"
      },
      "bar": {
       "description": "Foo bar.",
       "type": "string"
      }
     },
     "short_description": "Look up some foo O(bar)",
     "version_added": "1.0.0",
     "version_added_collection": "ns2.col"
    },
    "examples": "\n- name: Look up bar\n  ansible.builtin.debug:\n    msg: \"{{ lookup('ns2.col.foo', 'bar') }}\"\n",
    "metadata": null,
    "return": {
     "_raw": {
      "description": [
       "The resulting stuff."
      ],
      "elements": "str",
      "type": "list"
     }
    }
   }
  },
  "module": {
   "ansible.builtin.add_host": {
    "doc": {
     "attributes": {
      "action": {
       "description": "Indicates this has a corresponding action plugin so some parts of the options can be executed on the controller",
       "support": "full"
      },
      "async": {
       "description": "Supports being used with the C(async) keyword",
       "support": "none"
      },
      "become": {
       "description": "Is usable alongside become keywords",
       "support": "none"
      },
      "bypass_host_loop": {
       "description": [
        "Forces a 'global' task that does not execute per host, this bypasses per host templating and serial, throttle and other loop considerations",
        "Conditionals will work as if C(run_once) is being used, variables used will be from the first available host",
        "This action will not work normally outside of lockstep strategies"
       ],
       "support": "full"
      },
      "bypass_task_loop": {
       "description": "These tasks ignore the C(loop) and C(with_) keywords",
       "support": "none"
      },
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "details": "While this makes no changes to target systems the 'in memory' inventory will still be altered",
       "support": "partial"
      },
      "connection": {
       "description": "Uses the target's configured connection information to execute code on it",
       "support": "none"
      },
      "core": {
       "description": "This is a 'core engine' feature and is not implemented like most task actions, so it is not overridable in any way via the plugin system.",
       "details": "While parts of this action are implemented in core, other parts are still available as normal plugins and can be partially overridden",
       "support": "partial"
      },
      "delegation": {
       "description": "Can be used in conjunction with delegate_to and related keywords",
       "support": "none"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "ignore_conditional": {
       "description": "The action is not subject to conditional execution so it will ignore the C(when:) keyword",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "all",
       "support": "N/A"
      },
      "tags": {
       "description": "Allows for the 'tags' keyword to control the selection of this action for execution",
       "support": "full"
      },
      "until": {
       "description": "Denotes if this action obeys until/retry/poll keywords",
       "support": "full"
      }
     },
     "author": [
      "Ansible Core Team",
      "Seth Vidal (@skvidal)"
     ],
     "collection": "ansible.builtin",
     "description": [
      "Use variables to create new hosts and groups in inventory for use in later plays of the same playbook.",
      "Takes variables so you can define the new hosts more fully.",
      "This module is also supported for Windows targets."
     ],
     "filename": "/ansible/modules/add_host.py",
     "has_action": true,
     "module": "add_host",
     "notes": [
      "The alias O(host) of the parameter O(name) is only available on Ansible 2.4 and newer.",
      "Since Ansible 2.4, the C(inventory_dir) variable is now set to V(None) instead of the 'global inventory source', because you can now have multiple sources.  An example was added that shows how to partially restore the previous behaviour.",
      "Though this module does not change the remote host, we do provide 'changed' status as it can be useful for those trying to track inventory changes.",
      "The hosts added will not bypass the C(--limit) from the command line, so both of those need to be in agreement to make them available as play targets. They are still available from hostvars and for delegation as a normal part of the inventory."
     ],
     "options": {
      "groups": {
       "aliases": [
        "group",
        "groupname"
       ],
       "description": [
        "The groups to add the hostname to."
       ],
       "elements": "str",
       "type": "list"
      },
      "name": {
       "aliases": [
        "host",
        "hostname"
       ],
       "description": [
        "The hostname/ip of the host to add to the inventory, can include a colon and a port number."
       ],
       "required": true,
       "type": "str"
      }
     },
     "seealso": [
      {
       "module": "ansible.builtin.group_by"
      }
     ],
     "short_description": "Add a host (and alternatively a group) to the ansible-playbook in-memory inventory",
     "version_added": "0.9",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Add host to group 'just_created' with variable foo=42\n  ansible.builtin.add_host:\n    name: '{{ ip_from_ec2 }}'\n    groups: just_created\n    foo: 42\n\n- name: Add host to multiple groups\n  ansible.builtin.add_host:\n    hostname: '{{ new_ip }}'\n    groups:\n    - group1\n    - group2\n\n- name: Add a host with a non-standard port local to your machines\n  ansible.builtin.add_host:\n    name: '{{ new_ip }}:{{ new_port }}'\n\n- name: Add a host alias that we reach through a tunnel (Ansible 1.9 and older)\n  ansible.builtin.add_host:\n    hostname: '{{ new_ip }}'\n    ansible_ssh_host: '{{ inventory_hostname }}'\n    ansible_ssh_port: '{{ new_port }}'\n\n- name: Add a host alias that we reach through a tunnel (Ansible 2.0 and newer)\n  ansible.builtin.add_host:\n    hostname: '{{ new_ip }}'\n    ansible_host: '{{ inventory_hostname }}'\n    ansible_port: '{{ new_port }}'\n\n- name: Ensure inventory vars are set to the same value as the inventory_hostname has (close to pre Ansible 2.4 behaviour)\n  ansible.builtin.add_host:\n    hostname: charlie\n    inventory_dir: '{{ inventory_dir }}'\n\n- name: Add all hosts running this playbook to the done group\n  ansible.builtin.add_host:\n    name: '{{ item }}'\n    groups: done\n  loop: \"{{ ansible_play_hosts }}\"\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.apt": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "full"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "debian",
       "support": "N/A"
      }
     },
     "author": "Matthew Williams (@mgwilliams)",
     "collection": "ansible.builtin",
     "description": [
      "Manages I(apt) packages (such as for Debian/Ubuntu)."
     ],
     "filename": "/ansible/modules/apt.py",
     "has_action": false,
     "module": "apt",
     "notes": [
      "Three of the upgrade modes (V(full), V(safe) and its alias V(true)) required C(aptitude) up to 2.3, since 2.4 C(apt-get) is used as a fall-back.",
      "In most cases, packages installed with apt will start newly installed services by default. Most distributions have mechanisms to avoid this. For example when installing Postgresql-9.5 in Debian 9, creating an executable shell script (/usr/sbin/policy-rc.d) that throws a return code of 101 will stop Postgresql 9.5 starting up after install. Remove the file or  its execute permission afterward.",
      "The apt-get commandline supports implicit regex matches here but we do not because it can let typos through easier (If you typo C(foo) as C(fo) apt-get would install packages that have \"fo\" in their name with a warning and a prompt for the user. Since we don't have warnings and prompts before installing, we disallow this.Use an explicit fnmatch pattern if you want wildcarding)",
      "When used with a C(loop:) each package will be processed individually, it is much more efficient to pass the list directly to the O(name) option.",
      "When O(default_release) is used, an implicit priority of 990 is used. This is the same behavior as C(apt-get -t).",
      "When an exact version is specified, an implicit priority of 1001 is used.",
      "If the interpreter can't import ``python-apt``/``python3-apt`` the module will check for it in system-owned interpreters as well. If the dependency can't be found, the module will attempt to install it. If the dependency is found or installed, the module will be respawned under the correct interpreter."
     ],
     "options": {
      "allow_change_held_packages": {
       "default": "no",
       "description": [
        "Allows changing the version of a package which is on the apt hold list"
       ],
       "type": "bool",
       "version_added": "2.13",
       "version_added_collection": "ansible.builtin"
      },
      "allow_downgrade": {
       "aliases": [
        "allow-downgrade",
        "allow_downgrades",
        "allow-downgrades"
       ],
       "default": "no",
       "description": [
        "Corresponds to the C(--allow-downgrades) option for I(apt).",
        "This option enables the named package and version to replace an already installed higher version of that package.",
        "Note that setting O(allow_downgrade=true) can make this module behave in a non-idempotent way.",
        "(The task could end up with a set of packages that does not match the complete list of specified packages to install).",
        "O(allow_downgrade) is only supported by C(apt) and will be ignored if C(aptitude) is detected or specified."
       ],
       "type": "bool",
       "version_added": "2.12",
       "version_added_collection": "ansible.builtin"
      },
      "allow_unauthenticated": {
       "aliases": [
        "allow-unauthenticated"
       ],
       "default": "no",
       "description": [
        "Ignore if packages cannot be authenticated. This is useful for bootstrapping environments that manage their own apt-key setup.",
        "O(allow_unauthenticated) is only supported with O(state): V(install)/V(present)"
       ],
       "type": "bool",
       "version_added": "2.1",
       "version_added_collection": "ansible.builtin"
      },
      "autoclean": {
       "default": "no",
       "description": [
        "If V(true), cleans the local repository of retrieved package files that can no longer be downloaded."
       ],
       "type": "bool",
       "version_added": "2.4",
       "version_added_collection": "ansible.builtin"
      },
      "autoremove": {
       "default": "no",
       "description": [
        "If V(true), remove unused dependency packages for all module states except V(build-dep). It can also be used as the only option.",
        "Previous to version 2.4, autoclean was also an alias for autoremove, now it is its own separate command. See documentation for further information."
       ],
       "type": "bool",
       "version_added": "2.1",
       "version_added_collection": "ansible.builtin"
      },
      "cache_valid_time": {
       "default": 0,
       "description": [
        "Update the apt cache if it is older than the O(cache_valid_time). This option is set in seconds.",
        "As of Ansible 2.4, if explicitly set, this sets O(update_cache=yes)."
       ],
       "type": "int"
      },
      "clean": {
       "default": "no",
       "description": [
        "Run the equivalent of C(apt-get clean) to clear out the local repository of retrieved package files. It removes everything but the lock file from /var/cache/apt/archives/ and /var/cache/apt/archives/partial/.",
        "Can be run as part of the package installation (clean runs before install) or as a separate step."
       ],
       "type": "bool",
       "version_added": "2.13",
       "version_added_collection": "ansible.builtin"
      },
      "deb": {
       "description": [
        "Path to a .deb package on the remote machine.",
        "If :// in the path, ansible will attempt to download deb before installing. (Version added 2.1)",
        "Requires the C(xz-utils) package to extract the control file of the deb package to install."
       ],
       "required": false,
       "type": "path",
       "version_added": "1.6",
       "version_added_collection": "ansible.builtin"
      },
      "default_release": {
       "aliases": [
        "default-release"
       ],
       "description": [
        "Corresponds to the C(-t) option for I(apt) and sets pin priorities"
       ],
       "type": "str"
      },
      "dpkg_options": {
       "default": "force-confdef,force-confold",
       "description": [
        "Add dpkg options to apt command. Defaults to '-o \"Dpkg::Options::=--force-confdef\" -o \"Dpkg::Options::=--force-confold\"'",
        "Options should be supplied as comma separated list"
       ],
       "type": "str"
      },
      "fail_on_autoremove": {
       "default": "no",
       "description": [
        "Corresponds to the C(--no-remove) option for C(apt).",
        "If V(true), it is ensured that no packages will be removed or the task will fail.",
        "O(fail_on_autoremove) is only supported with O(state) except V(absent).",
        "O(fail_on_autoremove) is only supported by C(apt) and will be ignored if C(aptitude) is detected or specified."
       ],
       "type": "bool",
       "version_added": "2.11",
       "version_added_collection": "ansible.builtin"
      },
      "force": {
       "default": "no",
       "description": [
        "Corresponds to the C(--force-yes) to I(apt-get) and implies O(allow_unauthenticated=yes) and O(allow_downgrade=yes)",
        "This option will disable checking both the packages' signatures and the certificates of the web servers they are downloaded from.",
        "This option *is not* the equivalent of passing the C(-f) flag to I(apt-get) on the command line",
        "**This is a destructive operation with the potential to destroy your system, and it should almost never be used.** Please also see C(man apt-get) for more information."
       ],
       "type": "bool"
      },
      "force_apt_get": {
       "default": "no",
       "description": [
        "Force usage of apt-get instead of aptitude"
       ],
       "type": "bool",
       "version_added": "2.4",
       "version_added_collection": "ansible.builtin"
      },
      "install_recommends": {
       "aliases": [
        "install-recommends"
       ],
       "description": [
        "Corresponds to the C(--no-install-recommends) option for I(apt). V(true) installs recommended packages.  V(false) does not install recommended packages. By default, Ansible will use the same defaults as the operating system. Suggested packages are never installed."
       ],
       "type": "bool"
      },
      "lock_timeout": {
       "default": 60,
       "description": [
        "How many seconds will this action wait to acquire a lock on the apt db.",
        "Sometimes there is a transitory lock and this will retry at least until timeout is hit."
       ],
       "type": "int",
       "version_added": "2.12",
       "version_added_collection": "ansible.builtin"
      },
      "name": {
       "aliases": [
        "package",
        "pkg"
       ],
       "description": [
        "A list of package names, like V(foo), or package specifier with version, like V(foo=1.0) or V(foo>=1.0). Name wildcards (fnmatch) like V(apt*) and version wildcards like V(foo=1.0*) are also supported."
       ],
       "elements": "str",
       "type": "list"
      },
      "only_upgrade": {
       "default": "no",
       "description": [
        "Only upgrade a package if it is already installed."
       ],
       "type": "bool",
       "version_added": "2.1",
       "version_added_collection": "ansible.builtin"
      },
      "policy_rc_d": {
       "default": null,
       "description": [
        "Force the exit code of /usr/sbin/policy-rc.d.",
        "For example, if I(policy_rc_d=101) the installed package will not trigger a service start.",
        "If /usr/sbin/policy-rc.d already exists, it is backed up and restored after the package installation.",
        "If V(null), the /usr/sbin/policy-rc.d isn't created/changed."
       ],
       "type": "int",
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      },
      "purge": {
       "default": "no",
       "description": [
        "Will force purging of configuration files if O(state=absent) or O(autoremove=yes)."
       ],
       "type": "bool"
      },
      "state": {
       "choices": [
        "absent",
        "build-dep",
        "latest",
        "present",
        "fixed"
       ],
       "default": "present",
       "description": [
        "Indicates the desired package state. V(latest) ensures that the latest version is installed. V(build-dep) ensures the package build dependencies are installed. V(fixed) attempt to correct a system with broken dependencies in place."
       ],
       "type": "str"
      },
      "update_cache": {
       "aliases": [
        "update-cache"
       ],
       "description": [
        "Run the equivalent of C(apt-get update) before the operation. Can be run as part of the package installation or as a separate step.",
        "Default is not to update the cache."
       ],
       "type": "bool"
      },
      "update_cache_retries": {
       "default": 5,
       "description": [
        "Amount of retries if the cache update fails. Also see O(update_cache_retry_max_delay)."
       ],
       "type": "int",
       "version_added": "2.10",
       "version_added_collection": "ansible.builtin"
      },
      "update_cache_retry_max_delay": {
       "default": 12,
       "description": [
        "Use an exponential backoff delay for each retry (see O(update_cache_retries)) up to this max delay in seconds."
       ],
       "type": "int",
       "version_added": "2.10",
       "version_added_collection": "ansible.builtin"
      },
      "upgrade": {
       "choices": [
        "dist",
        "full",
        "no",
        "safe",
        "yes"
       ],
       "default": "no",
       "description": [
        "If yes or safe, performs an aptitude safe-upgrade.",
        "If full, performs an aptitude full-upgrade.",
        "If dist, performs an apt-get dist-upgrade.",
        "Note: This does not upgrade a specific package, use state=latest for that.",
        "Note: Since 2.4, apt-get is used as a fall-back if aptitude is not present."
       ],
       "type": "str",
       "version_added": "1.1",
       "version_added_collection": "ansible.builtin"
      }
     },
     "requirements": [
      "python-apt (python 2)",
      "python3-apt (python 3)",
      "aptitude (before 2.4)"
     ],
     "short_description": "Manages apt-packages",
     "version_added": "0.0.2",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Install apache httpd  (state=present is optional)\n  ansible.builtin.apt:\n    name: apache2\n    state: present\n\n- name: Update repositories cache and install \"foo\" package\n  ansible.builtin.apt:\n    name: foo\n    update_cache: yes\n\n- name: Remove \"foo\" package\n  ansible.builtin.apt:\n    name: foo\n    state: absent\n\n- name: Install the package \"foo\"\n  ansible.builtin.apt:\n    name: foo\n\n- name: Install a list of packages\n  ansible.builtin.apt:\n    pkg:\n    - foo\n    - foo-tools\n\n- name: Install the version '1.00' of package \"foo\"\n  ansible.builtin.apt:\n    name: foo=1.00\n\n- name: Update the repository cache and update package \"nginx\" to latest version using default release squeeze-backport\n  ansible.builtin.apt:\n    name: nginx\n    state: latest\n    default_release: squeeze-backports\n    update_cache: yes\n\n- name: Install the version '1.18.0' of package \"nginx\" and allow potential downgrades\n  ansible.builtin.apt:\n    name: nginx=1.18.0\n    state: present\n    allow_downgrade: yes\n\n- name: Install zfsutils-linux with ensuring conflicted packages (e.g. zfs-fuse) will not be removed.\n  ansible.builtin.apt:\n    name: zfsutils-linux\n    state: latest\n    fail_on_autoremove: yes\n\n- name: Install latest version of \"openjdk-6-jdk\" ignoring \"install-recommends\"\n  ansible.builtin.apt:\n    name: openjdk-6-jdk\n    state: latest\n    install_recommends: no\n\n- name: Update all packages to their latest version\n  ansible.builtin.apt:\n    name: \"*\"\n    state: latest\n\n- name: Upgrade the OS (apt-get dist-upgrade)\n  ansible.builtin.apt:\n    upgrade: dist\n\n- name: Run the equivalent of \"apt-get update\" as a separate step\n  ansible.builtin.apt:\n    update_cache: yes\n\n- name: Only run \"update_cache=yes\" if the last one is more than 3600 seconds ago\n  ansible.builtin.apt:\n    update_cache: yes\n    cache_valid_time: 3600\n\n- name: Pass options to dpkg on run\n  ansible.builtin.apt:\n    upgrade: dist\n    update_cache: yes\n    dpkg_options: 'force-confold,force-confdef'\n\n- name: Install a .deb package\n  ansible.builtin.apt:\n    deb: /tmp/mypackage.deb\n\n- name: Install the build dependencies for package \"foo\"\n  ansible.builtin.apt:\n    pkg: foo\n    state: build-dep\n\n- name: Install a .deb package from the internet\n  ansible.builtin.apt:\n    deb: https://example.com/python-ppq_0.1-1_all.deb\n\n- name: Remove useless packages from the cache\n  ansible.builtin.apt:\n    autoclean: yes\n\n- name: Remove dependencies that are no longer required\n  ansible.builtin.apt:\n    autoremove: yes\n\n- name: Remove dependencies that are no longer required and purge their configuration files\n  ansible.builtin.apt:\n    autoremove: yes\n    purge: true\n\n- name: Run the equivalent of \"apt-get clean\" as a separate step\n  ansible.builtin.apt:\n    clean: yes\n",
    "metadata": null,
    "return": {
     "cache_update_time": {
      "description": "time of the last cache update (0 if unknown)",
      "returned": "success, in some cases",
      "sample": 1425828348000,
      "type": "int"
     },
     "cache_updated": {
      "description": "if the cache was updated or not",
      "returned": "success, in some cases",
      "sample": true,
      "type": "bool"
     },
     "stderr": {
      "description": "error output from apt",
      "returned": "success, when needed",
      "sample": "AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 127.0.1.1. Set the 'ServerName' directive globally to ...",
      "type": "str"
     },
     "stdout": {
      "description": "output from apt",
      "returned": "success, when needed",
      "sample": "Reading package lists...\nBuilding dependency tree...\nReading state information...\nThe following extra packages will be installed:\n  apache2-bin ...",
      "type": "str"
     }
    }
   },
   "ansible.builtin.apt_key": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "debian",
       "support": "N/A"
      }
     },
     "author": [
      "Jayson Vantuyl (@jvantuyl)"
     ],
     "collection": "ansible.builtin",
     "description": [
      "Add or remove an I(apt) key, optionally downloading it."
     ],
     "filename": "/ansible/modules/apt_key.py",
     "has_action": false,
     "module": "apt_key",
     "notes": [
      "The apt-key command used by this module has been deprecated. See the L(Debian wiki,https://wiki.debian.org/DebianRepository/UseThirdParty) for details. This module is kept for backwards compatibility for systems that still use apt-key as the main way to manage apt repository keys.",
      "As a sanity check, downloaded key id must match the one specified.",
      "Use full fingerprint (40 characters) key ids to avoid key collisions. To generate a full-fingerprint imported key: C(apt-key adv --list-public-keys --with-fingerprint --with-colons).",
      "If you specify both the key id and the URL with O(state=present), the task can verify or add the key as needed.",
      "Adding a new key requires an apt cache update (e.g. using the M(ansible.builtin.apt) module's update_cache option)."
     ],
     "options": {
      "data": {
       "description": [
        "The keyfile contents to add to the keyring."
       ],
       "type": "str"
      },
      "file": {
       "description": [
        "The path to a keyfile on the remote server to add to the keyring."
       ],
       "type": "path"
      },
      "id": {
       "description": [
        "The identifier of the key.",
        "Including this allows check mode to correctly report the changed state.",
        "If specifying a subkey's id be aware that apt-key does not understand how to remove keys via a subkey id.  Specify the primary key's id instead.",
        "This parameter is required when O(state) is set to V(absent)."
       ],
       "type": "str"
      },
      "keyring": {
       "description": [
        "The full path to specific keyring file in C(/etc/apt/trusted.gpg.d/)."
       ],
       "type": "path",
       "version_added": "1.3",
       "version_added_collection": "ansible.builtin"
      },
      "keyserver": {
       "description": [
        "The keyserver to retrieve key from."
       ],
       "type": "str",
       "version_added": "1.6",
       "version_added_collection": "ansible.builtin"
      },
      "state": {
       "choices": [
        "absent",
        "present"
       ],
       "default": "present",
       "description": [
        "Ensures that the key is present (added) or absent (revoked)."
       ],
       "type": "str"
      },
      "url": {
       "description": [
        "The URL to retrieve key from."
       ],
       "type": "str"
      },
      "validate_certs": {
       "default": "yes",
       "description": [
        "If V(false), SSL certificates for the target url will not be validated. This should only be used on personally controlled sites using self-signed certificates."
       ],
       "type": "bool"
      }
     },
     "requirements": [
      "gpg"
     ],
     "seealso": [
      {
       "module": "ansible.builtin.deb822_repository"
      }
     ],
     "short_description": "Add or remove an apt key",
     "version_added": "1.0",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: One way to avoid apt_key once it is removed from your distro, armored keys should use .asc extension, binary should use .gpg\n  block:\n    - name: somerepo | no apt key\n      ansible.builtin.get_url:\n        url: https://keyserver.ubuntu.com/pks/lookup?op=get&search=0x36a1d7869245c8950f966e92d8576a8ba88d21e9\n        dest: /etc/apt/keyrings/myrepo.asc\n        checksum: sha256:bb42f0db45d46bab5f9ec619e1a47360b94c27142e57aa71f7050d08672309e0\n\n    - name: somerepo | apt source\n      ansible.builtin.apt_repository:\n        repo: \"deb [arch=amd64 signed-by=/etc/apt/keyrings/myrepo.asc] https://download.example.com/linux/ubuntu {{ ansible_distribution_release }} stable\"\n        state: present\n\n- name: Add an apt key by id from a keyserver\n  ansible.builtin.apt_key:\n    keyserver: keyserver.ubuntu.com\n    id: 36A1D7869245C8950F966E92D8576A8BA88D21E9\n\n- name: Add an Apt signing key, uses whichever key is at the URL\n  ansible.builtin.apt_key:\n    url: https://ftp-master.debian.org/keys/archive-key-6.0.asc\n    state: present\n\n- name: Add an Apt signing key, will not download if present\n  ansible.builtin.apt_key:\n    id: 9FED2BCBDCD29CDF762678CBAED4B06F473041FA\n    url: https://ftp-master.debian.org/keys/archive-key-6.0.asc\n    state: present\n\n- name: Remove a Apt specific signing key, leading 0x is valid\n  ansible.builtin.apt_key:\n    id: 0x9FED2BCBDCD29CDF762678CBAED4B06F473041FA\n    state: absent\n\n# Use armored file since utf-8 string is expected. Must be of \"PGP PUBLIC KEY BLOCK\" type.\n- name: Add a key from a file on the Ansible server\n  ansible.builtin.apt_key:\n    data: \"{{ lookup('ansible.builtin.file', 'apt.asc') }}\"\n    state: present\n\n- name: Add an Apt signing key to a specific keyring file\n  ansible.builtin.apt_key:\n    id: 9FED2BCBDCD29CDF762678CBAED4B06F473041FA\n    url: https://ftp-master.debian.org/keys/archive-key-6.0.asc\n    keyring: /etc/apt/trusted.gpg.d/debian.gpg\n\n- name: Add Apt signing key on remote server to keyring\n  ansible.builtin.apt_key:\n    id: 9FED2BCBDCD29CDF762678CBAED4B06F473041FA\n    file: /tmp/apt.gpg\n    state: present\n",
    "metadata": null,
    "return": {
     "after": {
      "description": "List of apt key ids or fingerprints after any modification",
      "returned": "on change",
      "sample": [
       "D8576A8BA88D21E9",
       "3B4FE6ACC0B21F32",
       "D94AA3F0EFE21092",
       "871920D1991BC93C"
      ],
      "type": "list"
     },
     "before": {
      "description": "List of apt key ids or fingprints before any modifications",
      "returned": "always",
      "sample": [
       "3B4FE6ACC0B21F32",
       "D94AA3F0EFE21092",
       "871920D1991BC93C"
      ],
      "type": "list"
     },
     "fp": {
      "description": "Fingerprint of the key to import",
      "returned": "always",
      "sample": "D8576A8BA88D21E9",
      "type": "str"
     },
     "id": {
      "description": "key id from source",
      "returned": "always",
      "sample": "36A1D7869245C8950F966E92D8576A8BA88D21E9",
      "type": "str"
     },
     "key_id": {
      "description": "calculated key id, it should be same as 'id', but can be different",
      "returned": "always",
      "sample": "36A1D7869245C8950F966E92D8576A8BA88D21E9",
      "type": "str"
     },
     "short_id": {
      "description": "calculated short key id",
      "returned": "always",
      "sample": "A88D21E9",
      "type": "str"
     }
    }
   },
   "ansible.builtin.apt_repository": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "full"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "debian",
       "support": "N/A"
      }
     },
     "author": [
      "Alexander Saltanov (@sashka)"
     ],
     "collection": "ansible.builtin",
     "description": [
      "Add or remove an APT repositories in Ubuntu and Debian."
     ],
     "filename": "/ansible/modules/apt_repository.py",
     "has_action": false,
     "module": "apt_repository",
     "notes": [
      "This module supports Debian Squeeze (version 6) as well as its successors and derivatives."
     ],
     "options": {
      "codename": {
       "description": [
        "Override the distribution codename to use for PPA repositories. Should usually only be set when working with a PPA on a non-Ubuntu target (for example, Debian or Mint)."
       ],
       "type": "str",
       "version_added": "2.3",
       "version_added_collection": "ansible.builtin"
      },
      "filename": {
       "description": [
        "Sets the name of the source list file in sources.list.d. Defaults to a file name based on the repository source url. The .list extension will be automatically added."
       ],
       "type": "str",
       "version_added": "2.1",
       "version_added_collection": "ansible.builtin"
      },
      "install_python_apt": {
       "default": true,
       "description": [
        "Whether to automatically try to install the Python apt library or not, if it is not already installed. Without this library, the module does not work.",
        "Runs C(apt-get install python-apt) for Python 2, and C(apt-get install python3-apt) for Python 3.",
        "Only works with the system Python 2 or Python 3. If you are using a Python on the remote that is not the system Python, set O(install_python_apt=false) and ensure that the Python apt library for your Python version is installed some other way."
       ],
       "type": "bool"
      },
      "mode": {
       "description": [
        "The octal mode for newly created files in sources.list.d.",
        "Default is what system uses (probably 0644)."
       ],
       "type": "raw",
       "version_added": "1.6",
       "version_added_collection": "ansible.builtin"
      },
      "repo": {
       "description": [
        "A source string for the repository."
       ],
       "required": true,
       "type": "str"
      },
      "state": {
       "choices": [
        "absent",
        "present"
       ],
       "default": "present",
       "description": [
        "A source string state."
       ],
       "type": "str"
      },
      "update_cache": {
       "aliases": [
        "update-cache"
       ],
       "default": "yes",
       "description": [
        "Run the equivalent of C(apt-get update) when a change occurs.  Cache updates are run after making changes."
       ],
       "type": "bool"
      },
      "update_cache_retries": {
       "default": 5,
       "description": [
        "Amount of retries if the cache update fails. Also see O(update_cache_retry_max_delay)."
       ],
       "type": "int",
       "version_added": "2.10",
       "version_added_collection": "ansible.builtin"
      },
      "update_cache_retry_max_delay": {
       "default": 12,
       "description": [
        "Use an exponential backoff delay for each retry (see O(update_cache_retries)) up to this max delay in seconds."
       ],
       "type": "int",
       "version_added": "2.10",
       "version_added_collection": "ansible.builtin"
      },
      "validate_certs": {
       "default": "yes",
       "description": [
        "If V(false), SSL certificates for the target repo will not be validated. This should only be used on personally controlled sites using self-signed certificates."
       ],
       "type": "bool",
       "version_added": "1.8",
       "version_added_collection": "ansible.builtin"
      }
     },
     "requirements": [
      "python-apt (python 2)",
      "python3-apt (python 3)",
      "apt-key or gpg"
     ],
     "seealso": [
      {
       "module": "ansible.builtin.deb822_repository"
      }
     ],
     "short_description": "Add and remove APT repositories",
     "version_added": "0.7",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Add specified repository into sources list\n  ansible.builtin.apt_repository:\n    repo: deb http://archive.canonical.com/ubuntu hardy partner\n    state: present\n\n- name: Add specified repository into sources list using specified filename\n  ansible.builtin.apt_repository:\n    repo: deb http://dl.google.com/linux/chrome/deb/ stable main\n    state: present\n    filename: google-chrome\n\n- name: Add source repository into sources list\n  ansible.builtin.apt_repository:\n    repo: deb-src http://archive.canonical.com/ubuntu hardy partner\n    state: present\n\n- name: Remove specified repository from sources list\n  ansible.builtin.apt_repository:\n    repo: deb http://archive.canonical.com/ubuntu hardy partner\n    state: absent\n\n- name: Add nginx stable repository from PPA and install its signing key on Ubuntu target\n  ansible.builtin.apt_repository:\n    repo: ppa:nginx/stable\n\n- name: Add nginx stable repository from PPA and install its signing key on Debian target\n  ansible.builtin.apt_repository:\n    repo: 'ppa:nginx/stable'\n    codename: trusty\n\n- name: One way to avoid apt_key once it is removed from your distro\n  block:\n    - name: somerepo |no apt key\n      ansible.builtin.get_url:\n        url: https://download.example.com/linux/ubuntu/gpg\n        dest: /etc/apt/keyrings/somerepo.asc\n\n    - name: somerepo | apt source\n      ansible.builtin.apt_repository:\n        repo: \"deb [arch=amd64 signed-by=/etc/apt/keyrings/myrepo.asc] https://download.example.com/linux/ubuntu {{ ansible_distribution_release }} stable\"\n        state: present\n",
    "metadata": null,
    "return": {
     "repo": {
      "description": "A source string for the repository",
      "returned": "always",
      "sample": "deb https://artifacts.elastic.co/packages/6.x/apt stable main",
      "type": "str"
     },
     "sources_added": {
      "description": "List of sources added",
      "returned": "success, sources were added",
      "sample": [
       "/etc/apt/sources.list.d/artifacts_elastic_co_packages_6_x_apt.list"
      ],
      "type": "list",
      "version_added": "2.15",
      "version_added_collection": "ansible.builtin"
     },
     "sources_removed": {
      "description": "List of sources removed",
      "returned": "success, sources were removed",
      "sample": [
       "/etc/apt/sources.list.d/artifacts_elastic_co_packages_6_x_apt.list"
      ],
      "type": "list",
      "version_added": "2.15",
      "version_added_collection": "ansible.builtin"
     }
    }
   },
   "ansible.builtin.assemble": {
    "doc": {
     "attributes": {
      "action": {
       "description": "Indicates this has a corresponding action plugin so some parts of the options can be executed on the controller",
       "support": "full"
      },
      "async": {
       "description": "Supports being used with the C(async) keyword",
       "support": "none"
      },
      "bypass_host_loop": {
       "description": [
        "Forces a 'global' task that does not execute per host, this bypasses per host templating and serial, throttle and other loop considerations",
        "Conditionals will work as if C(run_once) is being used, variables used will be from the first available host",
        "This action will not work normally outside of lockstep strategies"
       ],
       "support": "none"
      },
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "none"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "full"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "N/A"
      },
      "safe_file_operations": {
       "description": "Uses Ansible's strict file operation functions to ensure proper permissions and avoid data corruption",
       "support": "full"
      },
      "vault": {
       "description": "Can automatically decrypt Ansible vaulted files",
       "support": "full",
       "version_added": "2.2",
       "version_added_collection": "ansible.builtin"
      }
     },
     "author": [
      "Stephen Fromm (@sfromm)"
     ],
     "collection": "ansible.builtin",
     "description": [
      "Assembles a configuration file from fragments.",
      "Often a particular program will take a single configuration file and does not support a C(conf.d) style structure where it is easy to build up the configuration from multiple sources. M(ansible.builtin.assemble) will take a directory of files that can be local or have already been transferred to the system, and concatenate them together to produce a destination file.",
      "Files are assembled in string sorting order.",
      "Puppet calls this idea I(fragments)."
     ],
     "filename": "/ansible/modules/assemble.py",
     "has_action": true,
     "module": "assemble",
     "options": {
      "attributes": {
       "aliases": [
        "attr"
       ],
       "description": [
        "The attributes the resulting filesystem object should have.",
        "To get supported flags look at the man page for I(chattr) on the target system.",
        "This string should contain the attributes in the same order as the one displayed by I(lsattr).",
        "The C(=) operator is assumed as default, otherwise C(+) or C(-) operators need to be included in the string."
       ],
       "type": "str",
       "version_added": "2.3",
       "version_added_collection": "ansible.builtin"
      },
      "backup": {
       "default": false,
       "description": [
        "Create a backup file (if V(true)), including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly."
       ],
       "type": "bool"
      },
      "decrypt": {
       "default": true,
       "description": [
        "This option controls the auto-decryption of source files using vault."
       ],
       "type": "bool",
       "version_added": "2.4",
       "version_added_collection": "ansible.builtin"
      },
      "delimiter": {
       "description": [
        "A delimiter to separate the file contents."
       ],
       "type": "str",
       "version_added": "1.4",
       "version_added_collection": "ansible.builtin"
      },
      "dest": {
       "description": [
        "A file to create using the concatenation of all of the source files."
       ],
       "required": true,
       "type": "path"
      },
      "group": {
       "description": [
        "Name of the group that should own the filesystem object, as would be fed to I(chown).",
        "When left unspecified, it uses the current group of the current user unless you are root, in which case it can preserve the previous ownership."
       ],
       "type": "str"
      },
      "ignore_hidden": {
       "default": false,
       "description": [
        "A boolean that controls if files that start with a '.' will be included or not."
       ],
       "type": "bool",
       "version_added": "2.0",
       "version_added_collection": "ansible.builtin"
      },
      "mode": {
       "description": [
        "The permissions the resulting filesystem object should have.",
        "For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must give Ansible enough information to parse them correctly. For consistent results, quote octal numbers (for example, V('644') or V('1777')) so Ansible receives a string and can do its own conversion from string into number. Adding a leading zero (for example, V(0755)) works sometimes, but can fail in loops and some other circumstances.",
        "Giving Ansible a number without following either of these rules will end up with a decimal number which will have unexpected results.",
        "As of Ansible 1.8, the mode may be specified as a symbolic mode (for example, V(u+rwx) or V(u=rw,g=r,o=r)).",
        "If O(mode) is not specified and the destination filesystem object B(does not) exist, the default C(umask) on the system will be used when setting the mode for the newly created filesystem object.",
        "If O(mode) is not specified and the destination filesystem object B(does) exist, the mode of the existing filesystem object will be used.",
        "Specifying O(mode) is the best way to ensure filesystem objects are created with the correct permissions. See CVE-2020-1736 for further details."
       ],
       "type": "raw"
      },
      "owner": {
       "description": [
        "Name of the user that should own the filesystem object, as would be fed to I(chown).",
        "When left unspecified, it uses the current user unless you are root, in which case it can preserve the previous ownership.",
        "Specifying a numeric username will be assumed to be a user ID and not a username. Avoid numeric usernames to avoid this confusion."
       ],
       "type": "str"
      },
      "regexp": {
       "description": [
        "Assemble files only if the given regular expression matches the filename.",
        "If not set, all files are assembled.",
        "Every V(\\\\) (backslash) must be escaped as V(\\\\\\\\) to comply to YAML syntax.",
        "Uses L(Python regular expressions,https://docs.python.org/3/library/re.html)."
       ],
       "type": "str"
      },
      "remote_src": {
       "default": true,
       "description": [
        "If V(false), it will search for src at originating/master machine.",
        "If V(true), it will go to the remote/target machine for the src."
       ],
       "type": "bool",
       "version_added": "1.4",
       "version_added_collection": "ansible.builtin"
      },
      "selevel": {
       "description": [
        "The level part of the SELinux filesystem object context.",
        "This is the MLS/MCS attribute, sometimes known as the C(range).",
        "When set to V(_default), it will use the C(level) portion of the policy if available."
       ],
       "type": "str"
      },
      "serole": {
       "description": [
        "The role part of the SELinux filesystem object context.",
        "When set to V(_default), it will use the C(role) portion of the policy if available."
       ],
       "type": "str"
      },
      "setype": {
       "description": [
        "The type part of the SELinux filesystem object context.",
        "When set to V(_default), it will use the C(type) portion of the policy if available."
       ],
       "type": "str"
      },
      "seuser": {
       "description": [
        "The user part of the SELinux filesystem object context.",
        "By default it uses the V(system) policy, where applicable.",
        "When set to V(_default), it will use the C(user) portion of the policy if available."
       ],
       "type": "str"
      },
      "src": {
       "description": [
        "An already existing directory full of source files."
       ],
       "required": true,
       "type": "path"
      },
      "unsafe_writes": {
       "default": false,
       "description": [
        "Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target filesystem object.",
        "By default this module uses atomic operations to prevent data corruption or inconsistent reads from the target filesystem objects, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted filesystem objects, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.",
        "This option allows Ansible to fall back to unsafe methods of updating filesystem objects when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes).",
        "IMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption."
       ],
       "type": "bool",
       "version_added": "2.2",
       "version_added_collection": "ansible.builtin"
      },
      "validate": {
       "description": [
        "The validation command to run before copying into place.",
        "The path to the file to validate is passed in via '%s' which must be present as in the sshd example below.",
        "The command is passed securely so shell features like expansion and pipes won't work."
       ],
       "type": "str",
       "version_added": "2.0",
       "version_added_collection": "ansible.builtin"
      }
     },
     "seealso": [
      {
       "module": "ansible.builtin.copy"
      },
      {
       "module": "ansible.builtin.template"
      },
      {
       "module": "ansible.windows.win_copy"
      }
     ],
     "short_description": "Assemble configuration files from fragments",
     "version_added": "0.5",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Assemble from fragments from a directory\n  ansible.builtin.assemble:\n    src: /etc/someapp/fragments\n    dest: /etc/someapp/someapp.conf\n\n- name: Insert the provided delimiter between fragments\n  ansible.builtin.assemble:\n    src: /etc/someapp/fragments\n    dest: /etc/someapp/someapp.conf\n    delimiter: '### START FRAGMENT ###'\n\n- name: Assemble a new \"sshd_config\" file into place, after passing validation with sshd\n  ansible.builtin.assemble:\n    src: /etc/ssh/conf.d/\n    dest: /etc/ssh/sshd_config\n    validate: /usr/sbin/sshd -t -f %s\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.assert": {
    "doc": {
     "attributes": {
      "action": {
       "description": "Indicates this has a corresponding action plugin so some parts of the options can be executed on the controller",
       "support": "full"
      },
      "async": {
       "description": "Supports being used with the C(async) keyword",
       "support": "none"
      },
      "become": {
       "description": "Is usable alongside become keywords",
       "support": "none"
      },
      "bypass_host_loop": {
       "description": [
        "Forces a 'global' task that does not execute per host, this bypasses per host templating and serial, throttle and other loop considerations",
        "Conditionals will work as if C(run_once) is being used, variables used will be from the first available host",
        "This action will not work normally outside of lockstep strategies"
       ],
       "support": "none"
      },
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "connection": {
       "description": "Uses the target's configured connection information to execute code on it",
       "support": "none"
      },
      "delegation": {
       "description": "Can be used in conjunction with delegate_to and related keywords",
       "details": "Aside from C(register) and/or in combination with C(delegate_facts), it has little effect.",
       "support": "none"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "all",
       "support": "N/A"
      }
     },
     "author": [
      "Ansible Core Team",
      "Michael DeHaan"
     ],
     "collection": "ansible.builtin",
     "description": [
      "This module asserts that given expressions are true with an optional custom message.",
      "This module is also supported for Windows targets."
     ],
     "filename": "/ansible/modules/assert.py",
     "has_action": true,
     "module": "assert",
     "options": {
      "fail_msg": {
       "aliases": [
        "msg"
       ],
       "description": [
        "The customized message used for a failing assertion.",
        "This argument was called 'msg' before Ansible 2.7, now it is renamed to 'fail_msg' with alias 'msg'."
       ],
       "type": "str",
       "version_added": "2.7",
       "version_added_collection": "ansible.builtin"
      },
      "quiet": {
       "default": false,
       "description": [
        "Set this to V(true) to avoid verbose output."
       ],
       "type": "bool",
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      },
      "success_msg": {
       "description": [
        "The customized message used for a successful assertion."
       ],
       "type": "str",
       "version_added": "2.7",
       "version_added_collection": "ansible.builtin"
      },
      "that": {
       "description": [
        "A list of string expressions of the same form that can be passed to the 'when' statement."
       ],
       "elements": "str",
       "required": true,
       "type": "list"
      }
     },
     "seealso": [
      {
       "module": "ansible.builtin.debug"
      },
      {
       "module": "ansible.builtin.fail"
      },
      {
       "module": "ansible.builtin.meta"
      }
     ],
     "short_description": "Asserts given expressions are true",
     "version_added": "1.5",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: A single condition can be supplied as string instead of list\n  ansible.builtin.assert:\n    that: \"ansible_os_family != 'RedHat'\"\n\n- name: Use yaml multiline strings to ease escaping\n  ansible.builtin.assert:\n    that:\n      - \"'foo' in some_command_result.stdout\"\n      - number_of_the_counting == 3\n      - >\n        \"reject\" not in some_command_result.stderr\n\n- name: After version 2.7 both 'msg' and 'fail_msg' can customize failing assertion message\n  ansible.builtin.assert:\n    that:\n      - my_param <= 100\n      - my_param >= 0\n    fail_msg: \"'my_param' must be between 0 and 100\"\n    success_msg: \"'my_param' is between 0 and 100\"\n\n- name: Please use 'msg' when ansible version is smaller than 2.7\n  ansible.builtin.assert:\n    that:\n      - my_param <= 100\n      - my_param >= 0\n    msg: \"'my_param' must be between 0 and 100\"\n\n- name: Use quiet to avoid verbose output\n  ansible.builtin.assert:\n    that:\n      - my_param <= 100\n      - my_param >= 0\n    quiet: true\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.async_status": {
    "doc": {
     "attributes": {
      "action": {
       "description": "Indicates this has a corresponding action plugin so some parts of the options can be executed on the controller",
       "support": "full"
      },
      "async": {
       "description": "Supports being used with the C(async) keyword",
       "support": "none"
      },
      "bypass_host_loop": {
       "description": [
        "Forces a 'global' task that does not execute per host, this bypasses per host templating and serial, throttle and other loop considerations",
        "Conditionals will work as if C(run_once) is being used, variables used will be from the first available host",
        "This action will not work normally outside of lockstep strategies"
       ],
       "support": "none"
      },
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "none"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix, windows",
       "support": "full"
      }
     },
     "author": [
      "Ansible Core Team",
      "Michael DeHaan"
     ],
     "collection": "ansible.builtin",
     "description": [
      "This module gets the status of an asynchronous task.",
      "This module is also supported for Windows targets."
     ],
     "filename": "/ansible/modules/async_status.py",
     "has_action": true,
     "module": "async_status",
     "options": {
      "jid": {
       "description": [
        "Job or task identifier"
       ],
       "required": true,
       "type": "str"
      },
      "mode": {
       "choices": [
        "cleanup",
        "status"
       ],
       "default": "status",
       "description": [
        "If V(status), obtain the status.",
        "If V(cleanup), clean up the async job cache (by default in C(~/.ansible_async/)) for the specified job O(jid), without waiting for it to finish."
       ],
       "type": "str"
      }
     },
     "seealso": [
      {
       "description": "Detailed information on how to use asynchronous actions and polling.",
       "ref": "playbooks_async"
      }
     ],
     "short_description": "Obtain status of asynchronous task",
     "version_added": "0.5",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n---\n- name: Asynchronous dnf task\n  ansible.builtin.dnf:\n    name: docker-io\n    state: present\n  async: 1000\n  poll: 0\n  register: dnf_sleeper\n\n- name: Wait for asynchronous job to end\n  ansible.builtin.async_status:\n    jid: '{{ dnf_sleeper.ansible_job_id }}'\n  register: job_result\n  until: job_result.finished\n  retries: 100\n  delay: 10\n\n- name: Clean up async file\n  ansible.builtin.async_status:\n    jid: '{{ dnf_sleeper.ansible_job_id }}'\n    mode: cleanup\n",
    "metadata": null,
    "return": {
     "ansible_job_id": {
      "description": "The asynchronous job id",
      "returned": "success",
      "sample": "360874038559.4169",
      "type": "str"
     },
     "erased": {
      "description": "Path to erased job file",
      "returned": "when file is erased",
      "type": "str"
     },
     "finished": {
      "description": "Whether the asynchronous job has finished (V(1)) or not (V(0))",
      "returned": "always",
      "sample": 1,
      "type": "int"
     },
     "started": {
      "description": "Whether the asynchronous job has started (V(1)) or not (V(0))",
      "returned": "always",
      "sample": 1,
      "type": "int"
     },
     "stderr": {
      "description": "Any errors returned by async_wrapper",
      "returned": "always",
      "type": "str"
     },
     "stdout": {
      "description": "Any output returned by async_wrapper",
      "returned": "always",
      "type": "str"
     }
    }
   },
   "ansible.builtin.blockinfile": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "full"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "full"
      },
      "safe_file_operations": {
       "description": "Uses Ansible's strict file operation functions to ensure proper permissions and avoid data corruption",
       "support": "full"
      },
      "vault": {
       "description": "Can automatically decrypt Ansible vaulted files",
       "support": "none"
      }
     },
     "author": [
      "Yaegashi Takeshi (@yaegashi)"
     ],
     "collection": "ansible.builtin",
     "description": [
      "This module will insert/update/remove a block of multi-line text surrounded by customizable marker lines."
     ],
     "filename": "/ansible/modules/blockinfile.py",
     "has_action": false,
     "module": "blockinfile",
     "notes": [
      "When using 'with_*' loops be aware that if you do not set a unique mark the block will be overwritten on each iteration.",
      "As of Ansible 2.3, the O(dest) option has been changed to O(path) as default, but O(dest) still works as well.",
      "Option O(ignore:follow) has been removed in Ansible 2.5, because this module modifies the contents of the file so O(ignore:follow=no) does not make sense.",
      "When more than one block should be handled in one file you must change the O(marker) per task."
     ],
     "options": {
      "append_newline": {
       "default": false,
       "description": [
        "Append a blank line to the inserted block, if this does not appear at the end of the file.",
        "Note that this attribute is not considered when C(state) is set to C(absent)"
       ],
       "required": false,
       "type": "bool",
       "version_added": "2.16",
       "version_added_collection": "ansible.builtin"
      },
      "attributes": {
       "aliases": [
        "attr"
       ],
       "description": [
        "The attributes the resulting filesystem object should have.",
        "To get supported flags look at the man page for I(chattr) on the target system.",
        "This string should contain the attributes in the same order as the one displayed by I(lsattr).",
        "The C(=) operator is assumed as default, otherwise C(+) or C(-) operators need to be included in the string."
       ],
       "type": "str",
       "version_added": "2.3",
       "version_added_collection": "ansible.builtin"
      },
      "backup": {
       "default": false,
       "description": [
        "Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly."
       ],
       "type": "bool"
      },
      "block": {
       "aliases": [
        "content"
       ],
       "default": "",
       "description": [
        "The text to insert inside the marker lines.",
        "If it is missing or an empty string, the block will be removed as if O(state) were specified to V(absent)."
       ],
       "type": "str"
      },
      "create": {
       "default": false,
       "description": [
        "Create a new file if it does not exist."
       ],
       "type": "bool"
      },
      "group": {
       "description": [
        "Name of the group that should own the filesystem object, as would be fed to I(chown).",
        "When left unspecified, it uses the current group of the current user unless you are root, in which case it can preserve the previous ownership."
       ],
       "type": "str"
      },
      "insertafter": {
       "choices": [
        "EOF",
        "*regex*"
       ],
       "default": "EOF",
       "description": [
        "If specified and no begin/ending O(marker) lines are found, the block will be inserted after the last match of specified regular expression.",
        "A special value is available; V(EOF) for inserting the block at the end of the file.",
        "If specified regular expression has no matches, V(EOF) will be used instead.",
        "The presence of the multiline flag (?m) in the regular expression controls whether the match is done line by line or with multiple lines. This behaviour was added in ansible-core 2.14."
       ],
       "type": "str"
      },
      "insertbefore": {
       "choices": [
        "BOF",
        "*regex*"
       ],
       "description": [
        "If specified and no begin/ending O(marker) lines are found, the block will be inserted before the last match of specified regular expression.",
        "A special value is available; V(BOF) for inserting the block at the beginning of the file.",
        "If specified regular expression has no matches, the block will be inserted at the end of the file.",
        "The presence of the multiline flag (?m) in the regular expression controls whether the match is done line by line or with multiple lines. This behaviour was added in ansible-core 2.14."
       ],
       "type": "str"
      },
      "marker": {
       "default": "# {mark} ANSIBLE MANAGED BLOCK",
       "description": [
        "The marker line template.",
        "C({mark}) will be replaced with the values in O(marker_begin) (default=\"BEGIN\") and O(marker_end) (default=\"END\").",
        "Using a custom marker without the C({mark}) variable may result in the block being repeatedly inserted on subsequent playbook runs.",
        "Multi-line markers are not supported and will result in the block being repeatedly inserted on subsequent playbook runs.",
        "A newline is automatically appended by the module to O(marker_begin) and O(marker_end)."
       ],
       "type": "str"
      },
      "marker_begin": {
       "default": "BEGIN",
       "description": [
        "This will be inserted at C({mark}) in the opening ansible block O(marker)."
       ],
       "type": "str",
       "version_added": "2.5",
       "version_added_collection": "ansible.builtin"
      },
      "marker_end": {
       "default": "END",
       "description": [
        "This will be inserted at C({mark}) in the closing ansible block O(marker)."
       ],
       "required": false,
       "type": "str",
       "version_added": "2.5",
       "version_added_collection": "ansible.builtin"
      },
      "mode": {
       "description": [
        "The permissions the resulting filesystem object should have.",
        "For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must give Ansible enough information to parse them correctly. For consistent results, quote octal numbers (for example, V('644') or V('1777')) so Ansible receives a string and can do its own conversion from string into number. Adding a leading zero (for example, V(0755)) works sometimes, but can fail in loops and some other circumstances.",
        "Giving Ansible a number without following either of these rules will end up with a decimal number which will have unexpected results.",
        "As of Ansible 1.8, the mode may be specified as a symbolic mode (for example, V(u+rwx) or V(u=rw,g=r,o=r)).",
        "If O(mode) is not specified and the destination filesystem object B(does not) exist, the default C(umask) on the system will be used when setting the mode for the newly created filesystem object.",
        "If O(mode) is not specified and the destination filesystem object B(does) exist, the mode of the existing filesystem object will be used.",
        "Specifying O(mode) is the best way to ensure filesystem objects are created with the correct permissions. See CVE-2020-1736 for further details."
       ],
       "type": "raw"
      },
      "owner": {
       "description": [
        "Name of the user that should own the filesystem object, as would be fed to I(chown).",
        "When left unspecified, it uses the current user unless you are root, in which case it can preserve the previous ownership.",
        "Specifying a numeric username will be assumed to be a user ID and not a username. Avoid numeric usernames to avoid this confusion."
       ],
       "type": "str"
      },
      "path": {
       "aliases": [
        "dest",
        "destfile",
        "name"
       ],
       "description": [
        "The file to modify.",
        "Before Ansible 2.3 this option was only usable as O(dest), O(destfile) and O(name)."
       ],
       "required": true,
       "type": "path"
      },
      "prepend_newline": {
       "default": false,
       "description": [
        "Prepend a blank line to the inserted block, if this does not appear at the beginning of the file.",
        "Note that this attribute is not considered when C(state) is set to C(absent)"
       ],
       "required": false,
       "type": "bool",
       "version_added": "2.16",
       "version_added_collection": "ansible.builtin"
      },
      "selevel": {
       "description": [
        "The level part of the SELinux filesystem object context.",
        "This is the MLS/MCS attribute, sometimes known as the C(range).",
        "When set to V(_default), it will use the C(level) portion of the policy if available."
       ],
       "type": "str"
      },
      "serole": {
       "description": [
        "The role part of the SELinux filesystem object context.",
        "When set to V(_default), it will use the C(role) portion of the policy if available."
       ],
       "type": "str"
      },
      "setype": {
       "description": [
        "The type part of the SELinux filesystem object context.",
        "When set to V(_default), it will use the C(type) portion of the policy if available."
       ],
       "type": "str"
      },
      "seuser": {
       "description": [
        "The user part of the SELinux filesystem object context.",
        "By default it uses the V(system) policy, where applicable.",
        "When set to V(_default), it will use the C(user) portion of the policy if available."
       ],
       "type": "str"
      },
      "state": {
       "choices": [
        "absent",
        "present"
       ],
       "default": "present",
       "description": [
        "Whether the block should be there or not."
       ],
       "type": "str"
      },
      "unsafe_writes": {
       "default": false,
       "description": [
        "Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target filesystem object.",
        "By default this module uses atomic operations to prevent data corruption or inconsistent reads from the target filesystem objects, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted filesystem objects, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.",
        "This option allows Ansible to fall back to unsafe methods of updating filesystem objects when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes).",
        "IMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption."
       ],
       "type": "bool",
       "version_added": "2.2",
       "version_added_collection": "ansible.builtin"
      },
      "validate": {
       "description": [
        "The validation command to run before copying the updated file into the final destination.",
        "A temporary file path is used to validate, passed in through '%s' which must be present as in the examples below.",
        "Also, the command is passed securely so shell features such as expansion and pipes will not work.",
        "For an example on how to handle more complex validation than what this option provides, see R(handling complex validation,complex_configuration_validation)."
       ],
       "type": "str"
      }
     },
     "short_description": "Insert/update/remove a text block surrounded by marker lines",
     "version_added": "2.0",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# Before Ansible 2.3, option 'dest' or 'name' was used instead of 'path'\n- name: Insert/Update \"Match User\" configuration block in /etc/ssh/sshd_config prepending and appending a new line\n  ansible.builtin.blockinfile:\n    path: /etc/ssh/sshd_config\n    append_newline: true\n    prepend_newline: true\n    block: |\n      Match User ansible-agent\n      PasswordAuthentication no\n\n- name: Insert/Update eth0 configuration stanza in /etc/network/interfaces\n        (it might be better to copy files into /etc/network/interfaces.d/)\n  ansible.builtin.blockinfile:\n    path: /etc/network/interfaces\n    block: |\n      iface eth0 inet static\n          address 192.0.2.23\n          netmask 255.255.255.0\n\n- name: Insert/Update configuration using a local file and validate it\n  ansible.builtin.blockinfile:\n    block: \"{{ lookup('ansible.builtin.file', './local/sshd_config') }}\"\n    path: /etc/ssh/sshd_config\n    backup: yes\n    validate: /usr/sbin/sshd -T -f %s\n\n- name: Insert/Update HTML surrounded by custom markers after <body> line\n  ansible.builtin.blockinfile:\n    path: /var/www/html/index.html\n    marker: \"<!-- {mark} ANSIBLE MANAGED BLOCK -->\"\n    insertafter: \"<body>\"\n    block: |\n      <h1>Welcome to {{ ansible_hostname }}</h1>\n      <p>Last updated on {{ ansible_date_time.iso8601 }}</p>\n\n- name: Remove HTML as well as surrounding markers\n  ansible.builtin.blockinfile:\n    path: /var/www/html/index.html\n    marker: \"<!-- {mark} ANSIBLE MANAGED BLOCK -->\"\n    block: \"\"\n\n- name: Add mappings to /etc/hosts\n  ansible.builtin.blockinfile:\n    path: /etc/hosts\n    block: |\n      {{ item.ip }} {{ item.name }}\n    marker: \"# {mark} ANSIBLE MANAGED BLOCK {{ item.name }}\"\n  loop:\n    - { name: host1, ip: 10.10.1.10 }\n    - { name: host2, ip: 10.10.1.11 }\n    - { name: host3, ip: 10.10.1.12 }\n\n- name: Search with a multiline search flags regex and if found insert after\n  blockinfile:\n    path: listener.ora\n    block: \"{{ listener_line | indent(width=8, first=True) }}\"\n    insertafter: '(?m)SID_LIST_LISTENER_DG =\\n.*\\(SID_LIST ='\n    marker: \"    <!-- {mark} ANSIBLE MANAGED BLOCK -->\"\n\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.command": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "details": "while the command itself is arbitrary and cannot be subject to the check mode semantics it adds O(creates)/O(removes) options as a workaround",
       "support": "partial"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "full"
      },
      "raw": {
       "description": "Indicates if an action takes a 'raw' or 'free form' string as an option and has it's own special parsing of it",
       "support": "full"
      }
     },
     "author": [
      "Ansible Core Team",
      "Michael DeHaan"
     ],
     "collection": "ansible.builtin",
     "description": [
      "The M(ansible.builtin.command) module takes the command name followed by a list of space-delimited arguments.",
      "The given command will be executed on all selected nodes.",
      "The command(s) will not be processed through the shell, so variables like C($HOSTNAME) and operations like C(\"*\"), C(\"<\"), C(\">\"), C(\"|\"), C(\";\") and C(\"&\") will not work. Use the M(ansible.builtin.shell) module if you need these features.",
      "To create C(command) tasks that are easier to read than the ones using space-delimited arguments, pass parameters using the C(args) L(task keyword,https://docs.ansible.com/ansible/latest/reference_appendices/playbooks_keywords.html#task) or use O(cmd) parameter.",
      "Either a free form command or O(cmd) parameter is required, see the examples.",
      "For Windows targets, use the M(ansible.windows.win_command) module instead."
     ],
     "filename": "/ansible/modules/command.py",
     "has_action": true,
     "module": "command",
     "notes": [
      "If you want to run a command through the shell (say you are using C(<), C(>), C(|), and so on), you actually want the M(ansible.builtin.shell) module instead. Parsing shell metacharacters can lead to unexpected commands being executed if quoting is not done correctly so it is more secure to use the M(ansible.builtin.command) module when possible.",
      "O(creates), O(removes), and O(chdir) can be specified after the command. For instance, if you only want to run a command if a certain file does not exist, use this.",
      "Check mode is supported when passing O(creates) or O(removes). If running in check mode and either of these are specified, the module will check for the existence of the file and report the correct changed status. If these are not supplied, the task will be skipped.",
      "The O(ignore:executable) parameter is removed since version 2.4. If you have a need for this parameter, use the M(ansible.builtin.shell) module instead.",
      "For Windows targets, use the M(ansible.windows.win_command) module instead.",
      "For rebooting systems, use the M(ansible.builtin.reboot) or M(ansible.windows.win_reboot) module.",
      "If the command returns non UTF-8 data, it must be encoded to avoid issues. This may necessitate using M(ansible.builtin.shell) so the output can be piped through C(base64)."
     ],
     "options": {
      "argv": {
       "description": [
        "Passes the command as a list rather than a string.",
        "Use O(argv) to avoid quoting values that would otherwise be interpreted incorrectly (for example \"user name\").",
        "Only the string (free form) or the list (argv) form can be provided, not both.  One or the other must be provided."
       ],
       "elements": "str",
       "type": "list",
       "version_added": "2.6",
       "version_added_collection": "ansible.builtin"
      },
      "chdir": {
       "description": [
        "Change into this directory before running the command."
       ],
       "type": "path",
       "version_added": "0.6",
       "version_added_collection": "ansible.builtin"
      },
      "cmd": {
       "description": [
        "The command to run."
       ],
       "type": "str"
      },
      "creates": {
       "description": [
        "A filename or (since 2.0) glob pattern. If a matching file already exists, this step B(will not) be run.",
        "This is checked before O(removes) is checked."
       ],
       "type": "path"
      },
      "expand_argument_vars": {
       "default": true,
       "description": [
        "Expands the arguments that are variables, for example C($HOME) will be expanded before being passed to the command to run.",
        "Set to V(false) to disable expansion and treat the value as a literal argument."
       ],
       "type": "bool",
       "version_added": "2.16",
       "version_added_collection": "ansible.builtin"
      },
      "free_form": {
       "description": [
        "The command module takes a free form string as a command to run.",
        "There is no actual parameter named 'free form'."
       ]
      },
      "removes": {
       "description": [
        "A filename or (since 2.0) glob pattern. If a matching file exists, this step B(will) be run.",
        "This is checked after O(creates) is checked."
       ],
       "type": "path",
       "version_added": "0.8",
       "version_added_collection": "ansible.builtin"
      },
      "stdin": {
       "description": [
        "Set the stdin of the command directly to the specified value."
       ],
       "type": "str",
       "version_added": "2.4",
       "version_added_collection": "ansible.builtin"
      },
      "stdin_add_newline": {
       "default": true,
       "description": [
        "If set to V(true), append a newline to stdin data."
       ],
       "type": "bool",
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      },
      "strip_empty_ends": {
       "default": true,
       "description": [
        "Strip empty lines from the end of stdout/stderr in result."
       ],
       "type": "bool",
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      }
     },
     "seealso": [
      {
       "module": "ansible.builtin.raw"
      },
      {
       "module": "ansible.builtin.script"
      },
      {
       "module": "ansible.builtin.shell"
      },
      {
       "module": "ansible.windows.win_command"
      }
     ],
     "short_description": "Execute commands on targets",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Return motd to registered var\n  ansible.builtin.command: cat /etc/motd\n  register: mymotd\n\n# free-form (string) arguments, all arguments on one line\n- name: Run command if /path/to/database does not exist (without 'args')\n  ansible.builtin.command: /usr/bin/make_database.sh db_user db_name creates=/path/to/database\n\n# free-form (string) arguments, some arguments on separate lines with the 'args' keyword\n# 'args' is a task keyword, passed at the same level as the module\n- name: Run command if /path/to/database does not exist (with 'args' keyword)\n  ansible.builtin.command: /usr/bin/make_database.sh db_user db_name\n  args:\n    creates: /path/to/database\n\n# 'cmd' is module parameter\n- name: Run command if /path/to/database does not exist (with 'cmd' parameter)\n  ansible.builtin.command:\n    cmd: /usr/bin/make_database.sh db_user db_name\n    creates: /path/to/database\n\n- name: Change the working directory to somedir/ and run the command as db_owner if /path/to/database does not exist\n  ansible.builtin.command: /usr/bin/make_database.sh db_user db_name\n  become: yes\n  become_user: db_owner\n  args:\n    chdir: somedir/\n    creates: /path/to/database\n\n# argv (list) arguments, each argument on a separate line, 'args' keyword not necessary\n# 'argv' is a parameter, indented one level from the module\n- name: Use 'argv' to send a command as a list - leave 'command' empty\n  ansible.builtin.command:\n    argv:\n      - /usr/bin/make_database.sh\n      - Username with whitespace\n      - dbname with whitespace\n    creates: /path/to/database\n\n- name: Run command using argv with mixed argument formats\n  ansible.builtin.command:\n    argv:\n      - /path/to/binary\n      - -v\n      - --debug\n      - --longopt\n      - value for longopt\n      - --other-longopt=value for other longopt\n      - positional\n\n- name: Safely use templated variable to run command. Always use the quote filter to avoid injection issues\n  ansible.builtin.command: cat {{ myfile|quote }}\n  register: myoutput\n",
    "metadata": null,
    "return": {
     "cmd": {
      "description": "The command executed by the task.",
      "returned": "always",
      "sample": [
       "echo",
       "hello"
      ],
      "type": "list"
     },
     "delta": {
      "description": "The command execution delta time.",
      "returned": "always",
      "sample": "0:00:00.001529",
      "type": "str"
     },
     "end": {
      "description": "The command execution end time.",
      "returned": "always",
      "sample": "2017-09-29 22:03:48.084657",
      "type": "str"
     },
     "msg": {
      "description": "changed",
      "returned": "always",
      "sample": true,
      "type": "bool"
     },
     "rc": {
      "description": "The command return code (0 means success).",
      "returned": "always",
      "sample": 0,
      "type": "int"
     },
     "start": {
      "description": "The command execution start time.",
      "returned": "always",
      "sample": "2017-09-29 22:03:48.083128",
      "type": "str"
     },
     "stderr": {
      "description": "The command standard error.",
      "returned": "always",
      "sample": "ls cannot access foo: No such file or directory",
      "type": "str"
     },
     "stderr_lines": {
      "description": "The command standard error split in lines.",
      "returned": "always",
      "sample": [
       {
        "u'ls cannot access foo": "No such file or directory'"
       },
       "u'ls \u2026'"
      ],
      "type": "list"
     },
     "stdout": {
      "description": "The command standard output.",
      "returned": "always",
      "sample": "Clustering node rabbit@slave1 with rabbit@master \u2026",
      "type": "str"
     },
     "stdout_lines": {
      "description": "The command standard output split in lines.",
      "returned": "always",
      "sample": [
       "u'Clustering node rabbit@slave1 with rabbit@master \u2026'"
      ],
      "type": "list"
     }
    }
   },
   "ansible.builtin.copy": {
    "doc": {
     "attributes": {
      "action": {
       "description": "Indicates this has a corresponding action plugin so some parts of the options can be executed on the controller",
       "support": "full"
      },
      "async": {
       "description": "Supports being used with the C(async) keyword",
       "support": "none"
      },
      "bypass_host_loop": {
       "description": [
        "Forces a 'global' task that does not execute per host, this bypasses per host templating and serial, throttle and other loop considerations",
        "Conditionals will work as if C(run_once) is being used, variables used will be from the first available host",
        "This action will not work normally outside of lockstep strategies"
       ],
       "support": "none"
      },
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "full"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "N/A"
      },
      "safe_file_operations": {
       "description": "Uses Ansible's strict file operation functions to ensure proper permissions and avoid data corruption",
       "support": "full"
      },
      "vault": {
       "description": "Can automatically decrypt Ansible vaulted files",
       "support": "full",
       "version_added": "2.2",
       "version_added_collection": "ansible.builtin"
      }
     },
     "author": [
      "Ansible Core Team",
      "Michael DeHaan"
     ],
     "collection": "ansible.builtin",
     "description": [
      "The M(ansible.builtin.copy) module copies a file or a directory structure from the local or remote machine to a location on the remote machine. File system meta-information (permissions, ownership, etc.) may be set, even when the file or directory already exists on the target system. Some meta-information may be copied on request.",
      "Get meta-information with the M(ansible.builtin.stat) module.",
      "Set meta-information with the M(ansible.builtin.file) module.",
      "Use the M(ansible.builtin.fetch) module to copy files from remote locations to the local box.",
      "If you need variable interpolation in copied files, use the M(ansible.builtin.template) module. Using a variable with the O(content) parameter produces unpredictable results.",
      "For Windows targets, use the M(ansible.windows.win_copy) module instead."
     ],
     "filename": "/ansible/modules/copy.py",
     "has_action": true,
     "module": "copy",
     "notes": [
      "The M(ansible.builtin.copy) module recursively copy facility does not scale to lots (>hundreds) of files."
     ],
     "options": {
      "attributes": {
       "aliases": [
        "attr"
       ],
       "description": [
        "The attributes the resulting filesystem object should have.",
        "To get supported flags look at the man page for I(chattr) on the target system.",
        "This string should contain the attributes in the same order as the one displayed by I(lsattr).",
        "The C(=) operator is assumed as default, otherwise C(+) or C(-) operators need to be included in the string."
       ],
       "type": "str",
       "version_added": "2.3",
       "version_added_collection": "ansible.builtin"
      },
      "backup": {
       "default": false,
       "description": [
        "Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly."
       ],
       "type": "bool",
       "version_added": "0.7",
       "version_added_collection": "ansible.builtin"
      },
      "checksum": {
       "description": [
        "SHA1 checksum of the file being transferred.",
        "Used to validate that the copy of the file was successful.",
        "If this is not provided, ansible will use the local calculated checksum of the src file."
       ],
       "type": "str",
       "version_added": "2.5",
       "version_added_collection": "ansible.builtin"
      },
      "content": {
       "description": [
        "When used instead of O(src), sets the contents of a file directly to the specified value.",
        "Works only when O(dest) is a file. Creates the file if it does not exist.",
        "For advanced formatting or if O(content) contains a variable, use the M(ansible.builtin.template) module."
       ],
       "type": "str",
       "version_added": "1.1",
       "version_added_collection": "ansible.builtin"
      },
      "decrypt": {
       "default": true,
       "description": [
        "This option controls the auto-decryption of source files using vault."
       ],
       "type": "bool",
       "version_added": "2.4",
       "version_added_collection": "ansible.builtin"
      },
      "dest": {
       "description": [
        "Remote absolute path where the file should be copied to.",
        "If O(src) is a directory, this must be a directory too.",
        "If O(dest) is a non-existent path and if either O(dest) ends with \"/\" or O(src) is a directory, O(dest) is created.",
        "If O(dest) is a relative path, the starting directory is determined by the remote host.",
        "If O(src) and O(dest) are files, the parent directory of O(dest) is not created and the task fails if it does not already exist."
       ],
       "required": true,
       "type": "path"
      },
      "directory_mode": {
       "description": [
        "Set the access permissions of newly created directories to the given mode. Permissions on existing directories do not change.",
        "See O(mode) for the syntax of accepted values.",
        "The target system's defaults determine permissions when this parameter is not set."
       ],
       "type": "raw",
       "version_added": "1.5",
       "version_added_collection": "ansible.builtin"
      },
      "follow": {
       "default": false,
       "description": [
        "This flag indicates that filesystem links in the destination, if they exist, should be followed."
       ],
       "type": "bool",
       "version_added": "1.8",
       "version_added_collection": "ansible.builtin"
      },
      "force": {
       "default": true,
       "description": [
        "Influence whether the remote file must always be replaced.",
        "If V(true), the remote file will be replaced when contents are different than the source.",
        "If V(false), the file will only be transferred if the destination does not exist."
       ],
       "type": "bool",
       "version_added": "1.1",
       "version_added_collection": "ansible.builtin"
      },
      "group": {
       "description": [
        "Name of the group that should own the filesystem object, as would be fed to I(chown).",
        "When left unspecified, it uses the current group of the current user unless you are root, in which case it can preserve the previous ownership."
       ],
       "type": "str"
      },
      "local_follow": {
       "default": true,
       "description": [
        "This flag indicates that filesystem links in the source tree, if they exist, should be followed."
       ],
       "type": "bool",
       "version_added": "2.4",
       "version_added_collection": "ansible.builtin"
      },
      "mode": {
       "description": [
        "The permissions of the destination file or directory.",
        "For those used to C(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like V(0644) or V(01777)) or quote it (like V('644') or V('1777')) so Ansible receives a string and can do its own conversion from string into number. Giving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results.",
        "As of Ansible 1.8, the mode may be specified as a symbolic mode (for example, V(u+rwx) or V(u=rw,g=r,o=r)).",
        "As of Ansible 2.3, the mode may also be the special string V(preserve).",
        "V(preserve) means that the file will be given the same permissions as the source file.",
        "When doing a recursive copy, see also O(directory_mode).",
        "If O(mode) is not specified and the destination file B(does not) exist, the default C(umask) on the system will be used when setting the mode for the newly created file.",
        "If O(mode) is not specified and the destination file B(does) exist, the mode of the existing file will be used.",
        "Specifying O(mode) is the best way to ensure files are created with the correct permissions. See CVE-2020-1736 for further details."
       ],
       "type": "raw"
      },
      "owner": {
       "description": [
        "Name of the user that should own the filesystem object, as would be fed to I(chown).",
        "When left unspecified, it uses the current user unless you are root, in which case it can preserve the previous ownership.",
        "Specifying a numeric username will be assumed to be a user ID and not a username. Avoid numeric usernames to avoid this confusion."
       ],
       "type": "str"
      },
      "remote_src": {
       "default": false,
       "description": [
        "Influence whether O(src) needs to be transferred or already is present remotely.",
        "If V(false), it will search for O(src) on the controller node.",
        "If V(true) it will search for O(src) on the managed (remote) node.",
        "O(remote_src) supports recursive copying as of version 2.8.",
        "O(remote_src) only works with O(mode=preserve) as of version 2.6.",
        "Auto-decryption of files does not work when O(remote_src=yes)."
       ],
       "type": "bool",
       "version_added": "2.0",
       "version_added_collection": "ansible.builtin"
      },
      "selevel": {
       "description": [
        "The level part of the SELinux filesystem object context.",
        "This is the MLS/MCS attribute, sometimes known as the C(range).",
        "When set to V(_default), it will use the C(level) portion of the policy if available."
       ],
       "type": "str"
      },
      "serole": {
       "description": [
        "The role part of the SELinux filesystem object context.",
        "When set to V(_default), it will use the C(role) portion of the policy if available."
       ],
       "type": "str"
      },
      "setype": {
       "description": [
        "The type part of the SELinux filesystem object context.",
        "When set to V(_default), it will use the C(type) portion of the policy if available."
       ],
       "type": "str"
      },
      "seuser": {
       "description": [
        "The user part of the SELinux filesystem object context.",
        "By default it uses the V(system) policy, where applicable.",
        "When set to V(_default), it will use the C(user) portion of the policy if available."
       ],
       "type": "str"
      },
      "src": {
       "description": [
        "Local path to a file to copy to the remote server.",
        "This can be absolute or relative.",
        "If path is a directory, it is copied recursively. In this case, if path ends with \"/\", only inside contents of that directory are copied to destination. Otherwise, if it does not end with \"/\", the directory itself with all contents is copied. This behavior is similar to the C(rsync) command line tool."
       ],
       "type": "path"
      },
      "unsafe_writes": {
       "default": false,
       "description": [
        "Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target filesystem object.",
        "By default this module uses atomic operations to prevent data corruption or inconsistent reads from the target filesystem objects, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted filesystem objects, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.",
        "This option allows Ansible to fall back to unsafe methods of updating filesystem objects when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes).",
        "IMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption."
       ],
       "type": "bool",
       "version_added": "2.2",
       "version_added_collection": "ansible.builtin"
      },
      "validate": {
       "description": [
        "The validation command to run before copying the updated file into the final destination.",
        "A temporary file path is used to validate, passed in through '%s' which must be present as in the examples below.",
        "Also, the command is passed securely so shell features such as expansion and pipes will not work.",
        "For an example on how to handle more complex validation than what this option provides, see R(handling complex validation,complex_configuration_validation)."
       ],
       "type": "str"
      }
     },
     "seealso": [
      {
       "module": "ansible.builtin.assemble"
      },
      {
       "module": "ansible.builtin.fetch"
      },
      {
       "module": "ansible.builtin.file"
      },
      {
       "module": "ansible.builtin.template"
      },
      {
       "module": "ansible.posix.synchronize"
      },
      {
       "module": "ansible.windows.win_copy"
      }
     ],
     "short_description": "Copy files to remote locations",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Copy file with owner and permissions\n  ansible.builtin.copy:\n    src: /srv/myfiles/foo.conf\n    dest: /etc/foo.conf\n    owner: foo\n    group: foo\n    mode: '0644'\n\n- name: Copy file with owner and permission, using symbolic representation\n  ansible.builtin.copy:\n    src: /srv/myfiles/foo.conf\n    dest: /etc/foo.conf\n    owner: foo\n    group: foo\n    mode: u=rw,g=r,o=r\n\n- name: Another symbolic mode example, adding some permissions and removing others\n  ansible.builtin.copy:\n    src: /srv/myfiles/foo.conf\n    dest: /etc/foo.conf\n    owner: foo\n    group: foo\n    mode: u+rw,g-wx,o-rwx\n\n- name: Copy a new \"ntp.conf\" file into place, backing up the original if it differs from the copied version\n  ansible.builtin.copy:\n    src: /mine/ntp.conf\n    dest: /etc/ntp.conf\n    owner: root\n    group: root\n    mode: '0644'\n    backup: yes\n\n- name: Copy a new \"sudoers\" file into place, after passing validation with visudo\n  ansible.builtin.copy:\n    src: /mine/sudoers\n    dest: /etc/sudoers\n    validate: /usr/sbin/visudo -csf %s\n\n- name: Copy a \"sudoers\" file on the remote machine for editing\n  ansible.builtin.copy:\n    src: /etc/sudoers\n    dest: /etc/sudoers.edit\n    remote_src: yes\n    validate: /usr/sbin/visudo -csf %s\n\n- name: Copy using inline content\n  ansible.builtin.copy:\n    content: '# This file was moved to /etc/other.conf'\n    dest: /etc/mine.conf\n\n- name: If follow=yes, /path/to/file will be overwritten by contents of foo.conf\n  ansible.builtin.copy:\n    src: /etc/foo.conf\n    dest: /path/to/link  # link to /path/to/file\n    follow: yes\n\n- name: If follow=no, /path/to/link will become a file and be overwritten by contents of foo.conf\n  ansible.builtin.copy:\n    src: /etc/foo.conf\n    dest: /path/to/link  # link to /path/to/file\n    follow: no\n",
    "metadata": null,
    "return": {
     "backup_file": {
      "description": "Name of backup file created.",
      "returned": "changed and if backup=yes",
      "sample": "/path/to/file.txt.2015-02-12@22:09~",
      "type": "str"
     },
     "checksum": {
      "description": "SHA1 checksum of the file after running copy.",
      "returned": "success",
      "sample": "6e642bb8dd5c2e027bf21dd923337cbb4214f827",
      "type": "str"
     },
     "dest": {
      "description": "Destination file/path.",
      "returned": "success",
      "sample": "/path/to/file.txt",
      "type": "str"
     },
     "gid": {
      "description": "Group id of the file, after execution.",
      "returned": "success",
      "sample": 100,
      "type": "int"
     },
     "group": {
      "description": "Group of the file, after execution.",
      "returned": "success",
      "sample": "httpd",
      "type": "str"
     },
     "md5sum": {
      "description": "MD5 checksum of the file after running copy.",
      "returned": "when supported",
      "sample": "2a5aeecc61dc98c4d780b14b330e3282",
      "type": "str"
     },
     "mode": {
      "description": "Permissions of the target, after execution.",
      "returned": "success",
      "sample": "0644",
      "type": "str"
     },
     "owner": {
      "description": "Owner of the file, after execution.",
      "returned": "success",
      "sample": "httpd",
      "type": "str"
     },
     "size": {
      "description": "Size of the target, after execution.",
      "returned": "success",
      "sample": 1220,
      "type": "int"
     },
     "src": {
      "description": "Source file used for the copy on the target machine.",
      "returned": "changed",
      "sample": "/home/httpd/.ansible/tmp/ansible-tmp-1423796390.97-147729857856000/source",
      "type": "str"
     },
     "state": {
      "description": "State of the target, after execution.",
      "returned": "success",
      "sample": "file",
      "type": "str"
     },
     "uid": {
      "description": "Owner id of the file, after execution.",
      "returned": "success",
      "sample": 100,
      "type": "int"
     }
    }
   },
   "ansible.builtin.cron": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "full"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "full"
      }
     },
     "author": [
      "Dane Summers (@dsummersl)",
      "Mike Grozak (@rhaido)",
      "Patrick Callahan (@dirtyharrycallahan)",
      "Evan Kaufman (@EvanK)",
      "Luca Berruti (@lberruti)"
     ],
     "collection": "ansible.builtin",
     "description": [
      "Use this module to manage crontab and environment variables entries. This module allows you to create environment variables and named crontab entries, update, or delete them.",
      "When crontab jobs are managed: the module includes one line with the description of the crontab entry C(\"#Ansible: <name>\") corresponding to the \"name\" passed to the module, which is used by future ansible/module calls to find/check the state. The \"name\" parameter should be unique, and changing the \"name\" value will result in a new cron task being created (or a different one being removed).",
      "When environment variables are managed, no comment line is added, but, when the module needs to find/check the state, it uses the \"name\" parameter to find the environment variable definition line.",
      "When using symbols such as %, they must be properly escaped."
     ],
     "filename": "/ansible/modules/cron.py",
     "has_action": false,
     "module": "cron",
     "options": {
      "backup": {
       "default": false,
       "description": [
        "If set, create a backup of the crontab before it is modified. The location of the backup is returned in the RV(ignore:backup_file) variable by this module."
       ],
       "type": "bool"
      },
      "cron_file": {
       "description": [
        "If specified, uses this file instead of an individual user's crontab. The assumption is that this file is exclusively managed by the module, do not use if the file contains multiple entries, NEVER use for /etc/crontab.",
        "If this is a relative path, it is interpreted with respect to C(/etc/cron.d).",
        "Many linux distros expect (and some require) the filename portion to consist solely of upper- and lower-case letters, digits, underscores, and hyphens.",
        "Using this parameter requires you to specify the O(user) as well, unless O(state) is not V(present).",
        "Either this parameter or O(name) is required"
       ],
       "type": "path"
      },
      "day": {
       "aliases": [
        "dom"
       ],
       "default": "*",
       "description": [
        "Day of the month the job should run (V(1-31), V(*), V(*/2), and so on)."
       ],
       "type": "str"
      },
      "disabled": {
       "default": false,
       "description": [
        "If the job should be disabled (commented out) in the crontab.",
        "Only has effect if O(state=present)."
       ],
       "type": "bool",
       "version_added": "2.0",
       "version_added_collection": "ansible.builtin"
      },
      "env": {
       "default": false,
       "description": [
        "If set, manages a crontab's environment variable.",
        "New variables are added on top of crontab.",
        "O(name) and O(value) parameters are the name and the value of environment variable."
       ],
       "type": "bool",
       "version_added": "2.1",
       "version_added_collection": "ansible.builtin"
      },
      "hour": {
       "default": "*",
       "description": [
        "Hour when the job should run (V(0-23), V(*), V(*/2), and so on)."
       ],
       "type": "str"
      },
      "insertafter": {
       "description": [
        "Used with O(state=present) and O(env).",
        "If specified, the environment variable will be inserted after the declaration of specified environment variable."
       ],
       "type": "str",
       "version_added": "2.1",
       "version_added_collection": "ansible.builtin"
      },
      "insertbefore": {
       "description": [
        "Used with O(state=present) and O(env).",
        "If specified, the environment variable will be inserted before the declaration of specified environment variable."
       ],
       "type": "str",
       "version_added": "2.1",
       "version_added_collection": "ansible.builtin"
      },
      "job": {
       "aliases": [
        "value"
       ],
       "description": [
        "The command to execute or, if env is set, the value of environment variable.",
        "The command should not contain line breaks.",
        "Required if O(state=present)."
       ],
       "type": "str"
      },
      "minute": {
       "default": "*",
       "description": [
        "Minute when the job should run (V(0-59), V(*), V(*/2), and so on)."
       ],
       "type": "str"
      },
      "month": {
       "default": "*",
       "description": [
        "Month of the year the job should run (V(1-12), V(*), V(*/2), and so on)."
       ],
       "type": "str"
      },
      "name": {
       "description": [
        "Description of a crontab entry or, if env is set, the name of environment variable.",
        "This parameter is always required as of ansible-core 2.12."
       ],
       "required": true,
       "type": "str"
      },
      "special_time": {
       "choices": [
        "annually",
        "daily",
        "hourly",
        "monthly",
        "reboot",
        "weekly",
        "yearly"
       ],
       "description": [
        "Special time specification nickname."
       ],
       "type": "str",
       "version_added": "1.3",
       "version_added_collection": "ansible.builtin"
      },
      "state": {
       "choices": [
        "absent",
        "present"
       ],
       "default": "present",
       "description": [
        "Whether to ensure the job or environment variable is present or absent."
       ],
       "type": "str"
      },
      "user": {
       "description": [
        "The specific user whose crontab should be modified.",
        "When unset, this parameter defaults to the current user."
       ],
       "type": "str"
      },
      "weekday": {
       "aliases": [
        "dow"
       ],
       "default": "*",
       "description": [
        "Day of the week that the job should run (V(0-6) for Sunday-Saturday, V(*), and so on)."
       ],
       "type": "str"
      }
     },
     "requirements": [
      "cron (any 'vixie cron' conformant variant, like cronie)"
     ],
     "short_description": "Manage cron.d and crontab entries",
     "version_added": "0.9",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Ensure a job that runs at 2 and 5 exists. Creates an entry like \"0 5,2 * * ls -alh > /dev/null\"\n  ansible.builtin.cron:\n    name: \"check dirs\"\n    minute: \"0\"\n    hour: \"5,2\"\n    job: \"ls -alh > /dev/null\"\n\n- name: 'Ensure an old job is no longer present. Removes any job that is prefixed by \"#Ansible: an old job\" from the crontab'\n  ansible.builtin.cron:\n    name: \"an old job\"\n    state: absent\n\n- name: Creates an entry like \"@reboot /some/job.sh\"\n  ansible.builtin.cron:\n    name: \"a job for reboot\"\n    special_time: reboot\n    job: \"/some/job.sh\"\n\n- name: Creates an entry like \"PATH=/opt/bin\" on top of crontab\n  ansible.builtin.cron:\n    name: PATH\n    env: yes\n    job: /opt/bin\n\n- name: Creates an entry like \"APP_HOME=/srv/app\" and insert it after PATH declaration\n  ansible.builtin.cron:\n    name: APP_HOME\n    env: yes\n    job: /srv/app\n    insertafter: PATH\n\n- name: Creates a cron file under /etc/cron.d\n  ansible.builtin.cron:\n    name: yum autoupdate\n    weekday: \"2\"\n    minute: \"0\"\n    hour: \"12\"\n    user: root\n    job: \"YUMINTERACTIVE=0 /usr/sbin/yum-autoupdate\"\n    cron_file: ansible_yum-autoupdate\n\n- name: Removes a cron file from under /etc/cron.d\n  ansible.builtin.cron:\n    name: \"yum autoupdate\"\n    cron_file: ansible_yum-autoupdate\n    state: absent\n\n- name: Removes \"APP_HOME\" environment variable from crontab\n  ansible.builtin.cron:\n    name: APP_HOME\n    env: yes\n    state: absent\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.deb822_repository": {
    "doc": {
     "author": "Ansible Core Team (@ansible)",
     "collection": "ansible.builtin",
     "description": [
      "Add and remove deb822 formatted repositories in Debian based distributions"
     ],
     "filename": "/ansible/modules/deb822_repository.py",
     "has_action": false,
     "module": "deb822_repository",
     "notes": [
      "This module will not automatically update caches, call the apt module based on the changed state."
     ],
     "options": {
      "allow_downgrade_to_insecure": {
       "description": [
        "Allow downgrading a package that was previously authenticated but is no longer authenticated"
       ],
       "type": "bool"
      },
      "allow_insecure": {
       "description": [
        "Allow insecure repositories"
       ],
       "type": "bool"
      },
      "allow_weak": {
       "description": [
        "Allow repositories signed with a key using a weak digest algorithm"
       ],
       "type": "bool"
      },
      "architectures": {
       "description": [
        "Architectures to search within repository"
       ],
       "elements": "str",
       "type": "list"
      },
      "by_hash": {
       "description": [
        "Controls if APT should try to acquire indexes via a URI constructed from a hashsum of the expected file instead of using the well-known stable filename of the index."
       ],
       "type": "bool"
      },
      "check_date": {
       "description": [
        "Controls if APT should consider the machine's time correct and hence perform time related checks, such as verifying that a Release file is not from the future."
       ],
       "type": "bool"
      },
      "check_valid_until": {
       "description": [
        "Controls if APT should try to detect replay attacks."
       ],
       "type": "bool"
      },
      "components": {
       "description": [
        "Components specify different sections of one distribution version present in a Suite."
       ],
       "elements": "str",
       "type": "list"
      },
      "date_max_future": {
       "description": [
        "Controls how far from the future a repository may be."
       ],
       "type": "int"
      },
      "enabled": {
       "description": [
        "Tells APT whether the source is enabled or not."
       ],
       "type": "bool"
      },
      "inrelease_path": {
       "description": [
        "Determines the path to the InRelease file, relative to the normal position of an InRelease file."
       ],
       "type": "str"
      },
      "languages": {
       "description": [
        "Defines which languages information such as translated package descriptions should be downloaded."
       ],
       "elements": "str",
       "type": "list"
      },
      "mode": {
       "default": "0644",
       "description": [
        "The octal mode for newly created files in sources.list.d."
       ],
       "type": "raw"
      },
      "name": {
       "description": [
        "Name of the repo. Specifically used for C(X-Repolib-Name) and in naming the repository and signing key files."
       ],
       "required": true,
       "type": "str"
      },
      "pdiffs": {
       "description": [
        "Controls if APT should try to use PDiffs to update old indexes instead of downloading the new indexes entirely"
       ],
       "type": "bool"
      },
      "signed_by": {
       "description": [
        "Either a URL to a GPG key, absolute path to a keyring file, one or more fingerprints of keys either in the C(trusted.gpg) keyring or in the keyrings in the C(trusted.gpg.d/) directory, or an ASCII armored GPG public key block."
       ],
       "type": "str"
      },
      "state": {
       "choices": [
        "absent",
        "present"
       ],
       "default": "present",
       "description": [
        "A source string state."
       ],
       "type": "str"
      },
      "suites": {
       "description": [
        "Suite can specify an exact path in relation to the URI(s) provided, in which case the Components: must be omitted and suite must end with a slash (C(/)). Alternatively, it may take the form of a distribution version (e.g. a version codename like disco or artful). If the suite does not specify a path, at least one component must be present."
       ],
       "elements": "str",
       "type": "list"
      },
      "targets": {
       "description": [
        "Defines which download targets apt will try to acquire from this source."
       ],
       "elements": "str",
       "type": "list"
      },
      "trusted": {
       "description": [
        "Decides if a source is considered trusted or if warnings should be raised before e.g. packages are installed from this source."
       ],
       "type": "bool"
      },
      "types": {
       "choices": [
        "deb",
        "deb-src"
       ],
       "default": [
        "deb"
       ],
       "description": [
        "Which types of packages to look for from a given source; either binary V(deb) or source code V(deb-src)"
       ],
       "elements": "str",
       "type": "list"
      },
      "uris": {
       "description": [
        "The URIs must specify the base of the Debian distribution archive, from which APT finds the information it needs."
       ],
       "elements": "str",
       "type": "list"
      }
     },
     "requirements": [
      "python3-debian / python-debian"
     ],
     "short_description": "Add and remove deb822 formatted repositories",
     "version_added": "2.15",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Add debian repo\n  deb822_repository:\n    name: debian\n    types: deb\n    uris: http://deb.debian.org/debian\n    suites: stretch\n    components:\n      - main\n      - contrib\n      - non-free\n\n- name: Add debian repo with key\n  deb822_repository:\n    name: debian\n    types: deb\n    uris: https://deb.debian.org\n    suites: stable\n    components:\n      - main\n      - contrib\n      - non-free\n    signed_by: |-\n      -----BEGIN PGP PUBLIC KEY BLOCK-----\n\n      mDMEYCQjIxYJKwYBBAHaRw8BAQdAD/P5Nvvnvk66SxBBHDbhRml9ORg1WV5CvzKY\n      CuMfoIS0BmFiY2RlZoiQBBMWCgA4FiEErCIG1VhKWMWo2yfAREZd5NfO31cFAmAk\n      IyMCGyMFCwkIBwMFFQoJCAsFFgIDAQACHgECF4AACgkQREZd5NfO31fbOwD6ArzS\n      dM0Dkd5h2Ujy1b6KcAaVW9FOa5UNfJ9FFBtjLQEBAJ7UyWD3dZzhvlaAwunsk7DG\n      3bHcln8DMpIJVXht78sL\n      =IE0r\n      -----END PGP PUBLIC KEY BLOCK-----\n\n- name: Add repo using key from URL\n  deb822_repository:\n    name: example\n    types: deb\n    uris: https://download.example.com/linux/ubuntu\n    suites: '{{ ansible_distribution_release }}'\n    components: stable\n    architectures: amd64\n    signed_by: https://download.example.com/linux/ubuntu/gpg\n",
    "metadata": null,
    "return": {
     "dest": {
      "description": "Path to the repository file",
      "returned": "always",
      "sample": "/etc/apt/sources.list.d/focal-archive.sources",
      "type": "str"
     },
     "key_filename": {
      "description": "Path to the signed_by key file",
      "returned": "always",
      "sample": "/etc/apt/keyrings/debian.gpg",
      "type": "str"
     },
     "repo": {
      "description": "A source string for the repository",
      "returned": "always",
      "sample": "X-Repolib-Name: debian\nTypes: deb\nURIs: https://deb.debian.org\nSuites: stable\nComponents: main contrib non-free\nSigned-By:\n    -----BEGIN PGP PUBLIC KEY BLOCK-----\n    .\n    mDMEYCQjIxYJKwYBBAHaRw8BAQdAD/P5Nvvnvk66SxBBHDbhRml9ORg1WV5CvzKY\n    CuMfoIS0BmFiY2RlZoiQBBMWCgA4FiEErCIG1VhKWMWo2yfAREZd5NfO31cFAmAk\n    IyMCGyMFCwkIBwMFFQoJCAsFFgIDAQACHgECF4AACgkQREZd5NfO31fbOwD6ArzS\n    dM0Dkd5h2Ujy1b6KcAaVW9FOa5UNfJ9FFBtjLQEBAJ7UyWD3dZzhvlaAwunsk7DG\n    3bHcln8DMpIJVXht78sL\n    =IE0r\n    -----END PGP PUBLIC KEY BLOCK-----\n",
      "type": "str"
     }
    }
   },
   "ansible.builtin.debconf": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "full"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "debian",
       "support": "full"
      }
     },
     "author": [
      "Brian Coca (@bcoca)"
     ],
     "collection": "ansible.builtin",
     "description": [
      "Configure a .deb package using debconf-set-selections.",
      "Or just query existing selections."
     ],
     "filename": "/ansible/modules/debconf.py",
     "has_action": false,
     "module": "debconf",
     "notes": [
      "This module requires the command line debconf tools.",
      "Several questions have to be answered (depending on the package). Use 'debconf-show <package>' on any Debian or derivative with the package installed to see questions/settings available.",
      "Some distros will always record tasks involving the setting of passwords as changed. This is due to debconf-get-selections masking passwords.",
      "It is highly recommended to add C(no_log=True) to the task while handling sensitive information using this module.",
      "The debconf module does not reconfigure packages, it just updates the debconf database. An additional step is needed (typically with C(notify) if debconf makes a change) to reconfigure the package and apply the changes. debconf is extensively used for pre-seeding configuration prior to installation rather than modifying configurations. So, while dpkg-reconfigure does use debconf data, it is not always authoritative and you may need to check how your package is handled.",
      "Also note dpkg-reconfigure is a 3-phase process. It invokes the control scripts from the C(/var/lib/dpkg/info) directory with the C(<package>.prerm  reconfigure <version>), C(<package>.config reconfigure <version>) and C(<package>.postinst control <version>) arguments.",
      "The main issue is that the C(<package>.config reconfigure) step for many packages will first reset the debconf database (overriding changes made by this module) by checking the on-disk configuration. If this is the case for your package then dpkg-reconfigure will effectively ignore changes made by debconf.",
      "However as dpkg-reconfigure only executes the C(<package>.config) step if the file exists, it is possible to rename it to C(/var/lib/dpkg/info/<package>.config.ignore) before executing C(dpkg-reconfigure -f noninteractive <package>) and then restore it. This seems to be compliant with Debian policy for the .config file."
     ],
     "options": {
      "name": {
       "aliases": [
        "pkg"
       ],
       "description": [
        "Name of package to configure."
       ],
       "required": true,
       "type": "str"
      },
      "question": {
       "aliases": [
        "selection",
        "setting"
       ],
       "description": [
        "A debconf configuration setting."
       ],
       "type": "str"
      },
      "unseen": {
       "default": false,
       "description": [
        "Do not set 'seen' flag when pre-seeding."
       ],
       "type": "bool"
      },
      "value": {
       "aliases": [
        "answer"
       ],
       "description": [
        "Value to set the configuration to."
       ],
       "type": "str"
      },
      "vtype": {
       "choices": [
        "boolean",
        "error",
        "multiselect",
        "note",
        "password",
        "seen",
        "select",
        "string",
        "text",
        "title"
       ],
       "description": [
        "The type of the value supplied.",
        "It is highly recommended to add C(no_log=True) to task while specifying O(vtype=password).",
        "V(seen) was added in Ansible 2.2."
       ],
       "type": "str"
      }
     },
     "requirements": [
      "debconf",
      "debconf-utils"
     ],
     "short_description": "Configure a .deb package",
     "version_added": "1.6",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Set default locale to fr_FR.UTF-8\n  ansible.builtin.debconf:\n    name: locales\n    question: locales/default_environment_locale\n    value: fr_FR.UTF-8\n    vtype: select\n\n- name: Set to generate locales\n  ansible.builtin.debconf:\n    name: locales\n    question: locales/locales_to_be_generated\n    value: en_US.UTF-8 UTF-8, fr_FR.UTF-8 UTF-8\n    vtype: multiselect\n\n- name: Accept oracle license\n  ansible.builtin.debconf:\n    name: oracle-java7-installer\n    question: shared/accepted-oracle-license-v1-1\n    value: 'true'\n    vtype: select\n\n- name: Specifying package you can register/return the list of questions and current values\n  ansible.builtin.debconf:\n    name: tzdata\n\n- name: Pre-configure tripwire site passphrase\n  ansible.builtin.debconf:\n    name: tripwire\n    question: tripwire/site-passphrase\n    value: \"{{ site_passphrase }}\"\n    vtype: password\n  no_log: True\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.debug": {
    "doc": {
     "attributes": {
      "action": {
       "description": "Indicates this has a corresponding action plugin so some parts of the options can be executed on the controller",
       "support": "full"
      },
      "async": {
       "description": "Supports being used with the C(async) keyword",
       "support": "none"
      },
      "become": {
       "description": "Is usable alongside become keywords",
       "support": "none"
      },
      "bypass_host_loop": {
       "description": [
        "Forces a 'global' task that does not execute per host, this bypasses per host templating and serial, throttle and other loop considerations",
        "Conditionals will work as if C(run_once) is being used, variables used will be from the first available host",
        "This action will not work normally outside of lockstep strategies"
       ],
       "support": "none"
      },
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "connection": {
       "description": "Uses the target's configured connection information to execute code on it",
       "support": "none"
      },
      "delegation": {
       "description": "Can be used in conjunction with delegate_to and related keywords",
       "details": "Aside from C(register) and/or in combination with C(delegate_facts), it has little effect.",
       "support": "partial"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "all",
       "support": "full"
      }
     },
     "author": [
      "Dag Wieers (@dagwieers)",
      "Michael DeHaan"
     ],
     "collection": "ansible.builtin",
     "description": [
      "This module prints statements during execution and can be useful for debugging variables or expressions without necessarily halting the playbook.",
      "Useful for debugging together with the 'when:' directive.",
      "This module is also supported for Windows targets."
     ],
     "filename": "/ansible/modules/debug.py",
     "has_action": true,
     "module": "debug",
     "options": {
      "msg": {
       "default": "Hello world!",
       "description": [
        "The customized message that is printed. If omitted, prints a generic message."
       ],
       "type": "str"
      },
      "var": {
       "description": [
        "A variable name to debug.",
        "Mutually exclusive with the O(msg) option.",
        "Be aware that this option already runs in Jinja2 context and has an implicit C({{ }}) wrapping, so you should not be using Jinja2 delimiters unless you are looking for double interpolation."
       ],
       "type": "str"
      },
      "verbosity": {
       "default": 0,
       "description": [
        "A number that controls when the debug is run, if you set to 3 it will only run debug when -vvv or above."
       ],
       "type": "int",
       "version_added": "2.1",
       "version_added_collection": "ansible.builtin"
      }
     },
     "seealso": [
      {
       "module": "ansible.builtin.assert"
      },
      {
       "module": "ansible.builtin.fail"
      }
     ],
     "short_description": "Print statements during execution",
     "version_added": "0.8",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Print the gateway for each host when defined\n  ansible.builtin.debug:\n    msg: System {{ inventory_hostname }} has gateway {{ ansible_default_ipv4.gateway }}\n  when: ansible_default_ipv4.gateway is defined\n\n- name: Get uptime information\n  ansible.builtin.shell: /usr/bin/uptime\n  register: result\n\n- name: Print return information from the previous task\n  ansible.builtin.debug:\n    var: result\n    verbosity: 2\n\n- name: Display all variables/facts known for a host\n  ansible.builtin.debug:\n    var: hostvars[inventory_hostname]\n    verbosity: 4\n\n- name: Prints two lines of messages, but only if there is an environment value set\n  ansible.builtin.debug:\n    msg:\n    - \"Provisioning based on YOUR_KEY which is: {{ lookup('ansible.builtin.env', 'YOUR_KEY') }}\"\n    - \"These servers were built using the password of '{{ password_used }}'. Please retain this for later use.\"\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.dnf": {
    "doc": {
     "attributes": {
      "action": {
       "description": "Indicates this has a corresponding action plugin so some parts of the options can be executed on the controller",
       "details": "dnf has 2 action plugins that use it under the hood, M(ansible.builtin.dnf) and M(ansible.builtin.package).",
       "support": "partial"
      },
      "async": {
       "description": "Supports being used with the C(async) keyword",
       "support": "none"
      },
      "bypass_host_loop": {
       "description": [
        "Forces a 'global' task that does not execute per host, this bypasses per host templating and serial, throttle and other loop considerations",
        "Conditionals will work as if C(run_once) is being used, variables used will be from the first available host",
        "This action will not work normally outside of lockstep strategies"
       ],
       "support": "none"
      },
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "full"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "rhel",
       "support": "N/A"
      }
     },
     "author": [
      "Igor Gnatenko (@ignatenkobrain) <i.gnatenko.brain@gmail.com>",
      "Cristian van Ee (@DJMuggs) <cristian at cvee.org>",
      "Berend De Schouwer (@berenddeschouwer)",
      "Adam Miller (@maxamillion) <admiller@redhat.com>"
     ],
     "collection": "ansible.builtin",
     "description": [
      "Installs, upgrade, removes, and lists packages and groups with the I(dnf) package manager."
     ],
     "filename": "/ansible/modules/dnf.py",
     "has_action": true,
     "module": "dnf",
     "notes": [
      "When used with a C(loop:) each package will be processed individually, it is much more efficient to pass the list directly to the I(name) option.",
      "Group removal doesn't work if the group was installed with Ansible because upstream dnf's API doesn't properly mark groups as installed, therefore upon removal the module is unable to detect that the group is installed (https://bugzilla.redhat.com/show_bug.cgi?id=1620324)"
     ],
     "options": {
      "allow_downgrade": {
       "default": "no",
       "description": [
        "Specify if the named package and version is allowed to downgrade a maybe already installed higher version of that package. Note that setting allow_downgrade=True can make this module behave in a non-idempotent way. The task could end up with a set of packages that does not match the complete list of specified packages to install (because dependencies between the downgraded package and others can cause changes to the packages which were in the earlier transaction)."
       ],
       "type": "bool",
       "version_added": "2.7",
       "version_added_collection": "ansible.builtin"
      },
      "allowerasing": {
       "default": "no",
       "description": [
        "If V(true) it allows  erasing  of  installed  packages to resolve dependencies."
       ],
       "required": false,
       "type": "bool",
       "version_added": "2.10",
       "version_added_collection": "ansible.builtin"
      },
      "autoremove": {
       "default": "no",
       "description": [
        "If V(true), removes all \"leaf\" packages from the system that were originally installed as dependencies of user-installed packages but which are no longer required by any such package. Should be used alone or when O(state) is V(absent)"
       ],
       "type": "bool",
       "version_added": "2.4",
       "version_added_collection": "ansible.builtin"
      },
      "bugfix": {
       "default": "no",
       "description": [
        "If set to V(true), and O(state=latest) then only installs updates that have been marked bugfix related.",
        "Note that, similar to C(dnf upgrade-minimal), this filter applies to dependencies as well."
       ],
       "type": "bool",
       "version_added": "2.7",
       "version_added_collection": "ansible.builtin"
      },
      "cacheonly": {
       "default": "no",
       "description": [
        "Tells dnf to run entirely from system cache; does not download or update metadata."
       ],
       "type": "bool",
       "version_added": "2.12",
       "version_added_collection": "ansible.builtin"
      },
      "conf_file": {
       "description": [
        "The remote dnf configuration file to use for the transaction."
       ],
       "type": "str"
      },
      "disable_excludes": {
       "description": [
        "Disable the excludes defined in DNF config files.",
        "If set to V(all), disables all excludes.",
        "If set to V(main), disable excludes defined in [main] in dnf.conf.",
        "If set to V(repoid), disable excludes defined for given repo id."
       ],
       "type": "str",
       "version_added": "2.7",
       "version_added_collection": "ansible.builtin"
      },
      "disable_gpg_check": {
       "default": "no",
       "description": [
        "Whether to disable the GPG checking of signatures of packages being installed. Has an effect only if O(state) is V(present) or V(latest).",
        "This setting affects packages installed from a repository as well as \"local\" packages installed from the filesystem or a URL."
       ],
       "type": "bool"
      },
      "disable_plugin": {
       "default": [],
       "description": [
        "I(Plugin) name to disable for the install/update operation. The disabled plugins will not persist beyond the transaction."
       ],
       "elements": "str",
       "type": "list",
       "version_added": "2.7",
       "version_added_collection": "ansible.builtin"
      },
      "disablerepo": {
       "default": [],
       "description": [
        "I(Repoid) of repositories to disable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a \",\"."
       ],
       "elements": "str",
       "type": "list"
      },
      "download_dir": {
       "description": [
        "Specifies an alternate directory to store packages.",
        "Has an effect only if O(download_only) is specified."
       ],
       "type": "str",
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      },
      "download_only": {
       "default": "no",
       "description": [
        "Only download the packages, do not install them."
       ],
       "type": "bool",
       "version_added": "2.7",
       "version_added_collection": "ansible.builtin"
      },
      "enable_plugin": {
       "default": [],
       "description": [
        "I(Plugin) name to enable for the install/update operation. The enabled plugin will not persist beyond the transaction."
       ],
       "elements": "str",
       "type": "list",
       "version_added": "2.7",
       "version_added_collection": "ansible.builtin"
      },
      "enablerepo": {
       "default": [],
       "description": [
        "I(Repoid) of repositories to enable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a \",\"."
       ],
       "elements": "str",
       "type": "list"
      },
      "exclude": {
       "default": [],
       "description": [
        "Package name(s) to exclude when state=present, or latest. This can be a list or a comma separated string."
       ],
       "elements": "str",
       "type": "list",
       "version_added": "2.7",
       "version_added_collection": "ansible.builtin"
      },
      "install_repoquery": {
       "default": "yes",
       "description": [
        "This is effectively a no-op in DNF as it is not needed with DNF.",
        "This option is deprecated and will be removed in ansible-core 2.20."
       ],
       "type": "bool",
       "version_added": "2.7",
       "version_added_collection": "ansible.builtin"
      },
      "install_weak_deps": {
       "default": "yes",
       "description": [
        "Will also install all packages linked by a weak dependency relation."
       ],
       "type": "bool",
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      },
      "installroot": {
       "default": "/",
       "description": [
        "Specifies an alternative installroot, relative to which all packages will be installed."
       ],
       "type": "str",
       "version_added": "2.3",
       "version_added_collection": "ansible.builtin"
      },
      "list": {
       "description": [
        "Various (non-idempotent) commands for usage with C(/usr/bin/ansible) and I(not) playbooks. Use M(ansible.builtin.package_facts) instead of the O(list) argument as a best practice."
       ],
       "type": "str"
      },
      "lock_timeout": {
       "default": 30,
       "description": [
        "Amount of time to wait for the dnf lockfile to be freed."
       ],
       "required": false,
       "type": "int",
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      },
      "name": {
       "aliases": [
        "pkg"
       ],
       "default": [],
       "description": [
        "A package name or package specifier with version, like C(name-1.0). When using state=latest, this can be '*' which means run: dnf -y update. You can also pass a url or a local path to an rpm file. To operate on several packages this can accept a comma separated string of packages or a list of packages.",
        "Comparison operators for package version are valid here C(>), C(<), C(>=), C(<=). Example - C(name >= 1.0). Spaces around the operator are required.",
        "You can also pass an absolute path for a binary which is provided by the package to install. See examples for more information."
       ],
       "elements": "str",
       "type": "list"
      },
      "nobest": {
       "default": "no",
       "description": [
        "Set best option to False, so that transactions are not limited to best candidates only."
       ],
       "required": false,
       "type": "bool",
       "version_added": "2.11",
       "version_added_collection": "ansible.builtin"
      },
      "releasever": {
       "description": [
        "Specifies an alternative release from which all packages will be installed."
       ],
       "type": "str",
       "version_added": "2.6",
       "version_added_collection": "ansible.builtin"
      },
      "security": {
       "default": "no",
       "description": [
        "If set to V(true), and O(state=latest) then only installs updates that have been marked security related.",
        "Note that, similar to C(dnf upgrade-minimal), this filter applies to dependencies as well."
       ],
       "type": "bool",
       "version_added": "2.7",
       "version_added_collection": "ansible.builtin"
      },
      "skip_broken": {
       "default": "no",
       "description": [
        "Skip all unavailable packages or packages with broken dependencies without raising an error. Equivalent to passing the --skip-broken option."
       ],
       "type": "bool",
       "version_added": "2.7",
       "version_added_collection": "ansible.builtin"
      },
      "sslverify": {
       "default": "yes",
       "description": [
        "Disables SSL validation of the repository server for this transaction.",
        "This should be set to V(false) if one of the configured repositories is using an untrusted or self-signed certificate."
       ],
       "type": "bool",
       "version_added": "2.13",
       "version_added_collection": "ansible.builtin"
      },
      "state": {
       "choices": [
        "absent",
        "present",
        "installed",
        "removed",
        "latest"
       ],
       "description": [
        "Whether to install (V(present), V(latest)), or remove (V(absent)) a package.",
        "Default is V(None), however in effect the default action is V(present) unless the O(autoremove) option is enabled for this module, then V(absent) is inferred."
       ],
       "type": "str"
      },
      "update_cache": {
       "aliases": [
        "expire-cache"
       ],
       "default": "no",
       "description": [
        "Force dnf to check if cache is out of date and redownload if needed. Has an effect only if O(state) is V(present) or V(latest)."
       ],
       "type": "bool",
       "version_added": "2.7",
       "version_added_collection": "ansible.builtin"
      },
      "update_only": {
       "default": "no",
       "description": [
        "When using latest, only update installed packages. Do not install packages.",
        "Has an effect only if O(state) is V(latest)"
       ],
       "type": "bool",
       "version_added": "2.7",
       "version_added_collection": "ansible.builtin"
      },
      "use_backend": {
       "choices": [
        "auto",
        "yum",
        "yum4",
        "dnf4",
        "dnf5"
       ],
       "default": "auto",
       "description": [
        "By default, this module will select the backend based on the C(ansible_pkg_mgr) fact."
       ],
       "type": "str",
       "version_added": 2.15,
       "version_added_collection": "ansible.builtin"
      },
      "validate_certs": {
       "default": "yes",
       "description": [
        "This only applies if using a https url as the source of the rpm. e.g. for localinstall. If set to V(false), the SSL certificates will not be validated.",
        "This should only set to V(false) used on personally controlled sites using self-signed certificates as it avoids verifying the source site."
       ],
       "type": "bool",
       "version_added": "2.7",
       "version_added_collection": "ansible.builtin"
      }
     },
     "requirements": [
      "python >= 2.6",
      "python-dnf",
      "for the autoremove option you need dnf >= 2.0.1\""
     ],
     "short_description": "Manages packages with the I(dnf) package manager",
     "version_added": 1.9,
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Install the latest version of Apache\n  ansible.builtin.dnf:\n    name: httpd\n    state: latest\n\n- name: Install Apache >= 2.4\n  ansible.builtin.dnf:\n    name: httpd >= 2.4\n    state: present\n\n- name: Install the latest version of Apache and MariaDB\n  ansible.builtin.dnf:\n    name:\n      - httpd\n      - mariadb-server\n    state: latest\n\n- name: Remove the Apache package\n  ansible.builtin.dnf:\n    name: httpd\n    state: absent\n\n- name: Install the latest version of Apache from the testing repo\n  ansible.builtin.dnf:\n    name: httpd\n    enablerepo: testing\n    state: present\n\n- name: Upgrade all packages\n  ansible.builtin.dnf:\n    name: \"*\"\n    state: latest\n\n- name: Update the webserver, depending on which is installed on the system. Do not install the other one\n  ansible.builtin.dnf:\n    name:\n      - httpd\n      - nginx\n    state: latest\n    update_only: yes\n\n- name: Install the nginx rpm from a remote repo\n  ansible.builtin.dnf:\n    name: 'http://nginx.org/packages/centos/6/noarch/RPMS/nginx-release-centos-6-0.el6.ngx.noarch.rpm'\n    state: present\n\n- name: Install nginx rpm from a local file\n  ansible.builtin.dnf:\n    name: /usr/local/src/nginx-release-centos-6-0.el6.ngx.noarch.rpm\n    state: present\n\n- name: Install Package based upon the file it provides\n  ansible.builtin.dnf:\n    name: /usr/bin/cowsay\n    state: present\n\n- name: Install the 'Development tools' package group\n  ansible.builtin.dnf:\n    name: '@Development tools'\n    state: present\n\n- name: Autoremove unneeded packages installed as dependencies\n  ansible.builtin.dnf:\n    autoremove: yes\n\n- name: Uninstall httpd but keep its dependencies\n  ansible.builtin.dnf:\n    name: httpd\n    state: absent\n    autoremove: no\n\n- name: Install a modularity appstream with defined stream and profile\n  ansible.builtin.dnf:\n    name: '@postgresql:9.6/client'\n    state: present\n\n- name: Install a modularity appstream with defined stream\n  ansible.builtin.dnf:\n    name: '@postgresql:9.6'\n    state: present\n\n- name: Install a modularity appstream with defined profile\n  ansible.builtin.dnf:\n    name: '@postgresql/client'\n    state: present\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.dnf5": {
    "doc": {
     "attributes": {
      "action": {
       "description": "Indicates this has a corresponding action plugin so some parts of the options can be executed on the controller",
       "details": "dnf5 has 2 action plugins that use it under the hood, M(ansible.builtin.dnf) and M(ansible.builtin.package).",
       "support": "partial"
      },
      "async": {
       "description": "Supports being used with the C(async) keyword",
       "support": "none"
      },
      "bypass_host_loop": {
       "description": [
        "Forces a 'global' task that does not execute per host, this bypasses per host templating and serial, throttle and other loop considerations",
        "Conditionals will work as if C(run_once) is being used, variables used will be from the first available host",
        "This action will not work normally outside of lockstep strategies"
       ],
       "support": "none"
      },
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "full"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "rhel",
       "support": "N/A"
      }
     },
     "author": "Ansible Core Team",
     "collection": "ansible.builtin",
     "description": [
      "Installs, upgrade, removes, and lists packages and groups with the I(dnf5) package manager.",
      "WARNING: The I(dnf5) package manager is still under development and not all features that the existing M(ansible.builtin.dnf) module provides are implemented in M(ansible.builtin.dnf5), please consult specific options for more information."
     ],
     "filename": "/ansible/modules/dnf5.py",
     "has_action": false,
     "module": "dnf5",
     "options": {
      "allow_downgrade": {
       "default": "no",
       "description": [
        "Specify if the named package and version is allowed to downgrade a maybe already installed higher version of that package. Note that setting allow_downgrade=True can make this module behave in a non-idempotent way. The task could end up with a set of packages that does not match the complete list of specified packages to install (because dependencies between the downgraded package and others can cause changes to the packages which were in the earlier transaction)."
       ],
       "type": "bool"
      },
      "allowerasing": {
       "default": "no",
       "description": [
        "If V(true) it allows  erasing  of  installed  packages to resolve dependencies."
       ],
       "required": false,
       "type": "bool"
      },
      "autoremove": {
       "default": "no",
       "description": [
        "If V(true), removes all \"leaf\" packages from the system that were originally installed as dependencies of user-installed packages but which are no longer required by any such package. Should be used alone or when O(state) is V(absent)"
       ],
       "type": "bool"
      },
      "bugfix": {
       "default": "no",
       "description": [
        "If set to V(true), and O(state=latest) then only installs updates that have been marked bugfix related.",
        "Note that, similar to C(dnf upgrade-minimal), this filter applies to dependencies as well."
       ],
       "type": "bool"
      },
      "cacheonly": {
       "default": "no",
       "description": [
        "Tells dnf to run entirely from system cache; does not download or update metadata."
       ],
       "type": "bool"
      },
      "conf_file": {
       "description": [
        "The remote dnf configuration file to use for the transaction."
       ],
       "type": "str"
      },
      "disable_excludes": {
       "description": [
        "Disable the excludes defined in DNF config files.",
        "If set to V(all), disables all excludes.",
        "If set to V(main), disable excludes defined in [main] in dnf.conf.",
        "If set to V(repoid), disable excludes defined for given repo id."
       ],
       "type": "str"
      },
      "disable_gpg_check": {
       "default": "no",
       "description": [
        "Whether to disable the GPG checking of signatures of packages being installed. Has an effect only if O(state) is V(present) or V(latest).",
        "This setting affects packages installed from a repository as well as \"local\" packages installed from the filesystem or a URL."
       ],
       "type": "bool"
      },
      "disable_plugin": {
       "default": [],
       "description": [
        "This is currently a no-op as dnf5 itself does not implement this feature.",
        "I(Plugin) name to disable for the install/update operation. The disabled plugins will not persist beyond the transaction."
       ],
       "elements": "str",
       "type": "list"
      },
      "disablerepo": {
       "default": [],
       "description": [
        "I(Repoid) of repositories to disable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a \",\"."
       ],
       "elements": "str",
       "type": "list"
      },
      "download_dir": {
       "description": [
        "Specifies an alternate directory to store packages.",
        "Has an effect only if O(download_only) is specified."
       ],
       "type": "str"
      },
      "download_only": {
       "default": "no",
       "description": [
        "Only download the packages, do not install them."
       ],
       "type": "bool"
      },
      "enable_plugin": {
       "default": [],
       "description": [
        "This is currently a no-op as dnf5 itself does not implement this feature.",
        "I(Plugin) name to enable for the install/update operation. The enabled plugin will not persist beyond the transaction."
       ],
       "elements": "str",
       "type": "list"
      },
      "enablerepo": {
       "default": [],
       "description": [
        "I(Repoid) of repositories to enable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a \",\"."
       ],
       "elements": "str",
       "type": "list"
      },
      "exclude": {
       "default": [],
       "description": [
        "Package name(s) to exclude when state=present, or latest. This can be a list or a comma separated string."
       ],
       "elements": "str",
       "type": "list"
      },
      "install_repoquery": {
       "default": "yes",
       "description": [
        "This is effectively a no-op in DNF as it is not needed with DNF.",
        "This option is deprecated and will be removed in ansible-core 2.20."
       ],
       "type": "bool"
      },
      "install_weak_deps": {
       "default": "yes",
       "description": [
        "Will also install all packages linked by a weak dependency relation."
       ],
       "type": "bool"
      },
      "installroot": {
       "default": "/",
       "description": [
        "Specifies an alternative installroot, relative to which all packages will be installed."
       ],
       "type": "str"
      },
      "list": {
       "description": [
        "Various (non-idempotent) commands for usage with C(/usr/bin/ansible) and I(not) playbooks. Use M(ansible.builtin.package_facts) instead of the O(list) argument as a best practice."
       ],
       "type": "str"
      },
      "lock_timeout": {
       "default": 30,
       "description": [
        "This is currently a no-op as dnf5 does not provide an option to configure it.",
        "Amount of time to wait for the dnf lockfile to be freed."
       ],
       "required": false,
       "type": "int"
      },
      "name": {
       "aliases": [
        "pkg"
       ],
       "default": [],
       "description": [
        "A package name or package specifier with version, like C(name-1.0). When using state=latest, this can be '*' which means run: dnf -y update. You can also pass a url or a local path to an rpm file. To operate on several packages this can accept a comma separated string of packages or a list of packages.",
        "Comparison operators for package version are valid here C(>), C(<), C(>=), C(<=). Example - C(name >= 1.0). Spaces around the operator are required.",
        "You can also pass an absolute path for a binary which is provided by the package to install. See examples for more information."
       ],
       "elements": "str",
       "type": "list"
      },
      "nobest": {
       "default": "no",
       "description": [
        "Set best option to False, so that transactions are not limited to best candidates only."
       ],
       "required": false,
       "type": "bool"
      },
      "releasever": {
       "description": [
        "Specifies an alternative release from which all packages will be installed."
       ],
       "type": "str"
      },
      "security": {
       "default": "no",
       "description": [
        "If set to V(true), and O(state=latest) then only installs updates that have been marked security related.",
        "Note that, similar to C(dnf upgrade-minimal), this filter applies to dependencies as well."
       ],
       "type": "bool"
      },
      "skip_broken": {
       "default": "no",
       "description": [
        "Skip all unavailable packages or packages with broken dependencies without raising an error. Equivalent to passing the --skip-broken option."
       ],
       "type": "bool"
      },
      "sslverify": {
       "default": "yes",
       "description": [
        "Disables SSL validation of the repository server for this transaction.",
        "This should be set to V(false) if one of the configured repositories is using an untrusted or self-signed certificate."
       ],
       "type": "bool"
      },
      "state": {
       "choices": [
        "absent",
        "present",
        "installed",
        "removed",
        "latest"
       ],
       "description": [
        "Whether to install (V(present), V(latest)), or remove (V(absent)) a package.",
        "Default is V(None), however in effect the default action is V(present) unless the V(autoremove) option is enabled for this module, then V(absent) is inferred."
       ],
       "type": "str"
      },
      "update_cache": {
       "aliases": [
        "expire-cache"
       ],
       "default": "no",
       "description": [
        "Force dnf to check if cache is out of date and redownload if needed. Has an effect only if O(state) is V(present) or V(latest)."
       ],
       "type": "bool"
      },
      "update_only": {
       "default": "no",
       "description": [
        "When using latest, only update installed packages. Do not install packages.",
        "Has an effect only if O(state) is V(latest)"
       ],
       "type": "bool"
      },
      "validate_certs": {
       "default": "yes",
       "description": [
        "This is effectively a no-op in the dnf5 module as dnf5 itself handles downloading a https url as the source of the rpm, but is an accepted parameter for feature parity/compatibility with the M(ansible.builtin.dnf) module."
       ],
       "type": "bool"
      }
     },
     "requirements": [
      "python3",
      "python3-libdnf5"
     ],
     "short_description": "Manages packages with the I(dnf5) package manager",
     "version_added": 2.15,
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Install the latest version of Apache\n  ansible.builtin.dnf5:\n    name: httpd\n    state: latest\n\n- name: Install Apache >= 2.4\n  ansible.builtin.dnf5:\n    name: httpd >= 2.4\n    state: present\n\n- name: Install the latest version of Apache and MariaDB\n  ansible.builtin.dnf5:\n    name:\n      - httpd\n      - mariadb-server\n    state: latest\n\n- name: Remove the Apache package\n  ansible.builtin.dnf5:\n    name: httpd\n    state: absent\n\n- name: Install the latest version of Apache from the testing repo\n  ansible.builtin.dnf5:\n    name: httpd\n    enablerepo: testing\n    state: present\n\n- name: Upgrade all packages\n  ansible.builtin.dnf5:\n    name: \"*\"\n    state: latest\n\n- name: Update the webserver, depending on which is installed on the system. Do not install the other one\n  ansible.builtin.dnf5:\n    name:\n      - httpd\n      - nginx\n    state: latest\n    update_only: yes\n\n- name: Install the nginx rpm from a remote repo\n  ansible.builtin.dnf5:\n    name: 'http://nginx.org/packages/centos/6/noarch/RPMS/nginx-release-centos-6-0.el6.ngx.noarch.rpm'\n    state: present\n\n- name: Install nginx rpm from a local file\n  ansible.builtin.dnf5:\n    name: /usr/local/src/nginx-release-centos-6-0.el6.ngx.noarch.rpm\n    state: present\n\n- name: Install Package based upon the file it provides\n  ansible.builtin.dnf5:\n    name: /usr/bin/cowsay\n    state: present\n\n- name: Install the 'Development tools' package group\n  ansible.builtin.dnf5:\n    name: '@Development tools'\n    state: present\n\n- name: Autoremove unneeded packages installed as dependencies\n  ansible.builtin.dnf5:\n    autoremove: yes\n\n- name: Uninstall httpd but keep its dependencies\n  ansible.builtin.dnf5:\n    name: httpd\n    state: absent\n    autoremove: no\n",
    "metadata": null,
    "return": {
     "failures": {
      "description": "A list of the dnf transaction failures",
      "returned": "failure",
      "sample": [
       "Argument 'lsof' matches only excluded packages."
      ],
      "type": "list"
     },
     "msg": {
      "description": "Additional information about the result",
      "returned": "always",
      "sample": "Nothing to do",
      "type": "str"
     },
     "rc": {
      "description": "For compatibility, 0 for success, 1 for failure",
      "returned": "always",
      "sample": 0,
      "type": "int"
     },
     "results": {
      "description": "A list of the dnf transaction results",
      "returned": "success",
      "sample": [
       "Installed: lsof-4.94.0-4.fc37.x86_64"
      ],
      "type": "list"
     }
    }
   },
   "ansible.builtin.dpkg_selections": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "full"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "debian",
       "support": "full"
      }
     },
     "author": [
      "Brian Brazil (@brian-brazil)  <brian.brazil@boxever.com>"
     ],
     "collection": "ansible.builtin",
     "description": [
      "Change dpkg package selection state via --get-selections and --set-selections."
     ],
     "filename": "/ansible/modules/dpkg_selections.py",
     "has_action": false,
     "module": "dpkg_selections",
     "notes": [
      "This module will not cause any packages to be installed/removed/purged, use the M(ansible.builtin.apt) module for that."
     ],
     "options": {
      "name": {
       "description": [
        "Name of the package."
       ],
       "required": true,
       "type": "str"
      },
      "selection": {
       "choices": [
        "install",
        "hold",
        "deinstall",
        "purge"
       ],
       "description": [
        "The selection state to set the package to."
       ],
       "required": true,
       "type": "str"
      }
     },
     "short_description": "Dpkg package selection selections",
     "version_added": "2.0",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Prevent python from being upgraded\n  ansible.builtin.dpkg_selections:\n    name: python\n    selection: hold\n\n- name: Allow python to be upgraded\n  ansible.builtin.dpkg_selections:\n    name: python\n    selection: install\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.expect": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "none"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "full"
      }
     },
     "author": "Matt Martz (@sivel)",
     "collection": "ansible.builtin",
     "description": [
      "The M(ansible.builtin.expect) module executes a command and responds to prompts.",
      "The given command will be executed on all selected nodes. It will not be processed through the shell, so variables like C($HOME) and operations like C(\"<\"), C(\">\"), C(\"|\"), and C(\"&\") will not work."
     ],
     "filename": "/ansible/modules/expect.py",
     "has_action": false,
     "module": "expect",
     "notes": [
      "If you want to run a command through the shell (say you are using C(<), C(>), C(|), and so on), you must specify a shell in the command such as C(/bin/bash -c \"/path/to/something | grep else\").",
      "Case insensitive searches are indicated with a prefix of C(?i).",
      "The C(pexpect) library used by this module operates with a search window of 2000 bytes, and does not use a multiline regex match. To perform a start of line bound match, use a pattern like ``(?m)^pattern``",
      "The M(ansible.builtin.expect) module is designed for simple scenarios. For more complex needs, consider the use of expect code with the M(ansible.builtin.shell) or M(ansible.builtin.script) modules. (An example is part of the M(ansible.builtin.shell) module documentation).",
      "If the command returns non UTF-8 data, it must be encoded to avoid issues. One option is to pipe the output through C(base64)."
     ],
     "options": {
      "chdir": {
       "description": [
        "Change into this directory before running the command."
       ],
       "type": "path"
      },
      "command": {
       "description": [
        "The command module takes command to run."
       ],
       "required": true,
       "type": "str"
      },
      "creates": {
       "description": [
        "A filename, when it already exists, this step will B(not) be run."
       ],
       "type": "path"
      },
      "echo": {
       "default": false,
       "description": [
        "Whether or not to echo out your response strings."
       ],
       "type": "bool"
      },
      "removes": {
       "description": [
        "A filename, when it does not exist, this step will B(not) be run."
       ],
       "type": "path"
      },
      "responses": {
       "description": [
        "Mapping of prompt regular expressions and corresponding answer(s).",
        "Each key in O(responses) is a Python regex U(https://docs.python.org/3/library/re.html#regular-expression-syntax).",
        "The value of each key is a string or list of strings. If the value is a string and the prompt is encountered multiple times, the answer will be repeated. Provide the value as a list to give different answers for successive matches."
       ],
       "required": true,
       "type": "dict"
      },
      "timeout": {
       "default": 30,
       "description": [
        "Amount of time in seconds to wait for the expected strings. Use V(null) to disable timeout."
       ],
       "type": "raw"
      }
     },
     "requirements": [
      "python >= 2.6",
      "pexpect >= 3.3"
     ],
     "seealso": [
      {
       "module": "ansible.builtin.script"
      },
      {
       "module": "ansible.builtin.shell"
      }
     ],
     "short_description": "Executes a command and responds to prompts",
     "version_added": "2.0",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Case insensitive password string match\n  ansible.builtin.expect:\n    command: passwd username\n    responses:\n      (?i)password: \"MySekretPa$$word\"\n  # you don't want to show passwords in your logs\n  no_log: true\n\n- name: Match multiple regular expressions and demonstrate individual and repeated responses\n  ansible.builtin.expect:\n    command: /path/to/custom/command\n    responses:\n      Question:\n        # give a unique response for each of the 3 hypothetical prompts matched\n        - response1\n        - response2\n        - response3\n      # give the same response for every matching prompt\n      \"^Match another prompt$\": \"response\"\n\n- name: Multiple questions with responses\n  ansible.builtin.expect:\n    command: /path/to/custom/command\n    responses:\n        \"Please provide your name\":\n            - \"Anna\"\n        \"Database user\":\n            - \"{{ db_username }}\"\n        \"Database password\":\n            - \"{{ db_password }}\"\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.fail": {
    "doc": {
     "attributes": {
      "action": {
       "description": "Indicates this has a corresponding action plugin so some parts of the options can be executed on the controller",
       "support": "full"
      },
      "async": {
       "description": "Supports being used with the C(async) keyword",
       "support": "none"
      },
      "become": {
       "description": "Is usable alongside become keywords",
       "support": "none"
      },
      "bypass_host_loop": {
       "description": [
        "Forces a 'global' task that does not execute per host, this bypasses per host templating and serial, throttle and other loop considerations",
        "Conditionals will work as if C(run_once) is being used, variables used will be from the first available host",
        "This action will not work normally outside of lockstep strategies"
       ],
       "support": "none"
      },
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "connection": {
       "description": "Uses the target's configured connection information to execute code on it",
       "support": "none"
      },
      "delegation": {
       "description": "Can be used in conjunction with delegate_to and related keywords",
       "details": "Aside from C(register) and/or in combination with C(delegate_facts), it has little effect.",
       "support": "partial"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "all",
       "support": "N/A"
      }
     },
     "author": [
      "Dag Wieers (@dagwieers)"
     ],
     "collection": "ansible.builtin",
     "description": [
      "This module fails the progress with a custom message.",
      "It can be useful for bailing out when a certain condition is met using C(when).",
      "This module is also supported for Windows targets."
     ],
     "filename": "/ansible/modules/fail.py",
     "has_action": true,
     "module": "fail",
     "options": {
      "msg": {
       "default": "Failed as requested from task",
       "description": [
        "The customized message used for failing execution.",
        "If omitted, fail will simply bail out with a generic message."
       ],
       "type": "str"
      }
     },
     "seealso": [
      {
       "module": "ansible.builtin.assert"
      },
      {
       "module": "ansible.builtin.debug"
      },
      {
       "module": "ansible.builtin.meta"
      }
     ],
     "short_description": "Fail with custom message",
     "version_added": "0.8",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Example using fail and when together\n  ansible.builtin.fail:\n    msg: The system may not be provisioned according to the CMDB status.\n  when: cmdb_status != \"to-be-staged\"\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.fetch": {
    "doc": {
     "attributes": {
      "action": {
       "description": "Indicates this has a corresponding action plugin so some parts of the options can be executed on the controller",
       "support": "full"
      },
      "async": {
       "description": "Supports being used with the C(async) keyword",
       "support": "none"
      },
      "bypass_host_loop": {
       "description": [
        "Forces a 'global' task that does not execute per host, this bypasses per host templating and serial, throttle and other loop considerations",
        "Conditionals will work as if C(run_once) is being used, variables used will be from the first available host",
        "This action will not work normally outside of lockstep strategies"
       ],
       "support": "none"
      },
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "full"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix, windows",
       "support": "N/A"
      },
      "safe_file_operations": {
       "description": "Uses Ansible's strict file operation functions to ensure proper permissions and avoid data corruption",
       "support": "none"
      },
      "vault": {
       "description": "Can automatically decrypt Ansible vaulted files",
       "support": "none"
      }
     },
     "author": [
      "Ansible Core Team",
      "Michael DeHaan"
     ],
     "collection": "ansible.builtin",
     "description": [
      "This module works like M(ansible.builtin.copy), but in reverse.",
      "It is used for fetching files from remote machines and storing them locally in a file tree, organized by hostname.",
      "Files that already exist at O(dest) will be overwritten if they are different than the O(src).",
      "This module is also supported for Windows targets."
     ],
     "filename": "/ansible/modules/fetch.py",
     "has_action": true,
     "module": "fetch",
     "notes": [
      "When running fetch with C(become), the M(ansible.builtin.slurp) module will also be used to fetch the contents of the file for determining the remote checksum. This effectively doubles the transfer size, and depending on the file size can consume all available memory on the remote or local hosts causing a C(MemoryError). Due to this it is advisable to run this module without C(become) whenever possible.",
      "Prior to Ansible 2.5 this module would not fail if reading the remote file was impossible unless O(fail_on_missing) was set.",
      "In Ansible 2.5 or later, playbook authors are encouraged to use C(fail_when) or C(ignore_errors) to get this ability. They may also explicitly set O(fail_on_missing) to V(false) to get the non-failing behaviour."
     ],
     "options": {
      "dest": {
       "description": [
        "A directory to save the file into.",
        "For example, if the O(dest) directory is C(/backup) a O(src) file named C(/etc/profile) on host C(host.example.com), would be saved into C(/backup/host.example.com/etc/profile). The host name is based on the inventory name."
       ],
       "required": true
      },
      "fail_on_missing": {
       "default": true,
       "description": [
        "When set to V(true), the task will fail if the remote file cannot be read for any reason.",
        "Prior to Ansible 2.5, setting this would only fail if the source file was missing.",
        "The default was changed to V(true) in Ansible 2.5."
       ],
       "type": "bool",
       "version_added": "1.1",
       "version_added_collection": "ansible.builtin"
      },
      "flat": {
       "default": false,
       "description": [
        "Allows you to override the default behavior of appending hostname/path/to/file to the destination.",
        "If O(dest) ends with '/', it will use the basename of the source file, similar to the copy module.",
        "This can be useful if working with a single host, or if retrieving files that are uniquely named per host.",
        "If using multiple hosts with the same filename, the file will be overwritten for each host."
       ],
       "type": "bool",
       "version_added": "1.2",
       "version_added_collection": "ansible.builtin"
      },
      "src": {
       "description": [
        "The file on the remote system to fetch.",
        "This I(must) be a file, not a directory.",
        "Recursive fetching may be supported in a later release."
       ],
       "required": true
      },
      "validate_checksum": {
       "default": true,
       "description": [
        "Verify that the source and destination checksums match after the files are fetched."
       ],
       "type": "bool",
       "version_added": "1.4",
       "version_added_collection": "ansible.builtin"
      }
     },
     "seealso": [
      {
       "module": "ansible.builtin.copy"
      },
      {
       "module": "ansible.builtin.slurp"
      }
     ],
     "short_description": "Fetch files from remote nodes",
     "version_added": "0.2",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Store file into /tmp/fetched/host.example.com/tmp/somefile\n  ansible.builtin.fetch:\n    src: /tmp/somefile\n    dest: /tmp/fetched\n\n- name: Specifying a path directly\n  ansible.builtin.fetch:\n    src: /tmp/somefile\n    dest: /tmp/prefix-{{ inventory_hostname }}\n    flat: yes\n\n- name: Specifying a destination path\n  ansible.builtin.fetch:\n    src: /tmp/uniquefile\n    dest: /tmp/special/\n    flat: yes\n\n- name: Storing in a path relative to the playbook\n  ansible.builtin.fetch:\n    src: /tmp/uniquefile\n    dest: special/prefix-{{ inventory_hostname }}\n    flat: yes\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.file": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "details": "permissions and ownership will be shown but file contents on absent/touch will not.",
       "support": "partial"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "N/A"
      }
     },
     "author": [
      "Ansible Core Team",
      "Michael DeHaan"
     ],
     "collection": "ansible.builtin",
     "description": [
      "Set attributes of files, directories, or symlinks and their targets.",
      "Alternatively, remove files, symlinks or directories.",
      "Many other modules support the same options as the M(ansible.builtin.file) module - including M(ansible.builtin.copy), M(ansible.builtin.template), and M(ansible.builtin.assemble).",
      "For Windows targets, use the M(ansible.windows.win_file) module instead."
     ],
     "filename": "/ansible/modules/file.py",
     "has_action": false,
     "module": "file",
     "options": {
      "access_time": {
       "description": [
        "This parameter indicates the time the file's access time should be set to.",
        "Should be V(preserve) when no modification is required, C(YYYYMMDDHHMM.SS) when using default time format, or V(now).",
        "Default is V(None) meaning that V(preserve) is the default for O(state=[file,directory,link,hard]) and V(now) is default for O(state=touch)."
       ],
       "type": "str",
       "version_added": "2.7",
       "version_added_collection": "ansible.builtin"
      },
      "access_time_format": {
       "default": "%Y%m%d%H%M.%S",
       "description": [
        "When used with O(access_time), indicates the time format that must be used.",
        "Based on default Python format (see time.strftime doc)."
       ],
       "type": "str",
       "version_added": "2.7",
       "version_added_collection": "ansible.builtin"
      },
      "attributes": {
       "aliases": [
        "attr"
       ],
       "description": [
        "The attributes the resulting filesystem object should have.",
        "To get supported flags look at the man page for I(chattr) on the target system.",
        "This string should contain the attributes in the same order as the one displayed by I(lsattr).",
        "The C(=) operator is assumed as default, otherwise C(+) or C(-) operators need to be included in the string."
       ],
       "type": "str",
       "version_added": "2.3",
       "version_added_collection": "ansible.builtin"
      },
      "follow": {
       "default": true,
       "description": [
        "This flag indicates that filesystem links, if they exist, should be followed.",
        "O(follow=yes) and O(state=link) can modify O(src) when combined with parameters such as O(mode).",
        "Previous to Ansible 2.5, this was V(false) by default.",
        "While creating a symlink with a non-existent destination, set O(follow) to V(false) to avoid a warning message related to permission issues. The warning message is added to notify the user that we can not set permissions to the non-existent destination."
       ],
       "type": "bool",
       "version_added": "1.8",
       "version_added_collection": "ansible.builtin"
      },
      "force": {
       "default": false,
       "description": [
        "Force the creation of the symlinks in two cases: the source file does not exist (but will appear later); the destination exists and is a file (so, we need to unlink the O(path) file and create a symlink to the O(src) file in place of it).\n"
       ],
       "type": "bool"
      },
      "group": {
       "description": [
        "Name of the group that should own the filesystem object, as would be fed to I(chown).",
        "When left unspecified, it uses the current group of the current user unless you are root, in which case it can preserve the previous ownership."
       ],
       "type": "str"
      },
      "mode": {
       "description": [
        "The permissions the resulting filesystem object should have.",
        "For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must give Ansible enough information to parse them correctly. For consistent results, quote octal numbers (for example, V('644') or V('1777')) so Ansible receives a string and can do its own conversion from string into number. Adding a leading zero (for example, V(0755)) works sometimes, but can fail in loops and some other circumstances.",
        "Giving Ansible a number without following either of these rules will end up with a decimal number which will have unexpected results.",
        "As of Ansible 1.8, the mode may be specified as a symbolic mode (for example, V(u+rwx) or V(u=rw,g=r,o=r)).",
        "If O(mode) is not specified and the destination filesystem object B(does not) exist, the default C(umask) on the system will be used when setting the mode for the newly created filesystem object.",
        "If O(mode) is not specified and the destination filesystem object B(does) exist, the mode of the existing filesystem object will be used.",
        "Specifying O(mode) is the best way to ensure filesystem objects are created with the correct permissions. See CVE-2020-1736 for further details."
       ],
       "type": "raw"
      },
      "modification_time": {
       "description": [
        "This parameter indicates the time the file's modification time should be set to.",
        "Should be V(preserve) when no modification is required, C(YYYYMMDDHHMM.SS) when using default time format, or V(now).",
        "Default is None meaning that V(preserve) is the default for O(state=[file,directory,link,hard]) and V(now) is default for O(state=touch)."
       ],
       "type": "str",
       "version_added": "2.7",
       "version_added_collection": "ansible.builtin"
      },
      "modification_time_format": {
       "default": "%Y%m%d%H%M.%S",
       "description": [
        "When used with O(modification_time), indicates the time format that must be used.",
        "Based on default Python format (see time.strftime doc)."
       ],
       "type": "str",
       "version_added": "2.7",
       "version_added_collection": "ansible.builtin"
      },
      "owner": {
       "description": [
        "Name of the user that should own the filesystem object, as would be fed to I(chown).",
        "When left unspecified, it uses the current user unless you are root, in which case it can preserve the previous ownership.",
        "Specifying a numeric username will be assumed to be a user ID and not a username. Avoid numeric usernames to avoid this confusion."
       ],
       "type": "str"
      },
      "path": {
       "aliases": [
        "dest",
        "name"
       ],
       "description": [
        "Path to the file being managed."
       ],
       "required": true,
       "type": "path"
      },
      "recurse": {
       "default": false,
       "description": [
        "Recursively set the specified file attributes on directory contents.",
        "This applies only when O(state) is set to V(directory)."
       ],
       "type": "bool",
       "version_added": "1.1",
       "version_added_collection": "ansible.builtin"
      },
      "selevel": {
       "description": [
        "The level part of the SELinux filesystem object context.",
        "This is the MLS/MCS attribute, sometimes known as the C(range).",
        "When set to V(_default), it will use the C(level) portion of the policy if available."
       ],
       "type": "str"
      },
      "serole": {
       "description": [
        "The role part of the SELinux filesystem object context.",
        "When set to V(_default), it will use the C(role) portion of the policy if available."
       ],
       "type": "str"
      },
      "setype": {
       "description": [
        "The type part of the SELinux filesystem object context.",
        "When set to V(_default), it will use the C(type) portion of the policy if available."
       ],
       "type": "str"
      },
      "seuser": {
       "description": [
        "The user part of the SELinux filesystem object context.",
        "By default it uses the V(system) policy, where applicable.",
        "When set to V(_default), it will use the C(user) portion of the policy if available."
       ],
       "type": "str"
      },
      "src": {
       "description": [
        "Path of the file to link to.",
        "This applies only to O(state=link) and O(state=hard).",
        "For O(state=link), this will also accept a non-existing path.",
        "Relative paths are relative to the file being created (O(path)) which is how the Unix command C(ln -s SRC DEST) treats relative paths."
       ],
       "type": "path"
      },
      "state": {
       "choices": [
        "absent",
        "directory",
        "file",
        "hard",
        "link",
        "touch"
       ],
       "description": [
        "If V(absent), directories will be recursively deleted, and files or symlinks will be unlinked. In the case of a directory, if C(diff) is declared, you will see the files and folders deleted listed under C(path_contents). Note that V(absent) will not cause M(ansible.builtin.file) to fail if the O(path) does not exist as the state did not change.",
        "If V(directory), all intermediate subdirectories will be created if they do not exist. Since Ansible 1.7 they will be created with the supplied permissions.",
        "If V(file), with no other options, returns the current state of C(path).",
        "If V(file), even with other options (such as O(mode)), the file will be modified if it exists but will NOT be created if it does not exist. Set to V(touch) or use the M(ansible.builtin.copy) or M(ansible.builtin.template) module if you want to create the file if it does not exist.",
        "If V(hard), the hard link will be created or changed.",
        "If V(link), the symbolic link will be created or changed.",
        "If V(touch) (new in 1.4), an empty file will be created if the file does not exist, while an existing file or directory will receive updated file access and modification times (similar to the way V(touch) works from the command line).",
        "Default is the current state of the file if it exists, V(directory) if O(recurse=yes), or V(file) otherwise."
       ],
       "type": "str"
      },
      "unsafe_writes": {
       "default": false,
       "description": [
        "Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target filesystem object.",
        "By default this module uses atomic operations to prevent data corruption or inconsistent reads from the target filesystem objects, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted filesystem objects, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.",
        "This option allows Ansible to fall back to unsafe methods of updating filesystem objects when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes).",
        "IMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption."
       ],
       "type": "bool",
       "version_added": "2.2",
       "version_added_collection": "ansible.builtin"
      }
     },
     "seealso": [
      {
       "module": "ansible.builtin.assemble"
      },
      {
       "module": "ansible.builtin.copy"
      },
      {
       "module": "ansible.builtin.stat"
      },
      {
       "module": "ansible.builtin.template"
      },
      {
       "module": "ansible.windows.win_file"
      }
     ],
     "short_description": "Manage files and file properties",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Change file ownership, group and permissions\n  ansible.builtin.file:\n    path: /etc/foo.conf\n    owner: foo\n    group: foo\n    mode: '0644'\n\n- name: Give insecure permissions to an existing file\n  ansible.builtin.file:\n    path: /work\n    owner: root\n    group: root\n    mode: '1777'\n\n- name: Create a symbolic link\n  ansible.builtin.file:\n    src: /file/to/link/to\n    dest: /path/to/symlink\n    owner: foo\n    group: foo\n    state: link\n\n- name: Create two hard links\n  ansible.builtin.file:\n    src: '/tmp/{{ item.src }}'\n    dest: '{{ item.dest }}'\n    state: hard\n  loop:\n    - { src: x, dest: y }\n    - { src: z, dest: k }\n\n- name: Touch a file, using symbolic modes to set the permissions (equivalent to 0644)\n  ansible.builtin.file:\n    path: /etc/foo.conf\n    state: touch\n    mode: u=rw,g=r,o=r\n\n- name: Touch the same file, but add/remove some permissions\n  ansible.builtin.file:\n    path: /etc/foo.conf\n    state: touch\n    mode: u+rw,g-wx,o-rwx\n\n- name: Touch again the same file, but do not change times this makes the task idempotent\n  ansible.builtin.file:\n    path: /etc/foo.conf\n    state: touch\n    mode: u+rw,g-wx,o-rwx\n    modification_time: preserve\n    access_time: preserve\n\n- name: Create a directory if it does not exist\n  ansible.builtin.file:\n    path: /etc/some_directory\n    state: directory\n    mode: '0755'\n\n- name: Update modification and access time of given file\n  ansible.builtin.file:\n    path: /etc/some_file\n    state: file\n    modification_time: now\n    access_time: now\n\n- name: Set access time based on seconds from epoch value\n  ansible.builtin.file:\n    path: /etc/another_file\n    state: file\n    access_time: '{{ \"%Y%m%d%H%M.%S\" | strftime(stat_var.stat.atime) }}'\n\n- name: Recursively change ownership of a directory\n  ansible.builtin.file:\n    path: /etc/foo\n    state: directory\n    recurse: yes\n    owner: foo\n    group: foo\n\n- name: Remove file (delete file)\n  ansible.builtin.file:\n    path: /etc/foo.txt\n    state: absent\n\n- name: Recursively remove directory\n  ansible.builtin.file:\n    path: /etc/foo\n    state: absent\n\n",
    "metadata": null,
    "return": {
     "dest": {
      "description": "Destination file/path, equal to the value passed to O(path).",
      "returned": "O(state=touch), O(state=hard), O(state=link)",
      "sample": "/path/to/file.txt",
      "type": "str"
     },
     "path": {
      "description": "Destination file/path, equal to the value passed to O(path).",
      "returned": "O(state=absent), O(state=directory), O(state=file)",
      "sample": "/path/to/file.txt",
      "type": "str"
     }
    }
   },
   "ansible.builtin.find": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "details": "since this action does not modify the target it just executes normally during check mode",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "N/A"
      }
     },
     "author": "Brian Coca (@bcoca)",
     "collection": "ansible.builtin",
     "description": [
      "Return a list of files based on specific criteria. Multiple criteria are AND'd together.",
      "For Windows targets, use the M(ansible.windows.win_find) module instead.",
      "This module does not use the C(find) command, it is a much simpler and slower Python implementation. It is intended for small and simple uses. Those that need the extra power or speed and have expertise with the UNIX command, should use it directly."
     ],
     "filename": "/ansible/modules/find.py",
     "has_action": false,
     "module": "find",
     "options": {
      "age": {
       "description": [
        "Select files whose age is equal to or greater than the specified time.",
        "Use a negative age to find files equal to or less than the specified time.",
        "You can choose seconds, minutes, hours, days, or weeks by specifying the first letter of any of those words (e.g., \"1w\")."
       ],
       "type": "str"
      },
      "age_stamp": {
       "choices": [
        "atime",
        "ctime",
        "mtime"
       ],
       "default": "mtime",
       "description": [
        "Choose the file property against which we compare age."
       ],
       "type": "str"
      },
      "contains": {
       "description": [
        "A regular expression or pattern which should be matched against the file content.",
        "If O(read_whole_file) is V(false) it matches against the beginning of the line (uses V(re.match(\\))). If O(read_whole_file) is V(true), it searches anywhere for that pattern (uses V(re.search(\\))).",
        "Works only when O(file_type) is V(file)."
       ],
       "type": "str"
      },
      "depth": {
       "description": [
        "Set the maximum number of levels to descend into.",
        "Setting recurse to V(false) will override this value, which is effectively depth 1.",
        "Default is unlimited depth."
       ],
       "type": "int",
       "version_added": "2.6",
       "version_added_collection": "ansible.builtin"
      },
      "encoding": {
       "description": [
        "When doing a C(contains) search, determine the encoding of the files to be searched."
       ],
       "type": "str",
       "version_added": "2.17",
       "version_added_collection": "ansible.builtin"
      },
      "exact_mode": {
       "default": true,
       "description": [
        "Restrict mode matching to exact matches only, and not as a minimum set of permissions to match."
       ],
       "type": "bool",
       "version_added": "2.16",
       "version_added_collection": "ansible.builtin"
      },
      "excludes": {
       "aliases": [
        "exclude"
       ],
       "description": [
        "One or more (shell or regex) patterns, which type is controlled by O(use_regex) option.",
        "Items whose basenames match an O(excludes) pattern are culled from O(patterns) matches. Multiple patterns can be specified using a list."
       ],
       "elements": "str",
       "type": "list",
       "version_added": "2.5",
       "version_added_collection": "ansible.builtin"
      },
      "file_type": {
       "choices": [
        "any",
        "directory",
        "file",
        "link"
       ],
       "default": "file",
       "description": [
        "Type of file to select.",
        "The 'link' and 'any' choices were added in Ansible 2.3."
       ],
       "type": "str"
      },
      "follow": {
       "default": false,
       "description": [
        "Set this to V(true) to follow symlinks in path for systems with python 2.6+."
       ],
       "type": "bool"
      },
      "get_checksum": {
       "default": false,
       "description": [
        "Set this to V(true) to retrieve a file's SHA1 checksum."
       ],
       "type": "bool"
      },
      "hidden": {
       "default": false,
       "description": [
        "Set this to V(true) to include hidden files, otherwise they will be ignored."
       ],
       "type": "bool"
      },
      "mode": {
       "description": [
        "Choose objects matching a specified permission. This value is restricted to modes that can be applied using the python C(os.chmod) function.",
        "The mode can be provided as an octal such as V(\"0644\") or as symbolic such as V(u=rw,g=r,o=r)"
       ],
       "type": "raw",
       "version_added": "2.16",
       "version_added_collection": "ansible.builtin"
      },
      "paths": {
       "aliases": [
        "name",
        "path"
       ],
       "description": [
        "List of paths of directories to search. All paths must be fully qualified."
       ],
       "elements": "str",
       "required": true,
       "type": "list"
      },
      "patterns": {
       "aliases": [
        "pattern"
       ],
       "default": [],
       "description": [
        "One or more (shell or regex) patterns, which type is controlled by O(use_regex) option.",
        "The patterns restrict the list of files to be returned to those whose basenames match at least one of the patterns specified. Multiple patterns can be specified using a list.",
        "The pattern is matched against the file base name, excluding the directory.",
        "When using regexen, the pattern MUST match the ENTIRE file name, not just parts of it. So if you are looking to match all files ending in .default, you'd need to use C(.*\\.default) as a regexp and not just C(\\.default).",
        "This parameter expects a list, which can be either comma separated or YAML. If any of the patterns contain a comma, make sure to put them in a list to avoid splitting the patterns in undesirable ways.",
        "Defaults to V(*) when O(use_regex=False), or V(.*) when O(use_regex=True)."
       ],
       "elements": "str",
       "type": "list"
      },
      "read_whole_file": {
       "default": false,
       "description": [
        "When doing a C(contains) search, determines whether the whole file should be read into memory or if the regex should be applied to the file line-by-line.",
        "Setting this to C(true) can have performance and memory implications for large files.",
        "This uses V(re.search(\\)) instead of V(re.match(\\))."
       ],
       "type": "bool",
       "version_added": "2.11",
       "version_added_collection": "ansible.builtin"
      },
      "recurse": {
       "default": false,
       "description": [
        "If target is a directory, recursively descend into the directory looking for files."
       ],
       "type": "bool"
      },
      "size": {
       "description": [
        "Select files whose size is equal to or greater than the specified size.",
        "Use a negative size to find files equal to or less than the specified size.",
        "Unqualified values are in bytes but b, k, m, g, and t can be appended to specify bytes, kilobytes, megabytes, gigabytes, and terabytes, respectively.",
        "Size is not evaluated for directories."
       ],
       "type": "str"
      },
      "use_regex": {
       "default": false,
       "description": [
        "If V(false), the patterns are file globs (shell).",
        "If V(true), they are python regexes."
       ],
       "type": "bool"
      }
     },
     "seealso": [
      {
       "module": "ansible.windows.win_find"
      }
     ],
     "short_description": "Return a list of files based on specific criteria",
     "version_added": "2.0",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Recursively find /tmp files older than 2 days\n  ansible.builtin.find:\n    paths: /tmp\n    age: 2d\n    recurse: yes\n\n- name: Recursively find /tmp files older than 4 weeks and equal or greater than 1 megabyte\n  ansible.builtin.find:\n    paths: /tmp\n    age: 4w\n    size: 1m\n    recurse: yes\n\n- name: Recursively find /var/tmp files with last access time greater than 3600 seconds\n  ansible.builtin.find:\n    paths: /var/tmp\n    age: 3600\n    age_stamp: atime\n    recurse: yes\n\n- name: Find /var/log files equal or greater than 10 megabytes ending with .old or .log.gz\n  ansible.builtin.find:\n    paths: /var/log\n    patterns: '*.old,*.log.gz'\n    size: 10m\n\n# Note that YAML double quotes require escaping backslashes but yaml single quotes do not.\n- name: Find /var/log files equal or greater than 10 megabytes ending with .old or .log.gz via regex\n  ansible.builtin.find:\n    paths: /var/log\n    patterns: \"^.*?\\\\.(?:old|log\\\\.gz)$\"\n    size: 10m\n    use_regex: yes\n\n- name: Find /var/log all directories, exclude nginx and mysql\n  ansible.builtin.find:\n    paths: /var/log\n    recurse: no\n    file_type: directory\n    excludes: 'nginx,mysql'\n\n# When using patterns that contain a comma, make sure they are formatted as lists to avoid splitting the pattern\n- name: Use a single pattern that contains a comma formatted as a list\n  ansible.builtin.find:\n    paths: /var/log\n    file_type: file\n    use_regex: yes\n    patterns: ['^_[0-9]{2,4}_.*.log$']\n\n- name: Use multiple patterns that contain a comma formatted as a YAML list\n  ansible.builtin.find:\n    paths: /var/log\n    file_type: file\n    use_regex: yes\n    patterns:\n      - '^_[0-9]{2,4}_.*.log$'\n      - '^[a-z]{1,5}_.*log$'\n\n",
    "metadata": null,
    "return": {
     "examined": {
      "description": "Number of filesystem objects looked at",
      "returned": "success",
      "sample": 34,
      "type": "int"
     },
     "files": {
      "description": "All matches found with the specified criteria (see stat module for full output of each dictionary)",
      "returned": "success",
      "sample": [
       {
        "...": "...",
        "checksum": "16fac7be61a6e4591a33ef4b729c5c3302307523",
        "mode": "0644",
        "path": "/var/tmp/test1"
       },
       {
        "...": "...",
        "path": "/var/tmp/test2"
       }
      ],
      "type": "list"
     },
     "matched": {
      "description": "Number of matches",
      "returned": "success",
      "sample": 14,
      "type": "int"
     },
     "skipped_paths": {
      "description": "skipped paths and reasons they were skipped",
      "returned": "success",
      "sample": {
       "/laskdfj": "'/laskdfj' is not a directory"
      },
      "type": "dict",
      "version_added": "2.12",
      "version_added_collection": "ansible.builtin"
     }
    }
   },
   "ansible.builtin.gather_facts": {
    "doc": {
     "attributes": {
      "action": {
       "description": "Indicates this has a corresponding action plugin so some parts of the options can be executed on the controller",
       "support": "full"
      },
      "async": {
       "description": "Supports being used with the C(async) keyword",
       "details": "while this action does not support the task 'async' keywords it can do its own parallel processing using the O(parallel) option.",
       "support": "none"
      },
      "bypass_host_loop": {
       "description": [
        "Forces a 'global' task that does not execute per host, this bypasses per host templating and serial, throttle and other loop considerations",
        "Conditionals will work as if C(run_once) is being used, variables used will be from the first available host",
        "This action will not work normally outside of lockstep strategies"
       ],
       "support": "none"
      },
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "details": "since this action should just query the target system info it always runs in check mode",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "facts": {
       "description": "Action returns an C(ansible_facts) dictionary that will update existing host facts",
       "support": "full"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "details": "The action plugin should be able to automatically select the specific platform modules automatically or can be configured manually",
       "platforms": "all",
       "support": "N/A"
      }
     },
     "author": [
      "Ansible Core Team"
     ],
     "collection": "ansible.builtin",
     "description": [
      "This module takes care of executing the R(configured facts modules,FACTS_MODULES), the default is to use the M(ansible.builtin.setup) module.",
      "This module is automatically called by playbooks to gather useful variables about remote hosts that can be used in playbooks.",
      "It can also be executed directly by C(/usr/bin/ansible) to check what variables are available to a host.",
      "Ansible provides many I(facts) about the system, automatically."
     ],
     "filename": "/ansible/modules/gather_facts.py",
     "has_action": true,
     "module": "gather_facts",
     "notes": [
      "This is mostly a wrapper around other fact gathering modules.",
      "Options passed into this action must be supported by all the underlying fact modules configured.",
      "If using C(gather_timeout) and parallel execution, it will limit the total execution time of modules that do not accept C(gather_timeout) themselves.",
      "Facts returned by each module will be merged, conflicts will favor 'last merged'. Order is not guaranteed, when doing parallel gathering on multiple modules."
     ],
     "options": {
      "parallel": {
       "description": [
        "A toggle that controls if the fact modules are executed in parallel or serially and in order. This can guarantee the merge order of module facts at the expense of performance.",
        "By default it will be true if more than one fact module is used.",
        "For low cost/delay fact modules parallelism overhead might end up meaning the whole process takes longer. Test your specific case to see if it is a speed improvement or not."
       ],
       "type": "bool"
      }
     },
     "short_description": "Gathers facts about remote hosts",
     "version_added": 2.8,
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# Display facts from all hosts and store them indexed by hostname at /tmp/facts.\n# ansible all -m ansible.builtin.gather_facts --tree /tmp/facts\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.get_url": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "details": "the changed status will reflect comparison to an empty source file",
       "support": "partial"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "N/A"
      }
     },
     "author": [
      "Jan-Piet Mens (@jpmens)"
     ],
     "collection": "ansible.builtin",
     "description": [
      "Downloads files from HTTP, HTTPS, or FTP to the remote server. The remote server I(must) have direct access to the remote resource.",
      "By default, if an environment variable C(<protocol>_proxy) is set on the target host, requests will be sent through that proxy. This behaviour can be overridden by setting a variable for this task (see R(setting the environment,playbooks_environment)), or by using the use_proxy option.",
      "HTTP redirects can redirect from HTTP to HTTPS so you should be sure that your proxy environment for both protocols is correct.",
      "From Ansible 2.4 when run with C(--check), it will do a HEAD request to validate the URL but will not download the entire file or verify it against hashes and will report incorrect changed status.",
      "For Windows targets, use the M(ansible.windows.win_get_url) module instead."
     ],
     "filename": "/ansible/modules/get_url.py",
     "has_action": false,
     "module": "get_url",
     "notes": [
      "For Windows targets, use the M(ansible.windows.win_get_url) module instead."
     ],
     "options": {
      "attributes": {
       "aliases": [
        "attr"
       ],
       "description": [
        "The attributes the resulting filesystem object should have.",
        "To get supported flags look at the man page for I(chattr) on the target system.",
        "This string should contain the attributes in the same order as the one displayed by I(lsattr).",
        "The C(=) operator is assumed as default, otherwise C(+) or C(-) operators need to be included in the string."
       ],
       "type": "str",
       "version_added": "2.3",
       "version_added_collection": "ansible.builtin"
      },
      "backup": {
       "default": false,
       "description": [
        "Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly."
       ],
       "type": "bool",
       "version_added": "2.1",
       "version_added_collection": "ansible.builtin"
      },
      "checksum": {
       "default": "",
       "description": [
        "If a checksum is passed to this parameter, the digest of the destination file will be calculated after it is downloaded to ensure its integrity and verify that the transfer completed successfully. Format: <algorithm>:<checksum|url>, e.g. checksum=\"sha256:D98291AC[...]B6DC7B97\", checksum=\"sha256:http://example.com/path/sha256sum.txt\"",
        "If you worry about portability, only the sha1 algorithm is available on all platforms and python versions.",
        "The Python ``hashlib`` module is responsible for providing the available algorithms. The choices vary based on Python version and OpenSSL version.",
        "On systems running in FIPS compliant mode, the ``md5`` algorithm may be unavailable.",
        "Additionally, if a checksum is passed to this parameter, and the file exist under the O(dest) location, the C(destination_checksum) would be calculated, and if checksum equals C(destination_checksum), the file download would be skipped (unless O(force) is V(true)). If the checksum does not equal C(destination_checksum), the destination file is deleted."
       ],
       "type": "str",
       "version_added": "2.0",
       "version_added_collection": "ansible.builtin"
      },
      "ciphers": {
       "description": [
        "SSL/TLS Ciphers to use for the request",
        "When a list is provided, all ciphers are joined in order with V(:)",
        "See the L(OpenSSL Cipher List Format,https://www.openssl.org/docs/manmaster/man1/openssl-ciphers.html#CIPHER-LIST-FORMAT) for more details.",
        "The available ciphers is dependent on the Python and OpenSSL/LibreSSL versions"
       ],
       "elements": "str",
       "type": "list",
       "version_added": "2.14",
       "version_added_collection": "ansible.builtin"
      },
      "client_cert": {
       "description": [
        "PEM formatted certificate chain file to be used for SSL client authentication.",
        "This file can also include the key as well, and if the key is included, O(client_key) is not required."
       ],
       "type": "path",
       "version_added": "2.4",
       "version_added_collection": "ansible.builtin"
      },
      "client_key": {
       "description": [
        "PEM formatted file that contains your private key to be used for SSL client authentication.",
        "If O(client_cert) contains both the certificate and key, this option is not required."
       ],
       "type": "path",
       "version_added": "2.4",
       "version_added_collection": "ansible.builtin"
      },
      "decompress": {
       "default": true,
       "description": [
        "Whether to attempt to decompress gzip content-encoded responses"
       ],
       "type": "bool",
       "version_added": "2.14",
       "version_added_collection": "ansible.builtin"
      },
      "dest": {
       "description": [
        "Absolute path of where to download the file to.",
        "If O(dest) is a directory, either the server provided filename or, if none provided, the base name of the URL on the remote server will be used. If a directory, O(force) has no effect.",
        "If O(dest) is a directory, the file will always be downloaded (regardless of the O(force) and O(checksum) option), but replaced only if the contents changed."
       ],
       "required": true,
       "type": "path"
      },
      "force": {
       "default": false,
       "description": [
        "If V(true) and O(dest) is not a directory, will download the file every time and replace the file if the contents change. If V(false), the file will only be downloaded if the destination does not exist. Generally should be V(true) only for small local files.",
        "Prior to 0.6, this module behaved as if V(true) was the default."
       ],
       "type": "bool",
       "version_added": "0.7",
       "version_added_collection": "ansible.builtin"
      },
      "force_basic_auth": {
       "default": false,
       "description": [
        "Force the sending of the Basic authentication header upon initial request.",
        "httplib2, the library used by the uri module only sends authentication information when a webservice responds to an initial request with a 401 status. Since some basic auth services do not properly send a 401, logins will fail."
       ],
       "type": "bool",
       "version_added": "2.0",
       "version_added_collection": "ansible.builtin"
      },
      "group": {
       "description": [
        "Name of the group that should own the filesystem object, as would be fed to I(chown).",
        "When left unspecified, it uses the current group of the current user unless you are root, in which case it can preserve the previous ownership."
       ],
       "type": "str"
      },
      "headers": {
       "description": [
        "Add custom HTTP headers to a request in hash/dict format.",
        "The hash/dict format was added in Ansible 2.6.",
        "Previous versions used a C(\"key:value,key:value\") string format.",
        "The C(\"key:value,key:value\") string format is deprecated and has been removed in version 2.10."
       ],
       "type": "dict",
       "version_added": "2.0",
       "version_added_collection": "ansible.builtin"
      },
      "http_agent": {
       "default": "ansible-httpget",
       "description": [
        "Header to identify as, generally appears in web server logs."
       ],
       "type": "str"
      },
      "mode": {
       "description": [
        "The permissions the resulting filesystem object should have.",
        "For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must give Ansible enough information to parse them correctly. For consistent results, quote octal numbers (for example, V('644') or V('1777')) so Ansible receives a string and can do its own conversion from string into number. Adding a leading zero (for example, V(0755)) works sometimes, but can fail in loops and some other circumstances.",
        "Giving Ansible a number without following either of these rules will end up with a decimal number which will have unexpected results.",
        "As of Ansible 1.8, the mode may be specified as a symbolic mode (for example, V(u+rwx) or V(u=rw,g=r,o=r)).",
        "If O(mode) is not specified and the destination filesystem object B(does not) exist, the default C(umask) on the system will be used when setting the mode for the newly created filesystem object.",
        "If O(mode) is not specified and the destination filesystem object B(does) exist, the mode of the existing filesystem object will be used.",
        "Specifying O(mode) is the best way to ensure filesystem objects are created with the correct permissions. See CVE-2020-1736 for further details."
       ],
       "type": "raw"
      },
      "owner": {
       "description": [
        "Name of the user that should own the filesystem object, as would be fed to I(chown).",
        "When left unspecified, it uses the current user unless you are root, in which case it can preserve the previous ownership.",
        "Specifying a numeric username will be assumed to be a user ID and not a username. Avoid numeric usernames to avoid this confusion."
       ],
       "type": "str"
      },
      "selevel": {
       "description": [
        "The level part of the SELinux filesystem object context.",
        "This is the MLS/MCS attribute, sometimes known as the C(range).",
        "When set to V(_default), it will use the C(level) portion of the policy if available."
       ],
       "type": "str"
      },
      "serole": {
       "description": [
        "The role part of the SELinux filesystem object context.",
        "When set to V(_default), it will use the C(role) portion of the policy if available."
       ],
       "type": "str"
      },
      "setype": {
       "description": [
        "The type part of the SELinux filesystem object context.",
        "When set to V(_default), it will use the C(type) portion of the policy if available."
       ],
       "type": "str"
      },
      "seuser": {
       "description": [
        "The user part of the SELinux filesystem object context.",
        "By default it uses the V(system) policy, where applicable.",
        "When set to V(_default), it will use the C(user) portion of the policy if available."
       ],
       "type": "str"
      },
      "timeout": {
       "default": 10,
       "description": [
        "Timeout in seconds for URL request."
       ],
       "type": "int",
       "version_added": "1.8",
       "version_added_collection": "ansible.builtin"
      },
      "tmp_dest": {
       "description": [
        "Absolute path of where temporary file is downloaded to.",
        "When run on Ansible 2.5 or greater, path defaults to ansible's remote_tmp setting",
        "When run on Ansible prior to 2.5, it defaults to E(TMPDIR), E(TEMP) or E(TMP) env variables or a platform specific value.",
        "U(https://docs.python.org/3/library/tempfile.html#tempfile.tempdir)"
       ],
       "type": "path",
       "version_added": "2.1",
       "version_added_collection": "ansible.builtin"
      },
      "unredirected_headers": {
       "default": [],
       "description": [
        "A list of header names that will not be sent on subsequent redirected requests. This list is case insensitive. By default all headers will be redirected. In some cases it may be beneficial to list headers such as C(Authorization) here to avoid potential credential exposure."
       ],
       "elements": "str",
       "type": "list",
       "version_added": "2.12",
       "version_added_collection": "ansible.builtin"
      },
      "unsafe_writes": {
       "default": false,
       "description": [
        "Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target filesystem object.",
        "By default this module uses atomic operations to prevent data corruption or inconsistent reads from the target filesystem objects, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted filesystem objects, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.",
        "This option allows Ansible to fall back to unsafe methods of updating filesystem objects when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes).",
        "IMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption."
       ],
       "type": "bool",
       "version_added": "2.2",
       "version_added_collection": "ansible.builtin"
      },
      "url": {
       "description": [
        "HTTP, HTTPS, or FTP URL in the form (http|https|ftp)://[user[:pass]]@host.domain[:port]/path"
       ],
       "required": true,
       "type": "str"
      },
      "url_password": {
       "aliases": [
        "password"
       ],
       "description": [
        "The password for use in HTTP basic authentication.",
        "If the O(url_username) parameter is not specified, the O(url_password) parameter will not be used.",
        "Since version 2.8 you can also use the O(password) alias for this option."
       ],
       "type": "str",
       "version_added": "1.6",
       "version_added_collection": "ansible.builtin"
      },
      "url_username": {
       "aliases": [
        "username"
       ],
       "description": [
        "The username for use in HTTP basic authentication.",
        "This parameter can be used without O(url_password) for sites that allow empty passwords.",
        "Since version 2.8 you can also use the O(username) alias for this option."
       ],
       "type": "str",
       "version_added": "1.6",
       "version_added_collection": "ansible.builtin"
      },
      "use_gssapi": {
       "default": false,
       "description": [
        "Use GSSAPI to perform the authentication, typically this is for Kerberos or Kerberos through Negotiate authentication.",
        "Requires the Python library L(gssapi,https://github.com/pythongssapi/python-gssapi) to be installed.",
        "Credentials for GSSAPI can be specified with O(url_username)/O(url_password) or with the GSSAPI env var C(KRB5CCNAME) that specified a custom Kerberos credential cache.",
        "NTLM authentication is I(not) supported even if the GSSAPI mech for NTLM has been installed."
       ],
       "type": "bool",
       "version_added": "2.11",
       "version_added_collection": "ansible.builtin"
      },
      "use_netrc": {
       "default": true,
       "description": [
        "Determining whether to use credentials from ``~/.netrc`` file",
        "By default .netrc is used with Basic authentication headers",
        "When set to False, .netrc credentials are ignored"
       ],
       "type": "bool",
       "version_added": "2.14",
       "version_added_collection": "ansible.builtin"
      },
      "use_proxy": {
       "default": true,
       "description": [
        "if V(false), it will not use a proxy, even if one is defined in an environment variable on the target hosts."
       ],
       "type": "bool"
      },
      "validate_certs": {
       "default": true,
       "description": [
        "If V(false), SSL certificates will not be validated.",
        "This should only be used on personally controlled sites using self-signed certificates."
       ],
       "type": "bool"
      }
     },
     "seealso": [
      {
       "module": "ansible.builtin.uri"
      },
      {
       "module": "ansible.windows.win_get_url"
      }
     ],
     "short_description": "Downloads files from HTTP, HTTPS, or FTP to node",
     "version_added": "0.6",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Download foo.conf\n  ansible.builtin.get_url:\n    url: http://example.com/path/file.conf\n    dest: /etc/foo.conf\n    mode: '0440'\n\n- name: Download file and force basic auth\n  ansible.builtin.get_url:\n    url: http://example.com/path/file.conf\n    dest: /etc/foo.conf\n    force_basic_auth: yes\n\n- name: Download file with custom HTTP headers\n  ansible.builtin.get_url:\n    url: http://example.com/path/file.conf\n    dest: /etc/foo.conf\n    headers:\n      key1: one\n      key2: two\n\n- name: Download file with check (sha256)\n  ansible.builtin.get_url:\n    url: http://example.com/path/file.conf\n    dest: /etc/foo.conf\n    checksum: sha256:b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c\n\n- name: Download file with check (md5)\n  ansible.builtin.get_url:\n    url: http://example.com/path/file.conf\n    dest: /etc/foo.conf\n    checksum: md5:66dffb5228a211e61d6d7ef4a86f5758\n\n- name: Download file with checksum url (sha256)\n  ansible.builtin.get_url:\n    url: http://example.com/path/file.conf\n    dest: /etc/foo.conf\n    checksum: sha256:http://example.com/path/sha256sum.txt\n\n- name: Download file from a file path\n  ansible.builtin.get_url:\n    url: file:///tmp/a_file.txt\n    dest: /tmp/afilecopy.txt\n\n- name: < Fetch file that requires authentication.\n        username/password only available since 2.8, in older versions you need to use url_username/url_password\n  ansible.builtin.get_url:\n    url: http://example.com/path/file.conf\n    dest: /etc/foo.conf\n    username: bar\n    password: '{{ mysecret }}'\n",
    "metadata": null,
    "return": {
     "backup_file": {
      "description": "name of backup file created after download",
      "returned": "changed and if backup=yes",
      "sample": "/path/to/file.txt.2015-02-12@22:09~",
      "type": "str"
     },
     "checksum_dest": {
      "description": "sha1 checksum of the file after copy",
      "returned": "success",
      "sample": "6e642bb8dd5c2e027bf21dd923337cbb4214f827",
      "type": "str"
     },
     "checksum_src": {
      "description": "sha1 checksum of the file",
      "returned": "success",
      "sample": "6e642bb8dd5c2e027bf21dd923337cbb4214f827",
      "type": "str"
     },
     "dest": {
      "description": "destination file/path",
      "returned": "success",
      "sample": "/path/to/file.txt",
      "type": "str"
     },
     "elapsed": {
      "description": "The number of seconds that elapsed while performing the download",
      "returned": "always",
      "sample": 23,
      "type": "int"
     },
     "gid": {
      "description": "group id of the file",
      "returned": "success",
      "sample": 100,
      "type": "int"
     },
     "group": {
      "description": "group of the file",
      "returned": "success",
      "sample": "httpd",
      "type": "str"
     },
     "md5sum": {
      "description": "md5 checksum of the file after download",
      "returned": "when supported",
      "sample": "2a5aeecc61dc98c4d780b14b330e3282",
      "type": "str"
     },
     "mode": {
      "description": "permissions of the target",
      "returned": "success",
      "sample": "0644",
      "type": "str"
     },
     "msg": {
      "description": "the HTTP message from the request",
      "returned": "always",
      "sample": "OK (unknown bytes)",
      "type": "str"
     },
     "owner": {
      "description": "owner of the file",
      "returned": "success",
      "sample": "httpd",
      "type": "str"
     },
     "secontext": {
      "description": "the SELinux security context of the file",
      "returned": "success",
      "sample": "unconfined_u:object_r:user_tmp_t:s0",
      "type": "str"
     },
     "size": {
      "description": "size of the target",
      "returned": "success",
      "sample": 1220,
      "type": "int"
     },
     "src": {
      "description": "source file used after download",
      "returned": "always",
      "sample": "/tmp/tmpAdFLdV",
      "type": "str"
     },
     "state": {
      "description": "state of the target",
      "returned": "success",
      "sample": "file",
      "type": "str"
     },
     "status_code": {
      "description": "the HTTP status code from the request",
      "returned": "always",
      "sample": 200,
      "type": "int"
     },
     "uid": {
      "description": "owner id of the file, after execution",
      "returned": "success",
      "sample": 100,
      "type": "int"
     },
     "url": {
      "description": "the actual URL used for the request",
      "returned": "always",
      "sample": "https://www.ansible.com/",
      "type": "str"
     }
    }
   },
   "ansible.builtin.getent": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "facts": {
       "description": "Action returns an C(ansible_facts) dictionary that will update existing host facts",
       "support": "full"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "N/A"
      }
     },
     "author": [
      "Brian Coca (@bcoca)"
     ],
     "collection": "ansible.builtin",
     "description": [
      "Runs getent against one of its various databases and returns information into the host's facts, in a C(getent_<database>) prefixed variable."
     ],
     "filename": "/ansible/modules/getent.py",
     "has_action": false,
     "module": "getent",
     "notes": [
      "Not all databases support enumeration, check system documentation for details."
     ],
     "options": {
      "database": {
       "description": [
        "The name of a getent database supported by the target system (passwd, group, hosts, etc)."
       ],
       "required": true,
       "type": "str"
      },
      "fail_key": {
       "default": "yes",
       "description": [
        "If a supplied key is missing this will make the task fail if V(true)."
       ],
       "type": "bool"
      },
      "key": {
       "description": [
        "Key from which to return values from the specified database, otherwise the full contents are returned."
       ],
       "type": "str"
      },
      "service": {
       "description": [
        "Override all databases with the specified service",
        "The underlying system must support the service flag which is not always available."
       ],
       "type": "str",
       "version_added": "2.9",
       "version_added_collection": "ansible.builtin"
      },
      "split": {
       "description": [
        "Character used to split the database values into lists/arrays such as V(:) or V(\\\\t), otherwise it will try to pick one depending on the database."
       ],
       "type": "str"
      }
     },
     "short_description": "A wrapper to the unix getent utility",
     "version_added": "1.8",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Get root user info\n  ansible.builtin.getent:\n    database: passwd\n    key: root\n- ansible.builtin.debug:\n    var: ansible_facts.getent_passwd\n\n- name: Get all groups\n  ansible.builtin.getent:\n    database: group\n    split: ':'\n- ansible.builtin.debug:\n    var: ansible_facts.getent_group\n\n- name: Get all hosts, split by tab\n  ansible.builtin.getent:\n    database: hosts\n- ansible.builtin.debug:\n    var: ansible_facts.getent_hosts\n\n- name: Get http service info, no error if missing\n  ansible.builtin.getent:\n    database: services\n    key: http\n    fail_key: False\n- ansible.builtin.debug:\n    var: ansible_facts.getent_services\n\n- name: Get user password hash (requires sudo/root)\n  ansible.builtin.getent:\n    database: shadow\n    key: www-data\n    split: ':'\n- ansible.builtin.debug:\n    var: ansible_facts.getent_shadow\n\n",
    "metadata": null,
    "return": {
     "ansible_facts": {
      "contains": {
       "getent_<database>": {
        "description": [
         "A list of results or a single result as a list of the fields the db provides",
         "The list elements depend on the database queried, see getent man page for the structure",
         "Starting at 2.11 it now returns multiple duplicate entries, previously it only returned the last one"
        ],
        "returned": "always",
        "type": "list"
       }
      },
      "description": "Facts to add to ansible_facts.",
      "returned": "always",
      "type": "dict"
     }
    }
   },
   "ansible.builtin.git": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "full"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "N/A"
      }
     },
     "author": [
      "Ansible Core Team",
      "Michael DeHaan"
     ],
     "collection": "ansible.builtin",
     "description": [
      "Manage I(git) checkouts of repositories to deploy files or software."
     ],
     "filename": "/ansible/modules/git.py",
     "has_action": false,
     "module": "git",
     "notes": [
      "If the task seems to be hanging, first verify remote host is in C(known_hosts). SSH will prompt user to authorize the first contact with a remote host.  To avoid this prompt, one solution is to use the option accept_hostkey. Another solution is to add the remote host public key in C(/etc/ssh/ssh_known_hosts) before calling the git module, with the following command: ssh-keyscan -H remote_host.com >> /etc/ssh/ssh_known_hosts."
     ],
     "options": {
      "accept_hostkey": {
       "default": "no",
       "description": [
        "Will ensure or not that \"-o StrictHostKeyChecking=no\" is present as an ssh option.",
        "Be aware that this disables a protection against MITM attacks.",
        "Those using OpenSSH >= 7.5 might want to set O(ssh_opts) to V(StrictHostKeyChecking=accept-new) instead, it does not remove the MITM issue but it does restrict it to the first attempt."
       ],
       "type": "bool",
       "version_added": "1.5",
       "version_added_collection": "ansible.builtin"
      },
      "accept_newhostkey": {
       "default": "no",
       "description": [
        "As of OpenSSH 7.5, \"-o StrictHostKeyChecking=accept-new\" can be used which is safer and will only accepts host keys which are not present or are the same. if V(true), ensure that \"-o StrictHostKeyChecking=accept-new\" is present as an ssh option."
       ],
       "type": "bool",
       "version_added": "2.12",
       "version_added_collection": "ansible.builtin"
      },
      "archive": {
       "description": [
        "Specify archive file path with extension. If specified, creates an archive file of the specified format containing the tree structure for the source tree. Allowed archive formats [\"zip\", \"tar.gz\", \"tar\", \"tgz\"].",
        "This will clone and perform git archive from local directory as not all git servers support git archive."
       ],
       "type": "path",
       "version_added": "2.4",
       "version_added_collection": "ansible.builtin"
      },
      "archive_prefix": {
       "description": [
        "Specify a prefix to add to each file path in archive. Requires O(archive) to be specified."
       ],
       "type": "str",
       "version_added": "2.10",
       "version_added_collection": "ansible.builtin"
      },
      "bare": {
       "default": "no",
       "description": [
        "If V(true), repository will be created as a bare repo, otherwise it will be a standard repo with a workspace."
       ],
       "type": "bool",
       "version_added": "1.4",
       "version_added_collection": "ansible.builtin"
      },
      "clone": {
       "default": "yes",
       "description": [
        "If V(false), do not clone the repository even if it does not exist locally."
       ],
       "type": "bool",
       "version_added": "1.9",
       "version_added_collection": "ansible.builtin"
      },
      "depth": {
       "description": [
        "Create a shallow clone with a history truncated to the specified number or revisions. The minimum possible value is V(1), otherwise ignored. Needs I(git>=1.9.1) to work correctly."
       ],
       "type": "int",
       "version_added": "1.2",
       "version_added_collection": "ansible.builtin"
      },
      "dest": {
       "description": [
        "The path of where the repository should be checked out. This is equivalent to C(git clone [repo_url] [directory]). The repository named in O(repo) is not appended to this path and the destination directory must be empty. This parameter is required, unless O(clone) is set to V(false)."
       ],
       "required": true,
       "type": "path"
      },
      "executable": {
       "description": [
        "Path to git executable to use. If not supplied, the normal mechanism for resolving binary paths will be used."
       ],
       "type": "path",
       "version_added": "1.4",
       "version_added_collection": "ansible.builtin"
      },
      "force": {
       "default": "no",
       "description": [
        "If V(true), any modified files in the working repository will be discarded.  Prior to 0.7, this was always V(true) and could not be disabled.  Prior to 1.9, the default was V(true)."
       ],
       "type": "bool",
       "version_added": "0.7",
       "version_added_collection": "ansible.builtin"
      },
      "gpg_whitelist": {
       "default": [],
       "description": [
        "A list of trusted GPG fingerprints to compare to the fingerprint of the GPG-signed commit.",
        "Only used when O(verify_commit=yes).",
        "Use of this feature requires Git 2.6+ due to its reliance on git's C(--raw) flag to C(verify-commit) and C(verify-tag)."
       ],
       "elements": "str",
       "type": "list",
       "version_added": "2.9",
       "version_added_collection": "ansible.builtin"
      },
      "key_file": {
       "description": [
        "Specify an optional private key file path, on the target host, to use for the checkout.",
        "This ensures 'IdentitiesOnly=yes' is present in O(ssh_opts)."
       ],
       "type": "path",
       "version_added": "1.5",
       "version_added_collection": "ansible.builtin"
      },
      "recursive": {
       "default": "yes",
       "description": [
        "If V(false), repository will be cloned without the C(--recursive) option, skipping sub-modules."
       ],
       "type": "bool",
       "version_added": "1.6",
       "version_added_collection": "ansible.builtin"
      },
      "reference": {
       "description": [
        "Reference repository (see \"git clone --reference ...\")."
       ],
       "type": "str",
       "version_added": "1.4",
       "version_added_collection": "ansible.builtin"
      },
      "refspec": {
       "description": [
        "Add an additional refspec to be fetched. If version is set to a I(SHA-1) not reachable from any branch or tag, this option may be necessary to specify the ref containing the I(SHA-1). Uses the same syntax as the C(git fetch) command. An example value could be \"refs/meta/config\"."
       ],
       "type": "str",
       "version_added": "1.9",
       "version_added_collection": "ansible.builtin"
      },
      "remote": {
       "default": "origin",
       "description": [
        "Name of the remote."
       ],
       "type": "str"
      },
      "repo": {
       "aliases": [
        "name"
       ],
       "description": [
        "git, SSH, or HTTP(S) protocol address of the git repository."
       ],
       "required": true,
       "type": "str"
      },
      "separate_git_dir": {
       "description": [
        "The path to place the cloned repository. If specified, Git repository can be separated from working tree."
       ],
       "type": "path",
       "version_added": "2.7",
       "version_added_collection": "ansible.builtin"
      },
      "single_branch": {
       "default": "no",
       "description": [
        "Clone only the history leading to the tip of the specified revision."
       ],
       "type": "bool",
       "version_added": "2.11",
       "version_added_collection": "ansible.builtin"
      },
      "ssh_opts": {
       "description": [
        "Options git will pass to ssh when used as protocol, it works via C(git)'s E(GIT_SSH)/E(GIT_SSH_COMMAND) environment variables.",
        "For older versions it appends E(GIT_SSH_OPTS) (specific to this module) to the variables above or via a wrapper script.",
        "Other options can add to this list, like O(key_file) and O(accept_hostkey).",
        "An example value could be \"-o StrictHostKeyChecking=no\" (although this particular option is better set by O(accept_hostkey)).",
        "The module ensures that 'BatchMode=yes' is always present to avoid prompts."
       ],
       "type": "str",
       "version_added": "1.5",
       "version_added_collection": "ansible.builtin"
      },
      "track_submodules": {
       "default": "no",
       "description": [
        "If V(true), submodules will track the latest commit on their master branch (or other branch specified in .gitmodules).  If V(false), submodules will be kept at the revision specified by the main project. This is equivalent to specifying the C(--remote) flag to git submodule update."
       ],
       "type": "bool",
       "version_added": "1.8",
       "version_added_collection": "ansible.builtin"
      },
      "umask": {
       "description": [
        "The umask to set before doing any checkouts, or any other repository maintenance."
       ],
       "type": "raw",
       "version_added": "2.2",
       "version_added_collection": "ansible.builtin"
      },
      "update": {
       "default": "yes",
       "description": [
        "If V(false), do not retrieve new revisions from the origin repository.",
        "Operations like archive will work on the existing (old) repository and might not respond to changes to the options version or remote."
       ],
       "type": "bool",
       "version_added": "1.2",
       "version_added_collection": "ansible.builtin"
      },
      "verify_commit": {
       "default": "no",
       "description": [
        "If V(true), when cloning or checking out a O(version) verify the signature of a GPG signed commit. This requires git version>=2.1.0 to be installed. The commit MUST be signed and the public key MUST be present in the GPG keyring."
       ],
       "type": "bool",
       "version_added": "2.0",
       "version_added_collection": "ansible.builtin"
      },
      "version": {
       "default": "HEAD",
       "description": [
        "What version of the repository to check out. This can be the literal string V(HEAD), a branch name, a tag name. It can also be a I(SHA-1) hash, in which case O(refspec) needs to be specified if the given revision is not already available."
       ],
       "type": "str"
      }
     },
     "requirements": [
      "git>=1.7.1 (the command line tool)"
     ],
     "short_description": "Deploy software (or files) from git checkouts",
     "version_added": "0.0.1",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Git checkout\n  ansible.builtin.git:\n    repo: 'https://foosball.example.org/path/to/repo.git'\n    dest: /srv/checkout\n    version: release-0.22\n\n- name: Read-write git checkout from github\n  ansible.builtin.git:\n    repo: git@github.com:mylogin/hello.git\n    dest: /home/mylogin/hello\n\n- name: Just ensuring the repo checkout exists\n  ansible.builtin.git:\n    repo: 'https://foosball.example.org/path/to/repo.git'\n    dest: /srv/checkout\n    update: no\n\n- name: Just get information about the repository whether or not it has already been cloned locally\n  ansible.builtin.git:\n    repo: 'https://foosball.example.org/path/to/repo.git'\n    dest: /srv/checkout\n    clone: no\n    update: no\n\n- name: Checkout a github repo and use refspec to fetch all pull requests\n  ansible.builtin.git:\n    repo: https://github.com/ansible/ansible-examples.git\n    dest: /src/ansible-examples\n    refspec: '+refs/pull/*:refs/heads/*'\n\n- name: Create git archive from repo\n  ansible.builtin.git:\n    repo: https://github.com/ansible/ansible-examples.git\n    dest: /src/ansible-examples\n    archive: /tmp/ansible-examples.zip\n\n- name: Clone a repo with separate git directory\n  ansible.builtin.git:\n    repo: https://github.com/ansible/ansible-examples.git\n    dest: /src/ansible-examples\n    separate_git_dir: /src/ansible-examples.git\n\n- name: Example clone of a single branch\n  ansible.builtin.git:\n    repo: https://github.com/ansible/ansible-examples.git\n    dest: /src/ansible-examples\n    single_branch: yes\n    version: master\n\n- name: Avoid hanging when http(s) password is missing\n  ansible.builtin.git:\n    repo: https://github.com/ansible/could-be-a-private-repo\n    dest: /src/from-private-repo\n  environment:\n    GIT_TERMINAL_PROMPT: 0 # reports \"terminal prompts disabled\" on missing password\n    # or GIT_ASKPASS: /bin/true # for git before version 2.3.0, reports \"Authentication failed\" on missing password\n",
    "metadata": null,
    "return": {
     "after": {
      "description": "Last commit revision of the repository retrieved during the update.",
      "returned": "success",
      "sample": "4c020102a9cd6fe908c9a4a326a38f972f63a903",
      "type": "str"
     },
     "before": {
      "description": "Commit revision before the repository was updated, \"null\" for new repository.",
      "returned": "success",
      "sample": "67c04ebe40a003bda0efb34eacfb93b0cafdf628",
      "type": "str"
     },
     "git_dir_before": {
      "description": "Contains the original path of .git directory if it is changed.",
      "returned": "success",
      "sample": "/path/to/old/git/dir",
      "type": "str"
     },
     "git_dir_now": {
      "description": "Contains the new path of .git directory if it is changed.",
      "returned": "success",
      "sample": "/path/to/new/git/dir",
      "type": "str"
     },
     "remote_url_changed": {
      "description": "Contains True or False whether or not the remote URL was changed.",
      "returned": "success",
      "sample": true,
      "type": "bool"
     },
     "warnings": {
      "description": "List of warnings if requested features were not available due to a too old git version.",
      "returned": "error",
      "sample": "git version is too old to fully support the depth argument. Falling back to full checkouts.",
      "type": "str"
     }
    }
   },
   "ansible.builtin.group": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "N/A"
      }
     },
     "author": [
      "Stephen Fromm (@sfromm)"
     ],
     "collection": "ansible.builtin",
     "description": [
      "Manage presence of groups on a host.",
      "For Windows targets, use the M(ansible.windows.win_group) module instead."
     ],
     "filename": "/ansible/modules/group.py",
     "has_action": false,
     "module": "group",
     "options": {
      "force": {
       "default": false,
       "description": [
        "Whether to delete a group even if it is the primary group of a user.",
        "Only applicable on platforms which implement a --force flag on the group deletion command."
       ],
       "type": "bool",
       "version_added": "2.15",
       "version_added_collection": "ansible.builtin"
      },
      "gid": {
       "description": [
        "Optional I(GID) to set for the group."
       ],
       "type": "int"
      },
      "local": {
       "default": false,
       "description": [
        "Forces the use of \"local\" command alternatives on platforms that implement it.",
        "This is useful in environments that use centralized authentication when you want to manipulate the local groups. (for example, it uses C(lgroupadd) instead of C(groupadd)).",
        "This requires that these commands exist on the targeted host, otherwise it will be a fatal error."
       ],
       "type": "bool",
       "version_added": "2.6",
       "version_added_collection": "ansible.builtin"
      },
      "name": {
       "description": [
        "Name of the group to manage."
       ],
       "required": true,
       "type": "str"
      },
      "non_unique": {
       "default": false,
       "description": [
        "This option allows to change the group ID to a non-unique value. Requires O(gid).",
        "Not supported on macOS or BusyBox distributions."
       ],
       "type": "bool",
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      },
      "state": {
       "choices": [
        "absent",
        "present"
       ],
       "default": "present",
       "description": [
        "Whether the group should be present or not on the remote host."
       ],
       "type": "str"
      },
      "system": {
       "default": false,
       "description": [
        "If V(yes), indicates that the group created is a system group."
       ],
       "type": "bool"
      }
     },
     "requirements": [
      "groupadd",
      "groupdel",
      "groupmod"
     ],
     "seealso": [
      {
       "module": "ansible.builtin.user"
      },
      {
       "module": "ansible.windows.win_group"
      }
     ],
     "short_description": "Add or remove groups",
     "version_added": "0.0.2",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Ensure group \"somegroup\" exists\n  ansible.builtin.group:\n    name: somegroup\n    state: present\n\n- name: Ensure group \"docker\" exists with correct gid\n  ansible.builtin.group:\n    name: docker\n    state: present\n    gid: 1750\n",
    "metadata": null,
    "return": {
     "gid": {
      "description": "Group ID of the group.",
      "returned": "When O(state) is C(present)",
      "sample": 1001,
      "type": "int"
     },
     "name": {
      "description": "Group name.",
      "returned": "always",
      "sample": "users",
      "type": "str"
     },
     "state": {
      "description": "Whether the group is present or not.",
      "returned": "always",
      "sample": "absent",
      "type": "str"
     },
     "system": {
      "description": "Whether the group is a system group or not.",
      "returned": "When O(state) is C(present)",
      "sample": false,
      "type": "bool"
     }
    }
   },
   "ansible.builtin.group_by": {
    "doc": {
     "attributes": {
      "action": {
       "description": "Indicates this has a corresponding action plugin so some parts of the options can be executed on the controller",
       "support": "full"
      },
      "async": {
       "description": "Supports being used with the C(async) keyword",
       "support": "none"
      },
      "become": {
       "description": "Is usable alongside become keywords",
       "support": "none"
      },
      "bypass_host_loop": {
       "description": [
        "Forces a 'global' task that does not execute per host, this bypasses per host templating and serial, throttle and other loop considerations",
        "Conditionals will work as if C(run_once) is being used, variables used will be from the first available host",
        "This action will not work normally outside of lockstep strategies"
       ],
       "support": "none"
      },
      "bypass_task_loop": {
       "description": "These tasks ignore the C(loop) and C(with_) keywords",
       "support": "none"
      },
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "details": "While this makes no changes to target systems the 'in memory' inventory will still be altered",
       "support": "partial"
      },
      "connection": {
       "description": "Uses the target's configured connection information to execute code on it",
       "support": "none"
      },
      "core": {
       "description": "This is a 'core engine' feature and is not implemented like most task actions, so it is not overridable in any way via the plugin system.",
       "details": "While parts of this action are implemented in core, other parts are still available as normal plugins and can be partially overridden",
       "support": "partial"
      },
      "delegation": {
       "description": "Can be used in conjunction with delegate_to and related keywords",
       "support": "none"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "ignore_conditional": {
       "description": "The action is not subject to conditional execution so it will ignore the C(when:) keyword",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "all",
       "support": "N/A"
      },
      "tags": {
       "description": "Allows for the 'tags' keyword to control the selection of this action for execution",
       "support": "full"
      },
      "until": {
       "description": "Denotes if this action obeys until/retry/poll keywords",
       "support": "full"
      }
     },
     "author": [
      "Jeroen Hoekx (@jhoekx)"
     ],
     "collection": "ansible.builtin",
     "description": [
      "Use facts to create ad-hoc groups that can be used later in a playbook.",
      "This module is also supported for Windows targets."
     ],
     "filename": "/ansible/modules/group_by.py",
     "has_action": true,
     "module": "group_by",
     "notes": [
      "Spaces in group names are converted to dashes '-'.",
      "Though this module does not change the remote host, we do provide 'changed' status as it can be useful for those trying to track inventory changes."
     ],
     "options": {
      "key": {
       "description": [
        "The variables whose values will be used as groups."
       ],
       "required": true,
       "type": "str"
      },
      "parents": {
       "default": "all",
       "description": [
        "The list of the parent groups."
       ],
       "elements": "str",
       "type": "list",
       "version_added": "2.4",
       "version_added_collection": "ansible.builtin"
      }
     },
     "seealso": [
      {
       "module": "ansible.builtin.add_host"
      }
     ],
     "short_description": "Create Ansible groups based on facts",
     "version_added": "0.9",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Create groups based on the machine architecture\n  ansible.builtin.group_by:\n    key: machine_{{ ansible_machine }}\n\n- name: Create groups like 'virt_kvm_host'\n  ansible.builtin.group_by:\n    key: virt_{{ ansible_virtualization_type }}_{{ ansible_virtualization_role }}\n\n- name: Create nested groups\n  ansible.builtin.group_by:\n    key: el{{ ansible_distribution_major_version }}-{{ ansible_architecture }}\n    parents:\n      - el{{ ansible_distribution_major_version }}\n\n- name: Add all active hosts to a static group\n  ansible.builtin.group_by:\n    key: done\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.hostname": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "full"
      },
      "facts": {
       "description": "Action returns an C(ansible_facts) dictionary that will update existing host facts",
       "support": "full"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "N/A"
      }
     },
     "author": [
      "Adrian Likins (@alikins)",
      "Hideki Saito (@saito-hideki)"
     ],
     "collection": "ansible.builtin",
     "description": [
      "Set system's hostname. Supports most OSs/Distributions including those using C(systemd).",
      "Windows, HP-UX, and AIX are not currently supported."
     ],
     "filename": "/ansible/modules/hostname.py",
     "has_action": false,
     "module": "hostname",
     "notes": [
      "This module does B(NOT) modify C(/etc/hosts). You need to modify it yourself using other modules such as M(ansible.builtin.template) or M(ansible.builtin.replace).",
      "On macOS, this module uses C(scutil) to set C(HostName), C(ComputerName), and C(LocalHostName). Since C(LocalHostName) cannot contain spaces or most special characters, this module will replace characters when setting C(LocalHostName)."
     ],
     "options": {
      "name": {
       "description": [
        "Name of the host.",
        "If the value is a fully qualified domain name that does not resolve from the given host, this will cause the module to hang for a few seconds while waiting for the name resolution attempt to timeout."
       ],
       "required": true,
       "type": "str"
      },
      "use": {
       "choices": [
        "alpine",
        "debian",
        "freebsd",
        "generic",
        "macos",
        "macosx",
        "darwin",
        "openbsd",
        "openrc",
        "redhat",
        "sles",
        "solaris",
        "systemd"
       ],
       "description": [
        "Which strategy to use to update the hostname.",
        "If not set we try to autodetect, but this can be problematic, particularly with containers as they can present misleading information.",
        "Note that 'systemd' should be specified for RHEL/EL/CentOS 7+. Older distributions should use 'redhat'."
       ],
       "type": "str",
       "version_added": "2.9",
       "version_added_collection": "ansible.builtin"
      }
     },
     "requirements": [
      "hostname"
     ],
     "short_description": "Manage hostname",
     "version_added": "1.4",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Set a hostname\n  ansible.builtin.hostname:\n    name: web01\n\n- name: Set a hostname specifying strategy\n  ansible.builtin.hostname:\n    name: web01\n    use: systemd\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.import_playbook": {
    "doc": {
     "attributes": {
      "action": {
       "description": "Indicates this has a corresponding action plugin so some parts of the options can be executed on the controller",
       "details": "While this action executes locally on the controller it is not governed by an action plugin",
       "support": "none"
      },
      "async": {
       "description": "Supports being used with the C(async) keyword",
       "support": "none"
      },
      "become": {
       "description": "Is usable alongside become keywords",
       "support": "none"
      },
      "bypass_host_loop": {
       "description": [
        "Forces a 'global' task that does not execute per host, this bypasses per host templating and serial, throttle and other loop considerations",
        "Conditionals will work as if C(run_once) is being used, variables used will be from the first available host",
        "This action will not work normally outside of lockstep strategies"
       ],
       "details": "While the import can be host specific and runs per host it is not dealing with all available host variables, use an include instead for those cases",
       "support": "partial"
      },
      "bypass_task_loop": {
       "description": "These tasks ignore the C(loop) and C(with_) keywords",
       "details": "The task itself is not looped, but the loop is applied to each imported task",
       "support": "partial"
      },
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "connection": {
       "description": "Uses the target's configured connection information to execute code on it",
       "support": "none"
      },
      "core": {
       "description": "This is a 'core engine' feature and is not implemented like most task actions, so it is not overridable in any way via the plugin system.",
       "support": "full"
      },
      "delegation": {
       "description": "Can be used in conjunction with delegate_to and related keywords",
       "details": "Since there are no connection nor facts, there is no sense in delegating imports",
       "support": "none"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "ignore_conditional": {
       "description": "The action is not subject to conditional execution so it will ignore the C(when:) keyword",
       "details": "While the action itself will ignore the conditional, it will be inherited by the imported tasks themselves",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "all",
       "support": "N/A"
      },
      "tags": {
       "description": "Allows for the 'tags' keyword to control the selection of this action for execution",
       "details": "Tags are not interpreted for this action, they are applied to the imported tasks",
       "support": "full"
      },
      "until": {
       "description": "Denotes if this action obeys until/retry/poll keywords",
       "support": "full"
      }
     },
     "author": "Ansible Core Team (@ansible)",
     "collection": "ansible.builtin",
     "description": [
      "Includes a file with a list of plays to be executed.",
      "Files with a list of plays can only be included at the top level.",
      "You cannot use this action inside a play."
     ],
     "filename": "/ansible/modules/import_playbook.py",
     "has_action": false,
     "module": "import_playbook",
     "notes": [
      "This is a core feature of Ansible, rather than a module, and cannot be overridden like a module."
     ],
     "options": {
      "free-form": {
       "description": [
        "The name of the imported playbook is specified directly without any other option."
       ]
      }
     },
     "seealso": [
      {
       "module": "ansible.builtin.import_role"
      },
      {
       "module": "ansible.builtin.import_tasks"
      },
      {
       "module": "ansible.builtin.include_role"
      },
      {
       "module": "ansible.builtin.include_tasks"
      },
      {
       "description": "More information related to including and importing playbooks, roles and tasks.",
       "ref": "playbooks_reuse"
      }
     ],
     "short_description": "Import a playbook",
     "version_added": "2.4",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- hosts: localhost\n  tasks:\n    - ansible.builtin.debug:\n        msg: play1\n\n- name: Include a play after another play\n  ansible.builtin.import_playbook: otherplays.yaml\n\n- name: Set variables on an imported playbook\n  ansible.builtin.import_playbook: otherplays.yml\n  vars:\n    service: httpd\n\n- name: Include a playbook from a collection\n  ansible.builtin.import_playbook: my_namespace.my_collection.my_playbook\n\n- name: This DOES NOT WORK\n  hosts: all\n  tasks:\n    - ansible.builtin.debug:\n        msg: task1\n\n    - name: This fails because I'm inside a play already\n      ansible.builtin.import_playbook: stuff.yaml\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.import_role": {
    "doc": {
     "attributes": {
      "action": {
       "description": "Indicates this has a corresponding action plugin so some parts of the options can be executed on the controller",
       "details": "While this action executes locally on the controller it is not governed by an action plugin",
       "support": "none"
      },
      "async": {
       "description": "Supports being used with the C(async) keyword",
       "support": "none"
      },
      "become": {
       "description": "Is usable alongside become keywords",
       "support": "none"
      },
      "bypass_host_loop": {
       "description": [
        "Forces a 'global' task that does not execute per host, this bypasses per host templating and serial, throttle and other loop considerations",
        "Conditionals will work as if C(run_once) is being used, variables used will be from the first available host",
        "This action will not work normally outside of lockstep strategies"
       ],
       "details": "While the import can be host specific and runs per host it is not dealing with all available host variables, use an include instead for those cases",
       "support": "partial"
      },
      "bypass_task_loop": {
       "description": "These tasks ignore the C(loop) and C(with_) keywords",
       "details": "The task itself is not looped, but the loop is applied to each imported task",
       "support": "partial"
      },
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "connection": {
       "description": "Uses the target's configured connection information to execute code on it",
       "support": "none"
      },
      "core": {
       "description": "This is a 'core engine' feature and is not implemented like most task actions, so it is not overridable in any way via the plugin system.",
       "support": "full"
      },
      "delegation": {
       "description": "Can be used in conjunction with delegate_to and related keywords",
       "details": "Since there are no connection nor facts, there is no sense in delegating imports",
       "support": "none"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "ignore_conditional": {
       "description": "The action is not subject to conditional execution so it will ignore the C(when:) keyword",
       "details": "While the action itself will ignore the conditional, it will be inherited by the imported tasks themselves",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "all",
       "support": "N/A"
      },
      "tags": {
       "description": "Allows for the 'tags' keyword to control the selection of this action for execution",
       "details": "Tags are not interpreted for this action, they are applied to the imported tasks",
       "support": "full"
      },
      "until": {
       "description": "Denotes if this action obeys until/retry/poll keywords",
       "support": "full"
      }
     },
     "author": "Ansible Core Team (@ansible)",
     "collection": "ansible.builtin",
     "description": [
      "Much like the C(roles:) keyword, this task loads a role, but it allows you to control when the role tasks run in between other tasks of the play.",
      "Most keywords, loops and conditionals will only be applied to the imported tasks, not to this statement itself. If you want the opposite behavior, use M(ansible.builtin.include_role) instead.",
      "Does not work in handlers."
     ],
     "filename": "/ansible/modules/import_role.py",
     "has_action": false,
     "module": "import_role",
     "notes": [
      "Handlers are made available to the whole play.",
      "Since Ansible 2.7 variables defined in C(vars) and C(defaults) for the role are exposed to the play at playbook parsing time. Due to this, these variables will be accessible to roles and tasks executed before the location of the M(ansible.builtin.import_role) task.",
      "Unlike M(ansible.builtin.include_role) variable exposure is not configurable, and will always be exposed."
     ],
     "options": {
      "allow_duplicates": {
       "default": true,
       "description": [
        "Overrides the role's metadata setting to allow using a role more than once with the same parameters."
       ],
       "type": "bool"
      },
      "defaults_from": {
       "default": "main",
       "description": [
        "File to load from a role's C(defaults/) directory."
       ],
       "type": "str"
      },
      "handlers_from": {
       "default": "main",
       "description": [
        "File to load from a role's C(handlers/) directory."
       ],
       "type": "str",
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      },
      "name": {
       "description": [
        "The name of the role to be executed."
       ],
       "required": true,
       "type": "str"
      },
      "public": {
       "default": true,
       "description": [
        "This option dictates whether the role's C(vars) and C(defaults) are exposed to the play.",
        "Variables are exposed to the play at playbook parsing time, and available to earlier roles and tasks as well unlike C(include_role).",
        "The default depends on the configuration option :ref:`default_private_role_vars`."
       ],
       "type": "bool",
       "version_added": "2.17",
       "version_added_collection": "ansible.builtin"
      },
      "rolespec_validate": {
       "default": true,
       "description": [
        "Perform role argument spec validation if an argument spec is defined."
       ],
       "type": "bool",
       "version_added": "2.11",
       "version_added_collection": "ansible.builtin"
      },
      "tasks_from": {
       "default": "main",
       "description": [
        "File to load from a role's C(tasks/) directory."
       ],
       "type": "str"
      },
      "vars_from": {
       "default": "main",
       "description": [
        "File to load from a role's C(vars/) directory."
       ],
       "type": "str"
      }
     },
     "seealso": [
      {
       "module": "ansible.builtin.import_playbook"
      },
      {
       "module": "ansible.builtin.import_tasks"
      },
      {
       "module": "ansible.builtin.include_role"
      },
      {
       "module": "ansible.builtin.include_tasks"
      },
      {
       "description": "More information related to including and importing playbooks, roles and tasks.",
       "ref": "playbooks_reuse"
      }
     ],
     "short_description": "Import a role into a play",
     "version_added": "2.4",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- hosts: all\n  tasks:\n    - ansible.builtin.import_role:\n        name: myrole\n\n    - name: Run tasks/other.yaml instead of 'main'\n      ansible.builtin.import_role:\n        name: myrole\n        tasks_from: other\n\n    - name: Pass variables to role\n      ansible.builtin.import_role:\n        name: myrole\n      vars:\n        rolevar1: value from task\n\n    - name: Apply condition to each task in role\n      ansible.builtin.import_role:\n        name: myrole\n      when: not idontwanttorun\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.import_tasks": {
    "doc": {
     "attributes": {
      "action": {
       "description": "Indicates this has a corresponding action plugin so some parts of the options can be executed on the controller",
       "details": "While this action executes locally on the controller it is not governed by an action plugin",
       "support": "none"
      },
      "async": {
       "description": "Supports being used with the C(async) keyword",
       "support": "none"
      },
      "become": {
       "description": "Is usable alongside become keywords",
       "support": "none"
      },
      "bypass_host_loop": {
       "description": [
        "Forces a 'global' task that does not execute per host, this bypasses per host templating and serial, throttle and other loop considerations",
        "Conditionals will work as if C(run_once) is being used, variables used will be from the first available host",
        "This action will not work normally outside of lockstep strategies"
       ],
       "details": "While the import can be host specific and runs per host it is not dealing with all available host variables, use an include instead for those cases",
       "support": "partial"
      },
      "bypass_task_loop": {
       "description": "These tasks ignore the C(loop) and C(with_) keywords",
       "details": "The task itself is not looped, but the loop is applied to each imported task",
       "support": "partial"
      },
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "none"
      },
      "connection": {
       "description": "Uses the target's configured connection information to execute code on it",
       "support": "none"
      },
      "core": {
       "description": "This is a 'core engine' feature and is not implemented like most task actions, so it is not overridable in any way via the plugin system.",
       "support": "full"
      },
      "delegation": {
       "description": "Can be used in conjunction with delegate_to and related keywords",
       "details": "Since there are no connection nor facts, there is no sense in delegating imports",
       "support": "none"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "ignore_conditional": {
       "description": "The action is not subject to conditional execution so it will ignore the C(when:) keyword",
       "details": "While the action itself will ignore the conditional, it will be inherited by the imported tasks themselves",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "all",
       "support": "N/A"
      },
      "tags": {
       "description": "Allows for the 'tags' keyword to control the selection of this action for execution",
       "details": "Tags are not interpreted for this action, they are applied to the imported tasks",
       "support": "full"
      },
      "until": {
       "description": "Denotes if this action obeys until/retry/poll keywords",
       "support": "full"
      }
     },
     "author": "Ansible Core Team (@ansible)",
     "collection": "ansible.builtin",
     "description": [
      "Imports a list of tasks to be added to the current playbook for subsequent execution."
     ],
     "filename": "/ansible/modules/import_tasks.py",
     "has_action": false,
     "module": "import_tasks",
     "notes": [
      "This is a core feature of Ansible, rather than a module, and cannot be overridden like a module"
     ],
     "options": {
      "file": {
       "description": [
        "Specifies the name of the file that lists tasks to add to the current playbook."
       ],
       "type": "str",
       "version_added": "2.7",
       "version_added_collection": "ansible.builtin"
      },
      "free-form": {
       "description": [
        "Specifies the name of the imported file directly without any other option C(- import_tasks: file.yml).\n",
        "Most keywords, including loops and conditionals, only apply to the imported tasks, not to this statement itself.",
        "If you need any of those to apply, use M(ansible.builtin.include_tasks) instead."
       ]
      }
     },
     "seealso": [
      {
       "module": "ansible.builtin.import_playbook"
      },
      {
       "module": "ansible.builtin.import_role"
      },
      {
       "module": "ansible.builtin.include_role"
      },
      {
       "module": "ansible.builtin.include_tasks"
      },
      {
       "description": "More information related to including and importing playbooks, roles and tasks.",
       "ref": "playbooks_reuse"
      }
     ],
     "short_description": "Import a task list",
     "version_added": "2.4",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- hosts: all\n  tasks:\n    - ansible.builtin.debug:\n        msg: task1\n\n    - name: Include task list in play\n      ansible.builtin.import_tasks:\n        file: stuff.yaml\n\n    - ansible.builtin.debug:\n        msg: task10\n\n- hosts: all\n  tasks:\n    - ansible.builtin.debug:\n        msg: task1\n\n    - name: Apply conditional to all imported tasks\n      ansible.builtin.import_tasks: stuff.yaml\n      when: hostvar is defined\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.include_role": {
    "doc": {
     "attributes": {
      "action": {
       "description": "Indicates this has a corresponding action plugin so some parts of the options can be executed on the controller",
       "details": "While this action executes locally on the controller it is not governed by an action plugin",
       "support": "none"
      },
      "async": {
       "description": "Supports being used with the C(async) keyword",
       "support": "none"
      },
      "become": {
       "description": "Is usable alongside become keywords",
       "support": "none"
      },
      "bypass_host_loop": {
       "description": [
        "Forces a 'global' task that does not execute per host, this bypasses per host templating and serial, throttle and other loop considerations",
        "Conditionals will work as if C(run_once) is being used, variables used will be from the first available host",
        "This action will not work normally outside of lockstep strategies"
       ],
       "support": "none"
      },
      "bypass_task_loop": {
       "description": "These tasks ignore the C(loop) and C(with_) keywords",
       "support": "none"
      },
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "connection": {
       "description": "Uses the target's configured connection information to execute code on it",
       "support": "none"
      },
      "core": {
       "description": "This is a 'core engine' feature and is not implemented like most task actions, so it is not overridable in any way via the plugin system.",
       "support": "full"
      },
      "delegation": {
       "description": "Can be used in conjunction with delegate_to and related keywords",
       "details": "Since there are no connection nor facts, there is no sense in delegating includes",
       "support": "none"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "ignore_conditional": {
       "description": "The action is not subject to conditional execution so it will ignore the C(when:) keyword",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "all",
       "support": "N/A"
      },
      "tags": {
       "description": "Allows for the 'tags' keyword to control the selection of this action for execution",
       "details": "Tags are interpreted by this action but are not automatically inherited by the include tasks, see C(apply)",
       "support": "full"
      },
      "until": {
       "description": "Denotes if this action obeys until/retry/poll keywords",
       "support": "full"
      }
     },
     "author": "Ansible Core Team (@ansible)",
     "collection": "ansible.builtin",
     "description": [
      "Dynamically loads and executes a specified role as a task.",
      "May be used only where Ansible tasks are allowed - inside C(pre_tasks), C(tasks), or C(post_tasks) play objects, or as a task inside a role.",
      "Task-level keywords, loops, and conditionals apply only to the C(include_role) statement itself.",
      "To apply keywords to the tasks within the role, pass them using the O(apply) option or use M(ansible.builtin.import_role) instead.",
      "Ignores some keywords, like C(until) and C(retries).",
      "This module is also supported for Windows targets.",
      "Does not work in handlers."
     ],
     "filename": "/ansible/modules/include_role.py",
     "has_action": false,
     "module": "include_role",
     "notes": [
      "Handlers and are made available to the whole play.",
      "After Ansible 2.4, you can use M(ansible.builtin.import_role) for B(static) behaviour and this action for B(dynamic) one."
     ],
     "options": {
      "allow_duplicates": {
       "default": true,
       "description": [
        "Overrides the role's metadata setting to allow using a role more than once with the same parameters."
       ],
       "type": "bool"
      },
      "apply": {
       "description": [
        "Accepts a hash of task keywords (for example C(tags), C(become)) that will be applied to all tasks within the included role."
       ],
       "version_added": "2.7",
       "version_added_collection": "ansible.builtin"
      },
      "defaults_from": {
       "default": "main",
       "description": [
        "File to load from a role's C(defaults/) directory."
       ],
       "type": "str"
      },
      "handlers_from": {
       "default": "main",
       "description": [
        "File to load from a role's C(handlers/) directory."
       ],
       "type": "str",
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      },
      "name": {
       "description": [
        "The name of the role to be executed."
       ],
       "required": true,
       "type": "str"
      },
      "public": {
       "default": false,
       "description": [
        "This option dictates whether the role's C(vars) and C(defaults) are exposed to the play. If set to V(true) the variables will be available to tasks following the C(include_role) task. This functionality differs from standard variable exposure for roles listed under the C(roles) header or M(ansible.builtin.import_role) as they are exposed to the play at playbook parsing time, and available to earlier roles and tasks as well."
       ],
       "type": "bool",
       "version_added": "2.7",
       "version_added_collection": "ansible.builtin"
      },
      "rolespec_validate": {
       "default": true,
       "description": [
        "Perform role argument spec validation if an argument spec is defined."
       ],
       "type": "bool",
       "version_added": "2.11",
       "version_added_collection": "ansible.builtin"
      },
      "tasks_from": {
       "default": "main",
       "description": [
        "File to load from a role's C(tasks/) directory."
       ],
       "type": "str"
      },
      "vars_from": {
       "default": "main",
       "description": [
        "File to load from a role's C(vars/) directory."
       ],
       "type": "str"
      }
     },
     "seealso": [
      {
       "module": "ansible.builtin.import_playbook"
      },
      {
       "module": "ansible.builtin.import_role"
      },
      {
       "module": "ansible.builtin.import_tasks"
      },
      {
       "module": "ansible.builtin.include_tasks"
      },
      {
       "description": "More information related to including and importing playbooks, roles and tasks.",
       "ref": "playbooks_reuse"
      }
     ],
     "short_description": "Load and execute a role",
     "version_added": "2.2",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- ansible.builtin.include_role:\n    name: myrole\n\n- name: Run tasks/other.yaml instead of 'main'\n  ansible.builtin.include_role:\n    name: myrole\n    tasks_from: other\n\n- name: Pass variables to role\n  ansible.builtin.include_role:\n    name: myrole\n  vars:\n    rolevar1: value from task\n\n- name: Use role in loop\n  ansible.builtin.include_role:\n    name: '{{ roleinputvar }}'\n  loop:\n    - '{{ roleinput1 }}'\n    - '{{ roleinput2 }}'\n  loop_control:\n    loop_var: roleinputvar\n\n- name: Conditional role\n  ansible.builtin.include_role:\n    name: myrole\n  when: not idontwanttorun\n\n- name: Apply tags to tasks within included file\n  ansible.builtin.include_role:\n    name: install\n    apply:\n      tags:\n        - install\n  tags:\n    - always\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.include_tasks": {
    "doc": {
     "attributes": {
      "action": {
       "description": "Indicates this has a corresponding action plugin so some parts of the options can be executed on the controller",
       "details": "While this action executes locally on the controller it is not governed by an action plugin",
       "support": "none"
      },
      "async": {
       "description": "Supports being used with the C(async) keyword",
       "support": "none"
      },
      "become": {
       "description": "Is usable alongside become keywords",
       "support": "none"
      },
      "bypass_host_loop": {
       "description": [
        "Forces a 'global' task that does not execute per host, this bypasses per host templating and serial, throttle and other loop considerations",
        "Conditionals will work as if C(run_once) is being used, variables used will be from the first available host",
        "This action will not work normally outside of lockstep strategies"
       ],
       "support": "none"
      },
      "bypass_task_loop": {
       "description": "These tasks ignore the C(loop) and C(with_) keywords",
       "support": "none"
      },
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "none"
      },
      "connection": {
       "description": "Uses the target's configured connection information to execute code on it",
       "support": "none"
      },
      "core": {
       "description": "This is a 'core engine' feature and is not implemented like most task actions, so it is not overridable in any way via the plugin system.",
       "support": "full"
      },
      "delegation": {
       "description": "Can be used in conjunction with delegate_to and related keywords",
       "details": "Since there are no connection nor facts, there is no sense in delegating includes",
       "support": "none"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "ignore_conditional": {
       "description": "The action is not subject to conditional execution so it will ignore the C(when:) keyword",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "all",
       "support": "N/A"
      },
      "tags": {
       "description": "Allows for the 'tags' keyword to control the selection of this action for execution",
       "details": "Tags are interpreted by this action but are not automatically inherited by the include tasks, see C(apply)",
       "support": "full"
      },
      "until": {
       "description": "Denotes if this action obeys until/retry/poll keywords",
       "support": "full"
      }
     },
     "author": "Ansible Core Team (@ansible)",
     "collection": "ansible.builtin",
     "description": [
      "Includes a file with a list of tasks to be executed in the current playbook."
     ],
     "filename": "/ansible/modules/include_tasks.py",
     "has_action": false,
     "module": "include_tasks",
     "options": {
      "apply": {
       "description": [
        "Accepts a hash of task keywords (for example C(tags), C(become)) that will be applied to the tasks within the include."
       ],
       "type": "str",
       "version_added": "2.7",
       "version_added_collection": "ansible.builtin"
      },
      "file": {
       "description": [
        "Specifies the name of the file that lists tasks to add to the current playbook."
       ],
       "type": "str",
       "version_added": "2.7",
       "version_added_collection": "ansible.builtin"
      },
      "free-form": {
       "description": [
        "Specifies the name of the imported file directly without any other option C(- include_tasks: file.yml).\n",
        "Is the equivalent of specifying an argument for the O(file) parameter.",
        "Most keywords, including loop, with_items, and conditionals, apply to this statement unlike M(ansible.builtin.import_tasks).",
        "The do-until loop is not supported."
       ]
      }
     },
     "seealso": [
      {
       "module": "ansible.builtin.import_playbook"
      },
      {
       "module": "ansible.builtin.import_role"
      },
      {
       "module": "ansible.builtin.import_tasks"
      },
      {
       "module": "ansible.builtin.include_role"
      },
      {
       "description": "More information related to including and importing playbooks, roles and tasks.",
       "ref": "playbooks_reuse"
      }
     ],
     "short_description": "Dynamically include a task list",
     "version_added": "2.4",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- hosts: all\n  tasks:\n    - ansible.builtin.debug:\n        msg: task1\n\n    - name: Include task list in play\n      ansible.builtin.include_tasks:\n        file: stuff.yaml\n\n    - ansible.builtin.debug:\n        msg: task10\n\n- hosts: all\n  tasks:\n    - ansible.builtin.debug:\n        msg: task1\n\n    - name: Include task list in play only if the condition is true\n      ansible.builtin.include_tasks: \"{{ hostvar }}.yaml\"\n      when: hostvar is defined\n\n- name: Apply tags to tasks within included file\n  ansible.builtin.include_tasks:\n    file: install.yml\n    apply:\n      tags:\n        - install\n  tags:\n    - always\n\n- name: Apply tags to tasks within included file when using free-form\n  ansible.builtin.include_tasks: install.yml\n  args:\n    apply:\n      tags:\n        - install\n  tags:\n    - always\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.include_vars": {
    "doc": {
     "attributes": {
      "action": {
       "description": "Indicates this has a corresponding action plugin so some parts of the options can be executed on the controller",
       "details": "While the action plugin does do some of the work it relies on the core engine to actually create the variables, that part cannot be overridden",
       "support": "partial"
      },
      "async": {
       "description": "Supports being used with the C(async) keyword",
       "support": "none"
      },
      "become": {
       "description": "Is usable alongside become keywords",
       "support": "none"
      },
      "bypass_host_loop": {
       "description": [
        "Forces a 'global' task that does not execute per host, this bypasses per host templating and serial, throttle and other loop considerations",
        "Conditionals will work as if C(run_once) is being used, variables used will be from the first available host",
        "This action will not work normally outside of lockstep strategies"
       ],
       "support": "none"
      },
      "bypass_task_loop": {
       "description": "These tasks ignore the C(loop) and C(with_) keywords",
       "support": "none"
      },
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "connection": {
       "description": "Uses the target's configured connection information to execute code on it",
       "support": "none"
      },
      "core": {
       "description": "This is a 'core engine' feature and is not implemented like most task actions, so it is not overridable in any way via the plugin system.",
       "details": "While parts of this action are implemented in core, other parts are still available as normal plugins and can be partially overridden",
       "support": "partial"
      },
      "delegation": {
       "description": "Can be used in conjunction with delegate_to and related keywords",
       "details": [
        "while variable assignment can be delegated to a different host the execution context is always the current inventory_hostname",
        "connection variables, if set at all, would reflect the host it would target, even if we are not connecting at all in this case"
       ],
       "support": "partial"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "ignore_conditional": {
       "description": "The action is not subject to conditional execution so it will ignore the C(when:) keyword",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "all",
       "support": "N/A"
      },
      "tags": {
       "description": "Allows for the 'tags' keyword to control the selection of this action for execution",
       "support": "full"
      },
      "until": {
       "description": "Denotes if this action obeys until/retry/poll keywords",
       "support": "full"
      }
     },
     "author": "Allen Sanabria (@linuxdynasty)",
     "collection": "ansible.builtin",
     "description": [
      "Loads YAML/JSON variables dynamically from a file or directory, recursively, during task runtime.",
      "If loading a directory, the files are sorted alphabetically before being loaded.",
      "This module is also supported for Windows targets.",
      "To assign included variables to a different host than C(inventory_hostname), use C(delegate_to) and set C(delegate_facts=yes)."
     ],
     "filename": "/ansible/modules/include_vars.py",
     "has_action": true,
     "module": "include_vars",
     "options": {
      "depth": {
       "default": 0,
       "description": [
        "When using O(dir), this module will, by default, recursively go through each sub directory and load up the variables. By explicitly setting the depth, this module will only go as deep as the depth."
       ],
       "type": "int",
       "version_added": "2.2",
       "version_added_collection": "ansible.builtin"
      },
      "dir": {
       "description": [
        "The directory name from which the variables should be loaded.",
        "If the path is relative and the task is inside a role, it will look inside the role's vars/ subdirectory.",
        "If the path is relative and not inside a role, it will be parsed relative to the playbook."
       ],
       "type": "path",
       "version_added": "2.2",
       "version_added_collection": "ansible.builtin"
      },
      "extensions": {
       "default": [
        "json",
        "yaml",
        "yml"
       ],
       "description": [
        "List of file extensions to read when using O(dir)."
       ],
       "elements": "str",
       "type": "list",
       "version_added": "2.3",
       "version_added_collection": "ansible.builtin"
      },
      "file": {
       "description": [
        "The file name from which variables should be loaded.",
        "If the path is relative, it will look for the file in vars/ subdirectory of a role or relative to playbook."
       ],
       "type": "path",
       "version_added": "2.2",
       "version_added_collection": "ansible.builtin"
      },
      "files_matching": {
       "description": [
        "Limit the files that are loaded within any directory to this regular expression."
       ],
       "type": "str",
       "version_added": "2.2",
       "version_added_collection": "ansible.builtin"
      },
      "free-form": {
       "description": [
        "This module allows you to specify the 'file' option directly without any other options.",
        "There is no 'free-form' option, this is just an indicator, see example below."
       ]
      },
      "hash_behaviour": {
       "choices": [
        "replace",
        "merge"
       ],
       "default": null,
       "description": [
        "If set to V(merge), merges existing hash variables instead of overwriting them.",
        "If omitted (V(null)), the behavior falls back to the global C(hash_behaviour) configuration.",
        "This option is self-contained and does not apply to individual files in O(dir). You can use a loop to apply O(hash_behaviour) per file."
       ],
       "type": "str",
       "version_added": "2.12",
       "version_added_collection": "ansible.builtin"
      },
      "ignore_files": {
       "description": [
        "List of file names to ignore."
       ],
       "elements": "str",
       "type": "list",
       "version_added": "2.2",
       "version_added_collection": "ansible.builtin"
      },
      "ignore_unknown_extensions": {
       "default": false,
       "description": [
        "Ignore unknown file extensions within the directory.",
        "This allows users to specify a directory containing vars files that are intermingled with non-vars files extension types (e.g. a directory with a README in it and vars files)."
       ],
       "type": "bool",
       "version_added": "2.7",
       "version_added_collection": "ansible.builtin"
      },
      "name": {
       "description": [
        "The name of a variable into which assign the included vars.",
        "If omitted (null) they will be made top level vars."
       ],
       "type": "str",
       "version_added": "2.2",
       "version_added_collection": "ansible.builtin"
      }
     },
     "seealso": [
      {
       "module": "ansible.builtin.set_fact"
      },
      {
       "description": "More information related to task delegation.",
       "ref": "playbooks_delegation"
      }
     ],
     "short_description": "Load variables from files, dynamically within a task",
     "version_added": "1.4",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Include vars of stuff.yaml into the 'stuff' variable (2.2).\n  ansible.builtin.include_vars:\n    file: stuff.yaml\n    name: stuff\n\n- name: Conditionally decide to load in variables into 'plans' when x is 0, otherwise do not. (2.2)\n  ansible.builtin.include_vars:\n    file: contingency_plan.yaml\n    name: plans\n  when: x == 0\n\n- name: Load a variable file based on the OS type, or a default if not found. Using free-form to specify the file.\n  ansible.builtin.include_vars: \"{{ lookup('ansible.builtin.first_found', params) }}\"\n  vars:\n    params:\n      files:\n        - '{{ansible_distribution}}.yaml'\n        - '{{ansible_os_family}}.yaml'\n        - default.yaml\n      paths:\n        - 'vars'\n\n- name: Bare include (free-form)\n  ansible.builtin.include_vars: myvars.yaml\n\n- name: Include all .json and .jsn files in vars/all and all nested directories (2.3)\n  ansible.builtin.include_vars:\n    dir: vars/all\n    extensions:\n      - 'json'\n      - 'jsn'\n\n- name: Include all default extension files in vars/all and all nested directories and save the output in test. (2.2)\n  ansible.builtin.include_vars:\n    dir: vars/all\n    name: test\n\n- name: Include default extension files in vars/services (2.2)\n  ansible.builtin.include_vars:\n    dir: vars/services\n    depth: 1\n\n- name: Include only files matching bastion.yaml (2.2)\n  ansible.builtin.include_vars:\n    dir: vars\n    files_matching: bastion.yaml\n\n- name: Include all .yaml files except bastion.yaml (2.3)\n  ansible.builtin.include_vars:\n    dir: vars\n    ignore_files:\n      - 'bastion.yaml'\n    extensions:\n      - 'yaml'\n\n- name: Ignore warnings raised for files with unknown extensions while loading (2.7)\n  ansible.builtin.include_vars:\n    dir: vars\n    ignore_unknown_extensions: True\n    extensions:\n      - ''\n      - 'yaml'\n      - 'yml'\n      - 'json'\n",
    "metadata": null,
    "return": {
     "ansible_facts": {
      "description": "Variables that were included and their values",
      "returned": "success",
      "sample": {
       "variable": "value"
      },
      "type": "dict"
     },
     "ansible_included_var_files": {
      "description": "A list of files that were successfully included",
      "returned": "success",
      "sample": [
       "/path/to/file.json",
       "/path/to/file.yaml"
      ],
      "type": "list",
      "version_added": "2.4",
      "version_added_collection": "ansible.builtin"
     }
    }
   },
   "ansible.builtin.iptables": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "linux",
       "support": "N/A"
      }
     },
     "author": [
      "Linus Unneb\u00e4ck (@LinusU) <linus@folkdatorn.se>",
      "S\u00e9bastien DA ROCHA (@sebastiendarocha)"
     ],
     "collection": "ansible.builtin",
     "description": [
      "M(ansible.builtin.iptables) is used to set up, maintain, and inspect the tables of IP packet filter rules in the Linux kernel.",
      "This module does not handle the saving and/or loading of rules, but rather only manipulates the current rules that are present in memory. This is the same as the behaviour of the C(iptables) and C(ip6tables) command which this module uses internally."
     ],
     "filename": "/ansible/modules/iptables.py",
     "has_action": false,
     "module": "iptables",
     "notes": [
      "This module just deals with individual rules. If you need advanced chaining of rules the recommended way is to template the iptables restore file."
     ],
     "options": {
      "action": {
       "choices": [
        "append",
        "insert"
       ],
       "default": "append",
       "description": [
        "Whether the rule should be appended at the bottom or inserted at the top.",
        "If the rule already exists the chain will not be modified."
       ],
       "type": "str",
       "version_added": "2.2",
       "version_added_collection": "ansible.builtin"
      },
      "chain": {
       "description": [
        "Specify the iptables chain to modify.",
        "This could be a user-defined chain or one of the standard iptables chains, like V(INPUT), V(FORWARD), V(OUTPUT), V(PREROUTING), V(POSTROUTING), V(SECMARK) or V(CONNSECMARK)."
       ],
       "type": "str"
      },
      "chain_management": {
       "default": false,
       "description": [
        "If V(true) and O(state) is V(present), the chain will be created if needed.",
        "If V(true) and O(state) is V(absent), the chain will be deleted if the only other parameter passed are O(chain) and optionally O(table)."
       ],
       "type": "bool",
       "version_added": "2.13",
       "version_added_collection": "ansible.builtin"
      },
      "comment": {
       "description": [
        "This specifies a comment that will be added to the rule."
       ],
       "type": "str"
      },
      "ctstate": {
       "default": [],
       "description": [
        "A list of the connection states to match in the conntrack module.",
        "Possible values are V(INVALID), V(NEW), V(ESTABLISHED), V(RELATED), V(UNTRACKED), V(SNAT), V(DNAT)."
       ],
       "elements": "str",
       "type": "list"
      },
      "destination": {
       "description": [
        "Destination specification.",
        "Address can be either a network name, a hostname, a network IP address (with /mask), or a plain IP address.",
        "Hostnames will be resolved once only, before the rule is submitted to the kernel. Please note that specifying any name to be resolved with a remote query such as DNS is a really bad idea.",
        "The mask can be either a network mask or a plain number, specifying the number of 1's at the left side of the network mask. Thus, a mask of 24 is equivalent to 255.255.255.0. A V(!) argument before the address specification inverts the sense of the address."
       ],
       "type": "str"
      },
      "destination_port": {
       "description": [
        "Destination port or port range specification. This can either be a service name or a port number. An inclusive range can also be specified, using the format first:last. If the first port is omitted, '0' is assumed; if the last is omitted, '65535' is assumed. If the first port is greater than the second one they will be swapped. This is only valid if the rule also specifies one of the following protocols: tcp, udp, dccp or sctp."
       ],
       "type": "str"
      },
      "destination_ports": {
       "default": [],
       "description": [
        "This specifies multiple destination port numbers or port ranges to match in the multiport module.",
        "It can only be used in conjunction with the protocols tcp, udp, udplite, dccp and sctp."
       ],
       "elements": "str",
       "type": "list",
       "version_added": "2.11",
       "version_added_collection": "ansible.builtin"
      },
      "dst_range": {
       "description": [
        "Specifies the destination IP range to match in the iprange module."
       ],
       "type": "str",
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      },
      "flush": {
       "default": false,
       "description": [
        "Flushes the specified table and chain of all rules.",
        "If no chain is specified then the entire table is purged.",
        "Ignores all other parameters."
       ],
       "type": "bool",
       "version_added": "2.2",
       "version_added_collection": "ansible.builtin"
      },
      "fragment": {
       "description": [
        "This means that the rule only refers to second and further fragments of fragmented packets.",
        "Since there is no way to tell the source or destination ports of such a packet (or ICMP type), such a packet will not match any rules which specify them.",
        "When the \"!\" argument precedes the fragment argument, the rule will only match head fragments, or unfragmented packets."
       ],
       "type": "str"
      },
      "gateway": {
       "description": [
        "This specifies the IP address of the host to send the cloned packets.",
        "This option is only valid when O(jump) is set to V(TEE)."
       ],
       "type": "str",
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      },
      "gid_owner": {
       "description": [
        "Specifies the GID or group to use in the match by owner rule."
       ],
       "type": "str",
       "version_added": "2.9",
       "version_added_collection": "ansible.builtin"
      },
      "goto": {
       "description": [
        "This specifies that the processing should continue in a user-specified chain.",
        "Unlike the jump argument return will not continue processing in this chain but instead in the chain that called us via jump."
       ],
       "type": "str"
      },
      "icmp_type": {
       "description": [
        "This allows specification of the ICMP type, which can be a numeric ICMP type, type/code pair, or one of the ICMP type names shown by the command 'iptables -p icmp -h'"
       ],
       "type": "str",
       "version_added": "2.2",
       "version_added_collection": "ansible.builtin"
      },
      "in_interface": {
       "description": [
        "Name of an interface via which a packet was received (only for packets entering the V(INPUT), V(FORWARD) and V(PREROUTING) chains).",
        "When the V(!) argument is used before the interface name, the sense is inverted.",
        "If the interface name ends in a V(+), then any interface which begins with this name will match.",
        "If this option is omitted, any interface name will match."
       ],
       "type": "str"
      },
      "ip_version": {
       "choices": [
        "ipv4",
        "ipv6"
       ],
       "default": "ipv4",
       "description": [
        "Which version of the IP protocol this rule should apply to."
       ],
       "type": "str"
      },
      "jump": {
       "description": [
        "This specifies the target of the rule; i.e., what to do if the packet matches it.",
        "The target can be a user-defined chain (other than the one this rule is in), one of the special builtin targets that decide the fate of the packet immediately, or an extension (see EXTENSIONS below).",
        "If this option is omitted in a rule (and the goto parameter is not used), then matching the rule will have no effect on the packet's fate, but the counters on the rule will be incremented."
       ],
       "type": "str"
      },
      "limit": {
       "description": [
        "Specifies the maximum average number of matches to allow per second.",
        "The number can specify units explicitly, using C(/second), C(/minute), C(/hour) or C(/day), or parts of them (so V(5/second) is the same as V(5/s))."
       ],
       "type": "str"
      },
      "limit_burst": {
       "description": [
        "Specifies the maximum burst before the above limit kicks in."
       ],
       "type": "str",
       "version_added": "2.1",
       "version_added_collection": "ansible.builtin"
      },
      "log_level": {
       "choices": [
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "emerg",
        "alert",
        "crit",
        "error",
        "warning",
        "notice",
        "info",
        "debug"
       ],
       "description": [
        "Logging level according to the syslogd-defined priorities.",
        "The value can be strings or numbers from 1-8.",
        "This parameter is only applicable if O(jump) is set to V(LOG)."
       ],
       "type": "str",
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      },
      "log_prefix": {
       "description": [
        "Specifies a log text for the rule. Only makes sense with a LOG jump."
       ],
       "type": "str",
       "version_added": "2.5",
       "version_added_collection": "ansible.builtin"
      },
      "match": {
       "default": [],
       "description": [
        "Specifies a match to use, that is, an extension module that tests for a specific property.",
        "The set of matches makes up the condition under which a target is invoked.",
        "Matches are evaluated first to last if specified as an array and work in short-circuit fashion, i.e. if one extension yields false, the evaluation will stop."
       ],
       "elements": "str",
       "type": "list"
      },
      "match_set": {
       "description": [
        "Specifies a set name that can be defined by ipset.",
        "Must be used together with the match_set_flags parameter.",
        "When the V(!) argument is prepended then it inverts the rule.",
        "Uses the iptables set extension."
       ],
       "type": "str",
       "version_added": "2.11",
       "version_added_collection": "ansible.builtin"
      },
      "match_set_flags": {
       "choices": [
        "src",
        "dst",
        "src,dst",
        "dst,src"
       ],
       "description": [
        "Specifies the necessary flags for the match_set parameter.",
        "Must be used together with the match_set parameter.",
        "Uses the iptables set extension."
       ],
       "type": "str",
       "version_added": "2.11",
       "version_added_collection": "ansible.builtin"
      },
      "numeric": {
       "default": false,
       "description": [
        "This parameter controls the running of the list -action of iptables, which is used internally by the module",
        "Does not affect the actual functionality. Use this if iptables hang when creating a chain or altering policy",
        "If V(true), then iptables skips the DNS-lookup of the IP addresses in a chain when it uses the list -action",
        "Listing is used internally for example when setting a policy or creating a chain"
       ],
       "type": "bool",
       "version_added": "2.15",
       "version_added_collection": "ansible.builtin"
      },
      "out_interface": {
       "description": [
        "Name of an interface via which a packet is going to be sent (for packets entering the V(FORWARD), V(OUTPUT) and V(POSTROUTING) chains).",
        "When the V(!) argument is used before the interface name, the sense is inverted.",
        "If the interface name ends in a V(+), then any interface which begins with this name will match.",
        "If this option is omitted, any interface name will match."
       ],
       "type": "str"
      },
      "policy": {
       "choices": [
        "ACCEPT",
        "DROP",
        "QUEUE",
        "RETURN"
       ],
       "description": [
        "Set the policy for the chain to the given target.",
        "Only built-in chains can have policies.",
        "This parameter requires the O(chain) parameter.",
        "If you specify this parameter, all other parameters will be ignored.",
        "This parameter is used to set the default policy for the given O(chain). Do not confuse this with O(jump) parameter."
       ],
       "type": "str",
       "version_added": "2.2",
       "version_added_collection": "ansible.builtin"
      },
      "protocol": {
       "description": [
        "The protocol of the rule or of the packet to check.",
        "The specified protocol can be one of V(tcp), V(udp), V(udplite), V(icmp), V(ipv6-icmp) or V(icmpv6), V(esp), V(ah), V(sctp) or the special keyword V(all), or it can be a numeric value, representing one of these protocols or a different one.",
        "A protocol name from C(/etc/protocols) is also allowed.",
        "A V(!) argument before the protocol inverts the test.",
        "The number zero is equivalent to all.",
        "V(all) will match with all protocols and is taken as default when this option is omitted."
       ],
       "type": "str"
      },
      "reject_with": {
       "description": [
        "Specifies the error packet type to return while rejecting. It implies \"jump: REJECT\"."
       ],
       "type": "str",
       "version_added": "2.1",
       "version_added_collection": "ansible.builtin"
      },
      "rule_num": {
       "description": [
        "Insert the rule as the given rule number.",
        "This works only with O(action=insert)."
       ],
       "type": "str",
       "version_added": "2.5",
       "version_added_collection": "ansible.builtin"
      },
      "set_counters": {
       "description": [
        "This enables the administrator to initialize the packet and byte counters of a rule (during V(INSERT), V(APPEND), V(REPLACE) operations)."
       ],
       "type": "str"
      },
      "set_dscp_mark": {
       "description": [
        "This allows specifying a DSCP mark to be added to packets. It takes either an integer or hex value.",
        "If the parameter is set, O(jump) is set to V(DSCP).",
        "Mutually exclusive with O(set_dscp_mark_class)."
       ],
       "type": "str",
       "version_added": "2.1",
       "version_added_collection": "ansible.builtin"
      },
      "set_dscp_mark_class": {
       "description": [
        "This allows specifying a predefined DiffServ class which will be translated to the corresponding DSCP mark.",
        "If the parameter is set, O(jump) is set to V(DSCP).",
        "Mutually exclusive with O(set_dscp_mark)."
       ],
       "type": "str",
       "version_added": "2.1",
       "version_added_collection": "ansible.builtin"
      },
      "source": {
       "description": [
        "Source specification.",
        "Address can be either a network name, a hostname, a network IP address (with /mask), or a plain IP address.",
        "Hostnames will be resolved once only, before the rule is submitted to the kernel. Please note that specifying any name to be resolved with a remote query such as DNS is a really bad idea.",
        "The mask can be either a network mask or a plain number, specifying the number of 1's at the left side of the network mask. Thus, a mask of 24 is equivalent to 255.255.255.0. A V(!) argument before the address specification inverts the sense of the address."
       ],
       "type": "str"
      },
      "source_port": {
       "description": [
        "Source port or port range specification.",
        "This can either be a service name or a port number.",
        "An inclusive range can also be specified, using the format C(first:last).",
        "If the first port is omitted, V(0) is assumed; if the last is omitted, V(65535) is assumed.",
        "If the first port is greater than the second one they will be swapped."
       ],
       "type": "str"
      },
      "src_range": {
       "description": [
        "Specifies the source IP range to match the iprange module."
       ],
       "type": "str",
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      },
      "state": {
       "choices": [
        "absent",
        "present"
       ],
       "default": "present",
       "description": [
        "Whether the rule should be absent or present."
       ],
       "type": "str"
      },
      "syn": {
       "choices": [
        "ignore",
        "match",
        "negate"
       ],
       "default": "ignore",
       "description": [
        "This allows matching packets that have the SYN bit set and the ACK and RST bits unset.",
        "When negated, this matches all packets with the RST or the ACK bits set."
       ],
       "type": "str",
       "version_added": "2.5",
       "version_added_collection": "ansible.builtin"
      },
      "table": {
       "choices": [
        "filter",
        "nat",
        "mangle",
        "raw",
        "security"
       ],
       "default": "filter",
       "description": [
        "This option specifies the packet matching table on which the command should operate.",
        "If the kernel is configured with automatic module loading, an attempt will be made to load the appropriate module for that table if it is not already there."
       ],
       "type": "str"
      },
      "tcp_flags": {
       "description": [
        "TCP flags specification.",
        "O(tcp_flags) expects a dict with the two keys C(flags) and C(flags_set)."
       ],
       "suboptions": {
        "flags": {
         "description": [
          "List of flags you want to examine."
         ],
         "elements": "str",
         "type": "list"
        },
        "flags_set": {
         "description": [
          "Flags to be set."
         ],
         "elements": "str",
         "type": "list"
        }
       },
       "type": "dict",
       "version_added": "2.4",
       "version_added_collection": "ansible.builtin"
      },
      "to_destination": {
       "description": [
        "This specifies a destination address to use with C(DNAT).",
        "Without this, the destination address is never altered."
       ],
       "type": "str",
       "version_added": "2.1",
       "version_added_collection": "ansible.builtin"
      },
      "to_ports": {
       "description": [
        "This specifies a destination port or range of ports to use, without this, the destination port is never altered.",
        "This is only valid if the rule also specifies one of the protocol V(tcp), V(udp), V(dccp) or V(sctp)."
       ],
       "type": "str"
      },
      "to_source": {
       "description": [
        "This specifies a source address to use with C(SNAT).",
        "Without this, the source address is never altered."
       ],
       "type": "str",
       "version_added": "2.2",
       "version_added_collection": "ansible.builtin"
      },
      "uid_owner": {
       "description": [
        "Specifies the UID or username to use in the match by owner rule.",
        "From Ansible 2.6 when the C(!) argument is prepended then the it inverts the rule to apply instead to all users except that one specified."
       ],
       "type": "str",
       "version_added": "2.1",
       "version_added_collection": "ansible.builtin"
      },
      "wait": {
       "description": [
        "Wait N seconds for the xtables lock to prevent multiple instances of the program from running concurrently."
       ],
       "type": "str",
       "version_added": "2.10",
       "version_added_collection": "ansible.builtin"
      }
     },
     "short_description": "Modify iptables rules",
     "version_added": "2.0",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Block specific IP\n  ansible.builtin.iptables:\n    chain: INPUT\n    source: 8.8.8.8\n    jump: DROP\n  become: yes\n\n- name: Forward port 80 to 8600\n  ansible.builtin.iptables:\n    table: nat\n    chain: PREROUTING\n    in_interface: eth0\n    protocol: tcp\n    match: tcp\n    destination_port: 80\n    jump: REDIRECT\n    to_ports: 8600\n    comment: Redirect web traffic to port 8600\n  become: yes\n\n- name: Allow related and established connections\n  ansible.builtin.iptables:\n    chain: INPUT\n    ctstate: ESTABLISHED,RELATED\n    jump: ACCEPT\n  become: yes\n\n- name: Allow new incoming SYN packets on TCP port 22 (SSH)\n  ansible.builtin.iptables:\n    chain: INPUT\n    protocol: tcp\n    destination_port: 22\n    ctstate: NEW\n    syn: match\n    jump: ACCEPT\n    comment: Accept new SSH connections.\n\n- name: Match on IP ranges\n  ansible.builtin.iptables:\n    chain: FORWARD\n    src_range: 192.168.1.100-192.168.1.199\n    dst_range: 10.0.0.1-10.0.0.50\n    jump: ACCEPT\n\n- name: Allow source IPs defined in ipset \"admin_hosts\" on port 22\n  ansible.builtin.iptables:\n    chain: INPUT\n    match_set: admin_hosts\n    match_set_flags: src\n    destination_port: 22\n    jump: ALLOW\n\n- name: Tag all outbound tcp packets with DSCP mark 8\n  ansible.builtin.iptables:\n    chain: OUTPUT\n    jump: DSCP\n    table: mangle\n    set_dscp_mark: 8\n    protocol: tcp\n\n- name: Tag all outbound tcp packets with DSCP DiffServ class CS1\n  ansible.builtin.iptables:\n    chain: OUTPUT\n    jump: DSCP\n    table: mangle\n    set_dscp_mark_class: CS1\n    protocol: tcp\n\n# Create the user-defined chain ALLOWLIST\n- iptables:\n    chain: ALLOWLIST\n    chain_management: true\n\n# Delete the user-defined chain ALLOWLIST\n- iptables:\n    chain: ALLOWLIST\n    chain_management: true\n    state: absent\n\n- name: Insert a rule on line 5\n  ansible.builtin.iptables:\n    chain: INPUT\n    protocol: tcp\n    destination_port: 8080\n    jump: ACCEPT\n    action: insert\n    rule_num: 5\n\n# Think twice before running following task as this may lock target system\n- name: Set the policy for the INPUT chain to DROP\n  ansible.builtin.iptables:\n    chain: INPUT\n    policy: DROP\n\n- name: Reject tcp with tcp-reset\n  ansible.builtin.iptables:\n    chain: INPUT\n    protocol: tcp\n    reject_with: tcp-reset\n    ip_version: ipv4\n\n- name: Set tcp flags\n  ansible.builtin.iptables:\n    chain: OUTPUT\n    jump: DROP\n    protocol: tcp\n    tcp_flags:\n      flags: ALL\n      flags_set:\n        - ACK\n        - RST\n        - SYN\n        - FIN\n\n- name: Iptables flush filter\n  ansible.builtin.iptables:\n    chain: \"{{ item }}\"\n    flush: yes\n  with_items:  [ 'INPUT', 'FORWARD', 'OUTPUT' ]\n\n- name: Iptables flush nat\n  ansible.builtin.iptables:\n    table: nat\n    chain: '{{ item }}'\n    flush: yes\n  with_items: [ 'INPUT', 'OUTPUT', 'PREROUTING', 'POSTROUTING' ]\n\n- name: Log packets arriving into an user-defined chain\n  ansible.builtin.iptables:\n    chain: LOGGING\n    action: append\n    state: present\n    limit: 2/second\n    limit_burst: 20\n    log_prefix: \"IPTABLES:INFO: \"\n    log_level: info\n\n- name: Allow connections on multiple ports\n  ansible.builtin.iptables:\n    chain: INPUT\n    protocol: tcp\n    destination_ports:\n      - \"80\"\n      - \"443\"\n      - \"8081:8083\"\n    jump: ACCEPT\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.known_hosts": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "full"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "N/A"
      }
     },
     "author": [
      "Matthew Vernon (@mcv21)"
     ],
     "collection": "ansible.builtin",
     "description": [
      "The M(ansible.builtin.known_hosts) module lets you add or remove a host keys from the C(known_hosts) file.",
      "Starting at Ansible 2.2, multiple entries per host are allowed, but only one for each key type supported by ssh. This is useful if you're going to want to use the M(ansible.builtin.git) module over ssh, for example.",
      "If you have a very large number of host keys to manage, you will find the M(ansible.builtin.template) module more useful."
     ],
     "filename": "/ansible/modules/known_hosts.py",
     "has_action": false,
     "module": "known_hosts",
     "options": {
      "hash_host": {
       "default": "no",
       "description": [
        "Hash the hostname in the known_hosts file."
       ],
       "type": "bool",
       "version_added": "2.3",
       "version_added_collection": "ansible.builtin"
      },
      "key": {
       "description": [
        "The SSH public host key, as a string.",
        "Required if O(state=present), optional when O(state=absent), in which case all keys for the host are removed.",
        "The key must be in the right format for SSH (see sshd(8), section \"SSH_KNOWN_HOSTS FILE FORMAT\").",
        "Specifically, the key should not match the format that is found in an SSH pubkey file, but should rather have the hostname prepended to a line that includes the pubkey, the same way that it would appear in the known_hosts file. The value prepended to the line must also match the value of the name parameter.",
        "Should be of format C(<hostname[,IP]> ssh-rsa <pubkey>).",
        "For custom SSH port, O(key) needs to specify port as well. See example section."
       ],
       "type": "str"
      },
      "name": {
       "aliases": [
        "host"
       ],
       "description": [
        "The host to add or remove (must match a host specified in key). It will be converted to lowercase so that ssh-keygen can find it.",
        "Must match with <hostname> or <ip> present in key attribute.",
        "For custom SSH port, O(name) needs to specify port as well. See example section."
       ],
       "required": true,
       "type": "str"
      },
      "path": {
       "default": "~/.ssh/known_hosts",
       "description": [
        "The known_hosts file to edit.",
        "The known_hosts file will be created if needed. The rest of the path must exist prior to running the module."
       ],
       "type": "path"
      },
      "state": {
       "choices": [
        "absent",
        "present"
       ],
       "default": "present",
       "description": [
        "V(present) to add the host key.",
        "V(absent) to remove it."
       ],
       "type": "str"
      }
     },
     "short_description": "Add or remove a host from the C(known_hosts) file",
     "version_added": "1.9",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Tell the host about our servers it might want to ssh to\n  ansible.builtin.known_hosts:\n    path: /etc/ssh/ssh_known_hosts\n    name: foo.com.invalid\n    key: \"{{ lookup('ansible.builtin.file', 'pubkeys/foo.com.invalid') }}\"\n\n- name: Another way to call known_hosts\n  ansible.builtin.known_hosts:\n    name: host1.example.com   # or 10.9.8.77\n    key: host1.example.com,10.9.8.77 ssh-rsa ASDeararAIUHI324324  # some key gibberish\n    path: /etc/ssh/ssh_known_hosts\n    state: present\n\n- name: Add host with custom SSH port\n  ansible.builtin.known_hosts:\n    name: '[host1.example.com]:2222'\n    key: '[host1.example.com]:2222 ssh-rsa ASDeararAIUHI324324' # some key gibberish\n    path: /etc/ssh/ssh_known_hosts\n    state: present\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.lineinfile": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "full"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "N/A"
      },
      "safe_file_operations": {
       "description": "Uses Ansible's strict file operation functions to ensure proper permissions and avoid data corruption",
       "support": "full"
      },
      "vault": {
       "description": "Can automatically decrypt Ansible vaulted files",
       "support": "none"
      }
     },
     "author": [
      "Daniel Hokka Zakrissoni (@dhozac)",
      "Ahti Kitsik (@ahtik)",
      "Jose Angel Munoz (@imjoseangel)"
     ],
     "collection": "ansible.builtin",
     "description": [
      "This module ensures a particular line is in a file, or replace an existing line using a back-referenced regular expression.",
      "This is primarily useful when you want to change a single line in a file only.",
      "See the M(ansible.builtin.replace) module if you want to change multiple, similar lines or check M(ansible.builtin.blockinfile) if you want to insert/update/remove a block of lines in a file. For other cases, see the M(ansible.builtin.copy) or M(ansible.builtin.template) modules."
     ],
     "filename": "/ansible/modules/lineinfile.py",
     "has_action": false,
     "module": "lineinfile",
     "notes": [
      "As of Ansible 2.3, the O(dest) option has been changed to O(path) as default, but O(dest) still works as well."
     ],
     "options": {
      "attributes": {
       "aliases": [
        "attr"
       ],
       "description": [
        "The attributes the resulting filesystem object should have.",
        "To get supported flags look at the man page for I(chattr) on the target system.",
        "This string should contain the attributes in the same order as the one displayed by I(lsattr).",
        "The C(=) operator is assumed as default, otherwise C(+) or C(-) operators need to be included in the string."
       ],
       "type": "str",
       "version_added": "2.3",
       "version_added_collection": "ansible.builtin"
      },
      "backrefs": {
       "default": false,
       "description": [
        "Used with O(state=present).",
        "If set, O(line) can contain backreferences (both positional and named) that will get populated if the O(regexp) matches.",
        "This parameter changes the operation of the module slightly; O(insertbefore) and O(insertafter) will be ignored, and if the O(regexp) does not match anywhere in the file, the file will be left unchanged.",
        "If the O(regexp) does match, the last matching line will be replaced by the expanded line parameter.",
        "Mutually exclusive with O(search_string)."
       ],
       "type": "bool",
       "version_added": "1.1",
       "version_added_collection": "ansible.builtin"
      },
      "backup": {
       "default": false,
       "description": [
        "Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly."
       ],
       "type": "bool"
      },
      "create": {
       "default": false,
       "description": [
        "Used with O(state=present).",
        "If specified, the file will be created if it does not already exist.",
        "By default it will fail if the file is missing."
       ],
       "type": "bool"
      },
      "firstmatch": {
       "default": false,
       "description": [
        "Used with O(insertafter) or O(insertbefore).",
        "If set, O(insertafter) and O(insertbefore) will work with the first line that matches the given regular expression."
       ],
       "type": "bool",
       "version_added": "2.5",
       "version_added_collection": "ansible.builtin"
      },
      "group": {
       "description": [
        "Name of the group that should own the filesystem object, as would be fed to I(chown).",
        "When left unspecified, it uses the current group of the current user unless you are root, in which case it can preserve the previous ownership."
       ],
       "type": "str"
      },
      "insertafter": {
       "choices": [
        "EOF",
        "*regex*"
       ],
       "default": "EOF",
       "description": [
        "Used with O(state=present).",
        "If specified, the line will be inserted after the last match of specified regular expression.",
        "If the first match is required, use(firstmatch=yes).",
        "A special value is available; V(EOF) for inserting the line at the end of the file.",
        "If specified regular expression has no matches, EOF will be used instead.",
        "If O(insertbefore) is set, default value V(EOF) will be ignored.",
        "If regular expressions are passed to both O(regexp) and O(insertafter), O(insertafter) is only honored if no match for O(regexp) is found.",
        "May not be used with O(backrefs) or O(insertbefore)."
       ],
       "type": "str"
      },
      "insertbefore": {
       "choices": [
        "BOF",
        "*regex*"
       ],
       "description": [
        "Used with O(state=present).",
        "If specified, the line will be inserted before the last match of specified regular expression.",
        "If the first match is required, use O(firstmatch=yes).",
        "A value is available; V(BOF) for inserting the line at the beginning of the file.",
        "If specified regular expression has no matches, the line will be inserted at the end of the file.",
        "If regular expressions are passed to both O(regexp) and O(insertbefore), O(insertbefore) is only honored if no match for O(regexp) is found.",
        "May not be used with O(backrefs) or O(insertafter)."
       ],
       "type": "str",
       "version_added": "1.1",
       "version_added_collection": "ansible.builtin"
      },
      "line": {
       "aliases": [
        "value"
       ],
       "description": [
        "The line to insert/replace into the file.",
        "Required for O(state=present).",
        "If O(backrefs) is set, may contain backreferences that will get expanded with the O(regexp) capture groups if the regexp matches."
       ],
       "type": "str"
      },
      "mode": {
       "description": [
        "The permissions the resulting filesystem object should have.",
        "For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must give Ansible enough information to parse them correctly. For consistent results, quote octal numbers (for example, V('644') or V('1777')) so Ansible receives a string and can do its own conversion from string into number. Adding a leading zero (for example, V(0755)) works sometimes, but can fail in loops and some other circumstances.",
        "Giving Ansible a number without following either of these rules will end up with a decimal number which will have unexpected results.",
        "As of Ansible 1.8, the mode may be specified as a symbolic mode (for example, V(u+rwx) or V(u=rw,g=r,o=r)).",
        "If O(mode) is not specified and the destination filesystem object B(does not) exist, the default C(umask) on the system will be used when setting the mode for the newly created filesystem object.",
        "If O(mode) is not specified and the destination filesystem object B(does) exist, the mode of the existing filesystem object will be used.",
        "Specifying O(mode) is the best way to ensure filesystem objects are created with the correct permissions. See CVE-2020-1736 for further details."
       ],
       "type": "raw"
      },
      "owner": {
       "description": [
        "Name of the user that should own the filesystem object, as would be fed to I(chown).",
        "When left unspecified, it uses the current user unless you are root, in which case it can preserve the previous ownership.",
        "Specifying a numeric username will be assumed to be a user ID and not a username. Avoid numeric usernames to avoid this confusion."
       ],
       "type": "str"
      },
      "path": {
       "aliases": [
        "dest",
        "destfile",
        "name"
       ],
       "description": [
        "The file to modify.",
        "Before Ansible 2.3 this option was only usable as O(dest), O(destfile) and O(name)."
       ],
       "required": true,
       "type": "path"
      },
      "regexp": {
       "aliases": [
        "regex"
       ],
       "description": [
        "The regular expression to look for in every line of the file.",
        "For O(state=present), the pattern to replace if found. Only the last line found will be replaced.",
        "For O(state=absent), the pattern of the line(s) to remove.",
        "If the regular expression is not matched, the line will be added to the file in keeping with O(insertbefore) or O(insertafter) settings.",
        "When modifying a line the regexp should typically match both the initial state of the line as well as its state after replacement by O(line) to ensure idempotence.",
        "Uses Python regular expressions. See U(https://docs.python.org/3/library/re.html)."
       ],
       "type": "str",
       "version_added": "1.7",
       "version_added_collection": "ansible.builtin"
      },
      "search_string": {
       "description": [
        "The literal string to look for in every line of the file. This does not have to match the entire line.",
        "For O(state=present), the line to replace if the string is found in the file. Only the last line found will be replaced.",
        "For O(state=absent), the line(s) to remove if the string is in the line.",
        "If the literal expression is not matched, the line will be added to the file in keeping with O(insertbefore) or O(insertafter) settings.",
        "Mutually exclusive with O(backrefs) and O(regexp)."
       ],
       "type": "str",
       "version_added": "2.11",
       "version_added_collection": "ansible.builtin"
      },
      "selevel": {
       "description": [
        "The level part of the SELinux filesystem object context.",
        "This is the MLS/MCS attribute, sometimes known as the C(range).",
        "When set to V(_default), it will use the C(level) portion of the policy if available."
       ],
       "type": "str"
      },
      "serole": {
       "description": [
        "The role part of the SELinux filesystem object context.",
        "When set to V(_default), it will use the C(role) portion of the policy if available."
       ],
       "type": "str"
      },
      "setype": {
       "description": [
        "The type part of the SELinux filesystem object context.",
        "When set to V(_default), it will use the C(type) portion of the policy if available."
       ],
       "type": "str"
      },
      "seuser": {
       "description": [
        "The user part of the SELinux filesystem object context.",
        "By default it uses the V(system) policy, where applicable.",
        "When set to V(_default), it will use the C(user) portion of the policy if available."
       ],
       "type": "str"
      },
      "state": {
       "choices": [
        "absent",
        "present"
       ],
       "default": "present",
       "description": [
        "Whether the line should be there or not."
       ],
       "type": "str"
      },
      "unsafe_writes": {
       "default": false,
       "description": [
        "Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target filesystem object.",
        "By default this module uses atomic operations to prevent data corruption or inconsistent reads from the target filesystem objects, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted filesystem objects, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.",
        "This option allows Ansible to fall back to unsafe methods of updating filesystem objects when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes).",
        "IMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption."
       ],
       "type": "bool",
       "version_added": "2.2",
       "version_added_collection": "ansible.builtin"
      },
      "validate": {
       "description": [
        "The validation command to run before copying the updated file into the final destination.",
        "A temporary file path is used to validate, passed in through '%s' which must be present as in the examples below.",
        "Also, the command is passed securely so shell features such as expansion and pipes will not work.",
        "For an example on how to handle more complex validation than what this option provides, see R(handling complex validation,complex_configuration_validation)."
       ],
       "type": "str"
      }
     },
     "seealso": [
      {
       "module": "ansible.builtin.blockinfile"
      },
      {
       "module": "ansible.builtin.copy"
      },
      {
       "module": "ansible.builtin.file"
      },
      {
       "module": "ansible.builtin.replace"
      },
      {
       "module": "ansible.builtin.template"
      },
      {
       "module": "community.windows.win_lineinfile"
      }
     ],
     "short_description": "Manage lines in text files",
     "version_added": "0.7",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# NOTE: Before 2.3, option 'dest', 'destfile' or 'name' was used instead of 'path'\n- name: Ensure SELinux is set to enforcing mode\n  ansible.builtin.lineinfile:\n    path: /etc/selinux/config\n    regexp: '^SELINUX='\n    line: SELINUX=enforcing\n\n- name: Make sure group wheel is not in the sudoers configuration\n  ansible.builtin.lineinfile:\n    path: /etc/sudoers\n    state: absent\n    regexp: '^%wheel'\n\n- name: Replace a localhost entry with our own\n  ansible.builtin.lineinfile:\n    path: /etc/hosts\n    regexp: '^127\\.0\\.0\\.1'\n    line: 127.0.0.1 localhost\n    owner: root\n    group: root\n    mode: '0644'\n\n- name: Replace a localhost entry searching for a literal string to avoid escaping\n  ansible.builtin.lineinfile:\n    path: /etc/hosts\n    search_string: '127.0.0.1'\n    line: 127.0.0.1 localhost\n    owner: root\n    group: root\n    mode: '0644'\n\n- name: Ensure the default Apache port is 8080\n  ansible.builtin.lineinfile:\n    path: /etc/httpd/conf/httpd.conf\n    regexp: '^Listen '\n    insertafter: '^#Listen '\n    line: Listen 8080\n\n- name: Ensure php extension matches new pattern\n  ansible.builtin.lineinfile:\n    path: /etc/httpd/conf/httpd.conf\n    search_string: '<FilesMatch \".php[45]?$\">'\n    insertafter: '^\\t<Location \\/>\\n'\n    line: '        <FilesMatch \".php[34]?$\">'\n\n- name: Ensure we have our own comment added to /etc/services\n  ansible.builtin.lineinfile:\n    path: /etc/services\n    regexp: '^# port for http'\n    insertbefore: '^www.*80/tcp'\n    line: '# port for http by default'\n\n- name: Add a line to a file if the file does not exist, without passing regexp\n  ansible.builtin.lineinfile:\n    path: /tmp/testfile\n    line: 192.168.1.99 foo.lab.net foo\n    create: yes\n\n# NOTE: Yaml requires escaping backslashes in double quotes but not in single quotes\n- name: Ensure the JBoss memory settings are exactly as needed\n  ansible.builtin.lineinfile:\n    path: /opt/jboss-as/bin/standalone.conf\n    regexp: '^(.*)Xms(\\d+)m(.*)$'\n    line: '\\1Xms${xms}m\\3'\n    backrefs: yes\n\n# NOTE: Fully quoted because of the ': ' on the line. See the Gotchas in the YAML docs.\n- name: Validate the sudoers file before saving\n  ansible.builtin.lineinfile:\n    path: /etc/sudoers\n    state: present\n    regexp: '^%ADMIN ALL='\n    line: '%ADMIN ALL=(ALL) NOPASSWD: ALL'\n    validate: /usr/sbin/visudo -cf %s\n\n# See https://docs.python.org/3/library/re.html for further details on syntax\n- name: Use backrefs with alternative group syntax to avoid conflicts with variable values\n  ansible.builtin.lineinfile:\n    path: /tmp/config\n    regexp: ^(host=).*\n    line: \\g<1>{{ hostname }}\n    backrefs: yes\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.meta": {
    "doc": {
     "attributes": {
      "action": {
       "description": "Indicates this has a corresponding action plugin so some parts of the options can be executed on the controller",
       "support": "none"
      },
      "async": {
       "description": "Supports being used with the C(async) keyword",
       "support": "none"
      },
      "become": {
       "description": "Is usable alongside become keywords",
       "support": "none"
      },
      "bypass_host_loop": {
       "description": [
        "Forces a 'global' task that does not execute per host, this bypasses per host templating and serial, throttle and other loop considerations",
        "Conditionals will work as if C(run_once) is being used, variables used will be from the first available host",
        "This action will not work normally outside of lockstep strategies"
       ],
       "details": "Some of the subactions ignore the host loop, see the description above for each specific action for the exceptions",
       "support": "partial"
      },
      "bypass_task_loop": {
       "description": "These tasks ignore the C(loop) and C(with_) keywords",
       "details": "Most of the subactions ignore the task loop, see the description above for each specific action for the exceptions",
       "support": "partial"
      },
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "details": "While these actions don't modify the targets directly they do change possible states of the target within the run",
       "support": "partial"
      },
      "connection": {
       "description": "Uses the target's configured connection information to execute code on it",
       "details": "Most options in this action do not use a connection, except V(reset_connection) which still does not connect to the remote",
       "support": "partial"
      },
      "core": {
       "description": "This is a 'core engine' feature and is not implemented like most task actions, so it is not overridable in any way via the plugin system.",
       "support": "full"
      },
      "delegation": {
       "description": "Can be used in conjunction with delegate_to and related keywords",
       "support": "none"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "ignore_conditional": {
       "description": "The action is not subject to conditional execution so it will ignore the C(when:) keyword",
       "details": "Only some options support conditionals and when they do they act 'bypassing the host loop', taking the values from first available host",
       "support": "partial"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "all",
       "support": "N/A"
      },
      "tags": {
       "description": "Allows for the 'tags' keyword to control the selection of this action for execution",
       "support": "full"
      },
      "until": {
       "description": "Denotes if this action obeys until/retry/poll keywords",
       "support": "full"
      }
     },
     "author": [
      "Ansible Core Team"
     ],
     "collection": "ansible.builtin",
     "description": [
      "Meta tasks are a special kind of task which can influence Ansible internal execution or state.",
      "Meta tasks can be used anywhere within your playbook.",
      "This module is also supported for Windows targets."
     ],
     "filename": "/ansible/modules/meta.py",
     "has_action": false,
     "module": "meta",
     "notes": [
      "V(clear_facts) will remove the persistent facts from M(ansible.builtin.set_fact) using O(ansible.builtin.set_fact#module:cacheable=True), but not the current host variable it creates for the current run.",
      "Skipping M(ansible.builtin.meta) tasks with tags is not supported before Ansible 2.11."
     ],
     "options": {
      "free_form": {
       "choices": [
        "clear_facts",
        "clear_host_errors",
        "end_host",
        "end_play",
        "flush_handlers",
        "noop",
        "refresh_inventory",
        "reset_connection",
        "end_batch"
       ],
       "description": [
        "This module takes a free form command, as a string. There is not an actual option named \"free form\".  See the examples!",
        "V(flush_handlers) makes Ansible run any handler tasks which have thus far been notified. Ansible inserts these tasks internally at certain points to implicitly trigger handler runs (after pre/post tasks, the final role execution, and the main tasks section of your plays).",
        "V(refresh_inventory) (added in Ansible 2.0) forces the reload of the inventory, which in the case of dynamic inventory scripts means they will be re-executed. If the dynamic inventory script is using a cache, Ansible cannot know this and has no way of refreshing it (you can disable the cache or, if available for your specific inventory datasource (e.g. aws), you can use the an inventory plugin instead of an inventory script). This is mainly useful when additional hosts are created and users wish to use them instead of using the M(ansible.builtin.add_host) module.",
        "V(noop) (added in Ansible 2.0) This literally does 'nothing'. It is mainly used internally and not recommended for general use.",
        "V(clear_facts) (added in Ansible 2.1) causes the gathered facts for the hosts specified in the play's list of hosts to be cleared, including the fact cache.",
        "V(clear_host_errors) (added in Ansible 2.1) clears the failed state (if any) from hosts specified in the play's list of hosts.",
        "V(end_play) (added in Ansible 2.2) causes the play to end without failing the host(s). Note that this affects all hosts.",
        "V(reset_connection) (added in Ansible 2.3) interrupts a persistent connection (i.e. ssh + control persist)",
        "V(end_host) (added in Ansible 2.8) is a per-host variation of V(end_play). Causes the play to end for the current host without failing it.",
        "V(end_batch) (added in Ansible 2.12) causes the current batch (see C(serial)) to end without failing the host(s). Note that with C(serial=0) or undefined this behaves the same as V(end_play)."
       ],
       "required": true
      }
     },
     "seealso": [
      {
       "module": "ansible.builtin.assert"
      },
      {
       "module": "ansible.builtin.fail"
      }
     ],
     "short_description": "Execute Ansible 'actions'",
     "version_added": "1.2",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# Example showing flushing handlers on demand, not at end of play\n- ansible.builtin.template:\n    src: new.j2\n    dest: /etc/config.txt\n  notify: myhandler\n\n- name: Force all notified handlers to run at this point, not waiting for normal sync points\n  ansible.builtin.meta: flush_handlers\n\n# Example showing how to refresh inventory during play\n- name: Reload inventory, useful with dynamic inventories when play makes changes to the existing hosts\n  cloud_guest:            # this is fake module\n    name: newhost\n    state: present\n\n- name: Refresh inventory to ensure new instances exist in inventory\n  ansible.builtin.meta: refresh_inventory\n\n# Example showing how to clear all existing facts of targeted hosts\n- name: Clear gathered facts from all currently targeted hosts\n  ansible.builtin.meta: clear_facts\n\n# Example showing how to continue using a failed target\n- name: Bring host back to play after failure\n  ansible.builtin.copy:\n    src: file\n    dest: /etc/file\n  remote_user: imightnothavepermission\n\n- ansible.builtin.meta: clear_host_errors\n\n# Example showing how to reset an existing connection\n- ansible.builtin.user:\n    name: '{{ ansible_user }}'\n    groups: input\n\n- name: Reset ssh connection to allow user changes to affect 'current login user'\n  ansible.builtin.meta: reset_connection\n\n# Example showing how to end the play for specific targets\n- name: End the play for hosts that run CentOS 6\n  ansible.builtin.meta: end_host\n  when:\n  - ansible_distribution == 'CentOS'\n  - ansible_distribution_major_version == '6'\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.package": {
    "doc": {
     "attributes": {
      "action": {
       "description": "Indicates this has a corresponding action plugin so some parts of the options can be executed on the controller",
       "support": "full"
      },
      "async": {
       "description": "Supports being used with the C(async) keyword",
       "support": "full"
      },
      "bypass_host_loop": {
       "description": [
        "Forces a 'global' task that does not execute per host, this bypasses per host templating and serial, throttle and other loop considerations",
        "Conditionals will work as if C(run_once) is being used, variables used will be from the first available host",
        "This action will not work normally outside of lockstep strategies"
       ],
       "support": "none"
      },
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "details": "support depends on the underlying plugin invoked",
       "support": "N/A"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "details": "support depends on the underlying plugin invoked",
       "support": "N/A"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "details": "The support depends on the availability for the specific plugin for each platform and if fact gathering is able to detect it",
       "platforms": "all",
       "support": "N/A"
      }
     },
     "author": [
      "Ansible Core Team"
     ],
     "collection": "ansible.builtin",
     "description": [
      "This modules manages packages on a target without specifying a package manager module (like M(ansible.builtin.dnf), M(ansible.builtin.apt), ...). It is convenient to use in an heterogeneous environment of machines without having to create a specific task for each package manager. M(ansible.builtin.package) calls behind the module for the package manager used by the operating system discovered by the module M(ansible.builtin.setup).  If M(ansible.builtin.setup) was not yet run, M(ansible.builtin.package) will run it.",
      "This module acts as a proxy to the underlying package manager module. While all arguments will be passed to the underlying module, not all modules support the same arguments. This documentation only covers the minimum intersection of module arguments that all packaging modules support.",
      "For Windows targets, use the M(ansible.windows.win_package) module instead."
     ],
     "filename": "/ansible/modules/package.py",
     "has_action": true,
     "module": "package",
     "notes": [
      "While M(ansible.builtin.package) abstracts package managers to ease dealing with multiple distributions, package name often differs for the same software."
     ],
     "options": {
      "name": {
       "description": [
        "Package name, or package specifier with version.",
        "Syntax varies with package manager. For example V(name-1.0) or V(name=1.0).",
        "Package names also vary with package manager; this module will not \"translate\" them per distro. For example V(libyaml-dev), V(libyaml-devel).",
        "To operate on several packages this can accept a comma separated string of packages or a list of packages, depending on the underlying package manager."
       ],
       "required": true
      },
      "state": {
       "description": [
        "Whether to install (V(present)), or remove (V(absent)) a package.",
        "You can use other states like V(latest) ONLY if they are supported by the underlying package module(s) executed."
       ],
       "required": true
      },
      "use": {
       "default": "auto",
       "description": [
        "The required package manager module to use (V(dnf), V(apt), and so on). The default V(auto) will use existing facts or try to autodetect it.",
        "You should only use this field if the automatic selection is not working for some reason."
       ]
      }
     },
     "requirements": [
      "Whatever is required for the package plugins specific for each system."
     ],
     "short_description": "Generic OS package manager",
     "version_added": 2.0,
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Install ntpdate\n  ansible.builtin.package:\n    name: ntpdate\n    state: present\n\n# This uses a variable as this changes per distribution.\n- name: Remove the apache package\n  ansible.builtin.package:\n    name: \"{{ apache }}\"\n    state: absent\n\n- name: Install the latest version of Apache and MariaDB\n  ansible.builtin.package:\n    name:\n      - httpd\n      - mariadb-server\n    state: latest\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.package_facts": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "facts": {
       "description": "Action returns an C(ansible_facts) dictionary that will update existing host facts",
       "support": "full"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "N/A"
      }
     },
     "author": [
      "Matthew Jones (@matburt)",
      "Brian Coca (@bcoca)",
      "Adam Miller (@maxamillion)"
     ],
     "collection": "ansible.builtin",
     "description": [
      "Return information about installed packages as facts."
     ],
     "filename": "/ansible/modules/package_facts.py",
     "has_action": false,
     "module": "package_facts",
     "options": {
      "manager": {
       "choices": [
        "auto",
        "rpm",
        "apt",
        "portage",
        "pkg",
        "pacman",
        "apk",
        "pkg_info"
       ],
       "default": [
        "auto"
       ],
       "description": [
        "The package manager used by the system so we can query the package information.",
        "Since 2.8 this is a list and can support multiple package managers per system.",
        "The 'portage' and 'pkg' options were added in version 2.8.",
        "The 'apk' option was added in version 2.11.",
        "The 'pkg_info' option was added in version 2.13."
       ],
       "elements": "str",
       "type": "list"
      },
      "strategy": {
       "choices": [
        "first",
        "all"
       ],
       "default": "first",
       "description": [
        "This option controls how the module queries the package managers on the system. V(first) means it will return only information for the first supported package manager available. V(all) will return information for all supported and available package managers on the system."
       ],
       "type": "str",
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      }
     },
     "requirements": [
      "For 'portage' support it requires the C(qlist) utility, which is part of 'app-portage/portage-utils'.",
      "For Debian-based systems C(python-apt) package must be installed on targeted hosts.",
      "For SUSE-based systems C(python3-rpm) package must be installed on targeted hosts. This package is required because SUSE does not include RPM Python bindings by default."
     ],
     "short_description": "Package information as facts",
     "version_added": "2.5",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Gather the package facts\n  ansible.builtin.package_facts:\n    manager: auto\n\n- name: Print the package facts\n  ansible.builtin.debug:\n    var: ansible_facts.packages\n\n- name: Check whether a package called foobar is installed\n  ansible.builtin.debug:\n    msg: \"{{ ansible_facts.packages['foobar'] | length }} versions of foobar are installed!\"\n  when: \"'foobar' in ansible_facts.packages\"\n\n",
    "metadata": null,
    "return": {
     "ansible_facts": {
      "contains": {
       "packages": {
        "contains": {
         "name": {
          "description": "The package's name.",
          "returned": "always",
          "type": "str"
         },
         "source": {
          "description": "Where information on the package came from.",
          "returned": "always",
          "type": "str"
         },
         "version": {
          "description": "The package's version.",
          "returned": "always",
          "type": "str"
         }
        },
        "description": [
         "Maps the package name to a non-empty list of dicts with package information.",
         "Every dict in the list corresponds to one installed version of the package.",
         "The fields described below are present for all package managers. Depending on the package manager, there might be more fields for a package."
        ],
        "returned": "when operating system level package manager is specified or auto detected manager",
        "sample": "{\n  \"packages\": {\n    \"kernel\": [\n      {\n        \"name\": \"kernel\",\n        \"source\": \"rpm\",\n        \"version\": \"3.10.0\",\n        ...\n      },\n      {\n        \"name\": \"kernel\",\n        \"source\": \"rpm\",\n        \"version\": \"3.10.0\",\n        ...\n      },\n      ...\n    ],\n    \"kernel-tools\": [\n      {\n        \"name\": \"kernel-tools\",\n        \"source\": \"rpm\",\n        \"version\": \"3.10.0\",\n        ...\n      }\n    ],\n    ...\n  }\n}\n# Sample rpm\n{\n  \"packages\": {\n    \"kernel\": [\n      {\n        \"arch\": \"x86_64\",\n        \"epoch\": null,\n        \"name\": \"kernel\",\n        \"release\": \"514.26.2.el7\",\n        \"source\": \"rpm\",\n        \"version\": \"3.10.0\"\n      },\n      {\n        \"arch\": \"x86_64\",\n        \"epoch\": null,\n        \"name\": \"kernel\",\n        \"release\": \"514.16.1.el7\",\n        \"source\": \"rpm\",\n        \"version\": \"3.10.0\"\n      },\n      {\n        \"arch\": \"x86_64\",\n        \"epoch\": null,\n        \"name\": \"kernel\",\n        \"release\": \"514.10.2.el7\",\n        \"source\": \"rpm\",\n        \"version\": \"3.10.0\"\n      },\n      {\n        \"arch\": \"x86_64\",\n        \"epoch\": null,\n        \"name\": \"kernel\",\n        \"release\": \"514.21.1.el7\",\n        \"source\": \"rpm\",\n        \"version\": \"3.10.0\"\n      },\n      {\n        \"arch\": \"x86_64\",\n        \"epoch\": null,\n        \"name\": \"kernel\",\n        \"release\": \"693.2.2.el7\",\n        \"source\": \"rpm\",\n        \"version\": \"3.10.0\"\n      }\n    ],\n    \"kernel-tools\": [\n      {\n        \"arch\": \"x86_64\",\n        \"epoch\": null,\n        \"name\": \"kernel-tools\",\n        \"release\": \"693.2.2.el7\",\n        \"source\": \"rpm\",\n        \"version\": \"3.10.0\"\n      }\n    ],\n    \"kernel-tools-libs\": [\n      {\n        \"arch\": \"x86_64\",\n        \"epoch\": null,\n        \"name\": \"kernel-tools-libs\",\n        \"release\": \"693.2.2.el7\",\n        \"source\": \"rpm\",\n        \"version\": \"3.10.0\"\n      }\n    ],\n  }\n}\n# Sample deb\n{\n  \"packages\": {\n    \"libbz2-1.0\": [\n      {\n        \"version\": \"1.0.6-5\",\n        \"source\": \"apt\",\n        \"arch\": \"amd64\",\n        \"name\": \"libbz2-1.0\"\n      }\n    ],\n    \"patch\": [\n      {\n        \"version\": \"2.7.1-4ubuntu1\",\n        \"source\": \"apt\",\n        \"arch\": \"amd64\",\n        \"name\": \"patch\"\n      }\n    ],\n  }\n}\n# Sample pkg_info\n{\n  \"packages\": {\n    \"curl\": [\n      {\n          \"name\": \"curl\",\n          \"source\": \"pkg_info\",\n          \"version\": \"7.79.0\"\n      }\n    ],\n    \"intel-firmware\": [\n      {\n          \"name\": \"intel-firmware\",\n          \"source\": \"pkg_info\",\n          \"version\": \"20210608v0\"\n      }\n    ],\n  }\n}",
        "type": "dict"
       }
      },
      "description": "Facts to add to ansible_facts.",
      "returned": "always",
      "type": "complex"
     }
    }
   },
   "ansible.builtin.pause": {
    "doc": {
     "attributes": {
      "action": {
       "description": "Indicates this has a corresponding action plugin so some parts of the options can be executed on the controller",
       "support": "full"
      },
      "async": {
       "description": "Supports being used with the C(async) keyword",
       "support": "none"
      },
      "become": {
       "description": "Is usable alongside become keywords",
       "support": "none"
      },
      "bypass_host_loop": {
       "description": [
        "Forces a 'global' task that does not execute per host, this bypasses per host templating and serial, throttle and other loop considerations",
        "Conditionals will work as if C(run_once) is being used, variables used will be from the first available host",
        "This action will not work normally outside of lockstep strategies"
       ],
       "support": "full"
      },
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "connection": {
       "description": "Uses the target's configured connection information to execute code on it",
       "support": "none"
      },
      "delegation": {
       "description": "Can be used in conjunction with delegate_to and related keywords",
       "support": "none"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "all",
       "support": "N/A"
      }
     },
     "author": "Tim Bielawa (@tbielawa)",
     "collection": "ansible.builtin",
     "description": [
      "Pauses playbook execution for a set amount of time, or until a prompt is acknowledged. All parameters are optional. The default behavior is to pause with a prompt.",
      "To pause/wait/sleep per host, use the M(ansible.builtin.wait_for) module.",
      "You can use C(ctrl+c) if you wish to advance a pause earlier than it is set to expire or if you need to abort a playbook run entirely. To continue early press C(ctrl+c) and then C(c). To abort a playbook press C(ctrl+c) and then C(a).",
      "Prompting for a set amount of time is not supported. Pausing playbook execution is interruptible but does not return user input.",
      "The pause module integrates into async/parallelized playbooks without any special considerations (see Rolling Updates). When using pauses with the C(serial) playbook parameter (as in rolling updates) you are only prompted once for the current group of hosts.",
      "This module is also supported for Windows targets."
     ],
     "filename": "/ansible/modules/pause.py",
     "has_action": true,
     "module": "pause",
     "notes": [
      "Starting in 2.2,  if you specify 0 or negative for minutes or seconds, it will wait for 1 second, previously it would wait indefinitely.",
      "User input is not captured or echoed, regardless of echo setting, when minutes or seconds is specified."
     ],
     "options": {
      "echo": {
       "default": "yes",
       "description": [
        "Controls whether or not keyboard input is shown when typing.",
        "Only has effect if O(seconds=None) and O(minutes=None)."
       ],
       "type": "bool",
       "version_added": 2.5,
       "version_added_collection": "ansible.builtin"
      },
      "minutes": {
       "description": [
        "A positive number of minutes to pause for."
       ]
      },
      "prompt": {
       "description": [
        "Optional text to use for the prompt message.",
        "User input is only returned if O(seconds=None) and O(minutes=None), otherwise this is just a custom message before playbook execution is paused."
       ]
      },
      "seconds": {
       "description": [
        "A positive number of seconds to pause for."
       ]
      }
     },
     "short_description": "Pause playbook execution",
     "version_added": "0.8",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Pause for 5 minutes to build app cache\n  ansible.builtin.pause:\n    minutes: 5\n\n- name: Pause until you can verify updates to an application were successful\n  ansible.builtin.pause:\n\n- name: A helpful reminder of what to look out for post-update\n  ansible.builtin.pause:\n    prompt: \"Make sure org.foo.FooOverload exception is not present\"\n\n- name: Pause to get some sensitive input\n  ansible.builtin.pause:\n    prompt: \"Enter a secret\"\n    echo: no\n",
    "metadata": null,
    "return": {
     "delta": {
      "description": "Time paused in seconds",
      "returned": "always",
      "sample": 2,
      "type": "str"
     },
     "echo": {
      "description": "Value of echo setting",
      "returned": "always",
      "sample": true,
      "type": "bool"
     },
     "start": {
      "description": "Time when started pausing",
      "returned": "always",
      "sample": "2017-02-23 14:35:07.298862",
      "type": "str"
     },
     "stdout": {
      "description": "Output of pause module",
      "returned": "always",
      "sample": "Paused for 0.04 minutes",
      "type": "str"
     },
     "stop": {
      "description": "Time when ended pausing",
      "returned": "always",
      "sample": "2017-02-23 14:35:09.552594",
      "type": "str"
     },
     "user_input": {
      "description": "User input from interactive console",
      "returned": "if no waiting time set",
      "sample": "Example user input",
      "type": "str"
     }
    }
   },
   "ansible.builtin.ping": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "N/A"
      }
     },
     "author": [
      "Ansible Core Team",
      "Michael DeHaan"
     ],
     "collection": "ansible.builtin",
     "description": [
      "A trivial test module, this module always returns V(pong) on successful contact. It does not make sense in playbooks, but it is useful from C(/usr/bin/ansible) to verify the ability to login and that a usable Python is configured.",
      "This is NOT ICMP ping, this is just a trivial test module that requires Python on the remote-node.",
      "For Windows targets, use the M(ansible.windows.win_ping) module instead.",
      "For Network targets, use the M(ansible.netcommon.net_ping) module instead."
     ],
     "filename": "/ansible/modules/ping.py",
     "has_action": false,
     "module": "ping",
     "options": {
      "data": {
       "default": "pong",
       "description": [
        "Data to return for the RV(ping) return value.",
        "If this parameter is set to V(crash), the module will cause an exception."
       ],
       "type": "str"
      }
     },
     "seealso": [
      {
       "module": "ansible.netcommon.net_ping"
      },
      {
       "module": "ansible.windows.win_ping"
      }
     ],
     "short_description": "Try to connect to host, verify a usable python and return V(pong) on success",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# Test we can logon to 'webservers' and execute python with json lib.\n# ansible webservers -m ansible.builtin.ping\n\n- name: Example from an Ansible Playbook\n  ansible.builtin.ping:\n\n- name: Induce an exception to see what happens\n  ansible.builtin.ping:\n    data: crash\n",
    "metadata": null,
    "return": {
     "ping": {
      "description": "Value provided with the O(data) parameter.",
      "returned": "success",
      "sample": "pong",
      "type": "str"
     }
    }
   },
   "ansible.builtin.pip": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "N/A"
      }
     },
     "author": [
      "Matt Wright (@mattupstate)"
     ],
     "collection": "ansible.builtin",
     "description": [
      "Manage Python library dependencies. To use this module, one of the following keys is required: O(name) or O(requirements)."
     ],
     "filename": "/ansible/modules/pip.py",
     "has_action": false,
     "module": "pip",
     "notes": [
      "Python installations marked externally-managed (as defined by PEP668) cannot be updated by pip versions >= 23.0.1 without the use of a virtual environment or setting the O(break_system_packages) option.",
      "The virtualenv (U(http://www.virtualenv.org/)) must be installed on the remote host if the virtualenv parameter is specified and the virtualenv needs to be created.",
      "Although it executes using the Ansible Python interpreter, the pip module shells out to run the actual pip command, so it can use any pip version you specify with O(executable). By default, it uses the pip version for the Ansible Python interpreter. For example, pip3 on python 3, and pip2 or pip on python 2.",
      "The interpreter used by Ansible (see R(ansible_python_interpreter, ansible_python_interpreter)) requires the setuptools package, regardless of the version of pip set with the O(executable) option."
     ],
     "options": {
      "break_system_packages": {
       "default": false,
       "description": [
        "Allow pip to modify an externally-managed Python installation as defined by PEP 668.",
        "This is typically required when installing packages outside a virtual environment on modern systems."
       ],
       "type": "bool",
       "version_added": "2.17",
       "version_added_collection": "ansible.builtin"
      },
      "chdir": {
       "description": [
        "cd into this directory before running the command"
       ],
       "type": "path",
       "version_added": "1.3",
       "version_added_collection": "ansible.builtin"
      },
      "editable": {
       "default": "no",
       "description": [
        "Pass the editable flag."
       ],
       "type": "bool",
       "version_added": "2.0",
       "version_added_collection": "ansible.builtin"
      },
      "executable": {
       "description": [
        "The explicit executable or pathname for the pip executable, if different from the Ansible Python interpreter. For example V(pip3.3), if there are both Python 2.7 and 3.3 installations in the system and you want to run pip for the Python 3.3 installation.",
        "Mutually exclusive with O(virtualenv) (added in 2.1).",
        "Does not affect the Ansible Python interpreter.",
        "The setuptools package must be installed for both the Ansible Python interpreter and for the version of Python specified by this option."
       ],
       "type": "path",
       "version_added": "1.3",
       "version_added_collection": "ansible.builtin"
      },
      "extra_args": {
       "description": [
        "Extra arguments passed to pip."
       ],
       "type": "str",
       "version_added": "1.0",
       "version_added_collection": "ansible.builtin"
      },
      "name": {
       "description": [
        "The name of a Python library to install or the url(bzr+,hg+,git+,svn+) of the remote package.",
        "This can be a list (since 2.2) and contain version specifiers (since 2.7)."
       ],
       "elements": "str",
       "type": "list"
      },
      "requirements": {
       "description": [
        "The path to a pip requirements file, which should be local to the remote system. File can be specified as a relative path if using the chdir option."
       ],
       "type": "str"
      },
      "state": {
       "choices": [
        "absent",
        "forcereinstall",
        "latest",
        "present"
       ],
       "default": "present",
       "description": [
        "The state of module",
        "The 'forcereinstall' option is only available in Ansible 2.1 and above."
       ],
       "type": "str"
      },
      "umask": {
       "description": [
        "The system umask to apply before installing the pip package. This is useful, for example, when installing on systems that have a very restrictive umask by default (e.g., \"0077\") and you want to pip install packages which are to be used by all users. Note that this requires you to specify desired umask mode as an octal string, (e.g., \"0022\")."
       ],
       "type": "str",
       "version_added": "2.1",
       "version_added_collection": "ansible.builtin"
      },
      "version": {
       "description": [
        "The version number to install of the Python library specified in the O(name) parameter."
       ],
       "type": "str"
      },
      "virtualenv": {
       "description": [
        "An optional path to a I(virtualenv) directory to install into. It cannot be specified together with the 'executable' parameter (added in 2.1). If the virtualenv does not exist, it will be created before installing packages. The optional virtualenv_site_packages, virtualenv_command, and virtualenv_python options affect the creation of the virtualenv."
       ],
       "type": "path"
      },
      "virtualenv_command": {
       "default": "virtualenv",
       "description": [
        "The command or a pathname to the command to create the virtual environment with. For example V(pyvenv), V(virtualenv), V(virtualenv2), V(~/bin/virtualenv), V(/usr/local/bin/virtualenv)."
       ],
       "type": "path",
       "version_added": "1.1",
       "version_added_collection": "ansible.builtin"
      },
      "virtualenv_python": {
       "description": [
        "The Python executable used for creating the virtual environment. For example V(python3.12), V(python2.7). When not specified, the Python version used to run the ansible module is used. This parameter should not be used when O(virtualenv_command) is using V(pyvenv) or the C(-m venv) module."
       ],
       "type": "str",
       "version_added": "2.0",
       "version_added_collection": "ansible.builtin"
      },
      "virtualenv_site_packages": {
       "default": "no",
       "description": [
        "Whether the virtual environment will inherit packages from the global site-packages directory.  Note that if this setting is changed on an already existing virtual environment it will not have any effect, the environment must be deleted and newly created."
       ],
       "type": "bool",
       "version_added": "1.0",
       "version_added_collection": "ansible.builtin"
      }
     },
     "requirements": [
      "pip",
      "virtualenv",
      "setuptools or packaging"
     ],
     "short_description": "Manages Python library dependencies",
     "version_added": "0.7",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Install bottle python package\n  ansible.builtin.pip:\n    name: bottle\n\n- name: Install bottle python package on version 0.11\n  ansible.builtin.pip:\n    name: bottle==0.11\n\n- name: Install bottle python package with version specifiers\n  ansible.builtin.pip:\n    name: bottle>0.10,<0.20,!=0.11\n\n- name: Install multi python packages with version specifiers\n  ansible.builtin.pip:\n    name:\n      - django>1.11.0,<1.12.0\n      - bottle>0.10,<0.20,!=0.11\n\n- name: Install python package using a proxy\n  ansible.builtin.pip:\n    name: six\n  environment:\n    http_proxy: 'http://127.0.0.1:8080'\n    https_proxy: 'https://127.0.0.1:8080'\n\n# You do not have to supply '-e' option in extra_args\n- name: Install MyApp using one of the remote protocols (bzr+,hg+,git+,svn+)\n  ansible.builtin.pip:\n    name: svn+http://myrepo/svn/MyApp#egg=MyApp\n\n- name: Install MyApp using one of the remote protocols (bzr+,hg+,git+)\n  ansible.builtin.pip:\n    name: git+http://myrepo/app/MyApp\n\n- name: Install MyApp from local tarball\n  ansible.builtin.pip:\n    name: file:///path/to/MyApp.tar.gz\n\n- name: Install bottle into the specified (virtualenv), inheriting none of the globally installed modules\n  ansible.builtin.pip:\n    name: bottle\n    virtualenv: /my_app/venv\n\n- name: Install bottle into the specified (virtualenv), inheriting globally installed modules\n  ansible.builtin.pip:\n    name: bottle\n    virtualenv: /my_app/venv\n    virtualenv_site_packages: yes\n\n- name: Install bottle into the specified (virtualenv), using Python 2.7\n  ansible.builtin.pip:\n    name: bottle\n    virtualenv: /my_app/venv\n    virtualenv_command: virtualenv-2.7\n\n- name: Install bottle within a user home directory\n  ansible.builtin.pip:\n    name: bottle\n    extra_args: --user\n\n- name: Install specified python requirements\n  ansible.builtin.pip:\n    requirements: /my_app/requirements.txt\n\n- name: Install specified python requirements in indicated (virtualenv)\n  ansible.builtin.pip:\n    requirements: /my_app/requirements.txt\n    virtualenv: /my_app/venv\n\n- name: Install specified python requirements and custom Index URL\n  ansible.builtin.pip:\n    requirements: /my_app/requirements.txt\n    extra_args: -i https://example.com/pypi/simple\n\n- name: Install specified python requirements offline from a local directory with downloaded packages\n  ansible.builtin.pip:\n    requirements: /my_app/requirements.txt\n    extra_args: \"--no-index --find-links=file:///my_downloaded_packages_dir\"\n\n- name: Install bottle for Python 3.3 specifically, using the 'pip3.3' executable\n  ansible.builtin.pip:\n    name: bottle\n    executable: pip3.3\n\n- name: Install bottle, forcing reinstallation if it's already installed\n  ansible.builtin.pip:\n    name: bottle\n    state: forcereinstall\n\n- name: Install bottle while ensuring the umask is 0022 (to ensure other users can use it)\n  ansible.builtin.pip:\n    name: bottle\n    umask: \"0022\"\n  become: True\n\n- name: Run a module inside a virtual environment\n  block:\n    - name: Ensure the virtual environment exists\n      pip:\n        name: psutil\n        virtualenv: \"{{ venv_dir }}\"\n        # On Debian-based systems the correct python*-venv package must be installed to use the `venv` module.\n        virtualenv_command: \"{{ ansible_python_interpreter }} -m venv\"\n\n    - name: Run a module inside the virtual environment\n      wait_for:\n        port: 22\n      vars:\n        # Alternatively, use a block to affect multiple tasks, or use set_fact to affect the remainder of the playbook.\n        ansible_python_interpreter: \"{{ venv_python }}\"\n\n  vars:\n    venv_dir: /tmp/pick-a-better-venv-path\n    venv_python: \"{{ venv_dir }}/bin/python\"\n",
    "metadata": null,
    "return": {
     "cmd": {
      "description": "pip command used by the module",
      "returned": "success",
      "sample": "pip2 install ansible six",
      "type": "str"
     },
     "name": {
      "description": "list of python modules targeted by pip",
      "returned": "success",
      "sample": [
       "ansible",
       "six"
      ],
      "type": "list"
     },
     "requirements": {
      "description": "Path to the requirements file",
      "returned": "success, if a requirements file was provided",
      "sample": "/srv/git/project/requirements.txt",
      "type": "str"
     },
     "version": {
      "description": "Version of the package specified in 'name'",
      "returned": "success, if a name and version were provided",
      "sample": "2.5.1",
      "type": "str"
     },
     "virtualenv": {
      "description": "Path to the virtualenv",
      "returned": "success, if a virtualenv path was provided",
      "sample": "/tmp/virtualenv",
      "type": "str"
     }
    }
   },
   "ansible.builtin.raw": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "none"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "details": "This action is one of the few that requires no Python on the remote as it passes the command directly into the connection string",
       "platforms": "all",
       "support": "N/A"
      },
      "raw": {
       "description": "Indicates if an action takes a 'raw' or 'free form' string as an option and has it's own special parsing of it",
       "support": "full"
      }
     },
     "author": [
      "Ansible Core Team",
      "Michael DeHaan"
     ],
     "collection": "ansible.builtin",
     "description": [
      "Executes a low-down and dirty SSH command, not going through the module subsystem.",
      "This is useful and should only be done in a few cases. A common case is installing C(python) on a system without python installed by default. Another is speaking to any devices such as routers that do not have any Python installed. In any other case, using the M(ansible.builtin.shell) or M(ansible.builtin.command) module is much more appropriate.",
      "Arguments given to C(raw) are run directly through the configured remote shell.",
      "Standard output, error output and return code are returned when available.",
      "There is no change handler support for this module.",
      "This module does not require python on the remote system, much like the M(ansible.builtin.script) module.",
      "This module is also supported for Windows targets.",
      "If the command returns non UTF-8 data, it must be encoded to avoid issues. One option is to pipe the output through C(base64)."
     ],
     "filename": "/ansible/modules/raw.py",
     "has_action": true,
     "module": "raw",
     "notes": [
      "If using raw from a playbook, you may need to disable fact gathering using C(gather_facts: no) if you're using C(raw) to bootstrap python onto the machine.",
      "If you want to execute a command securely and predictably, it may be better to use the M(ansible.builtin.command) or M(ansible.builtin.shell) modules instead.",
      "The C(environment) keyword does not work with raw normally, it requires a shell which means it only works if C(executable) is set or using the module with privilege escalation (C(become))."
     ],
     "options": {
      "executable": {
       "description": [
        "Change the shell used to execute the command. Should be an absolute path to the executable.",
        "When using privilege escalation (C(become)) a default shell will be assigned if one is not provided as privilege escalation requires a shell."
       ],
       "version_added": "1.0",
       "version_added_collection": "ansible.builtin"
      },
      "free_form": {
       "description": [
        "The raw module takes a free form command to run.",
        "There is no parameter actually named 'free form'; see the examples!"
       ],
       "required": true
      }
     },
     "seealso": [
      {
       "module": "ansible.builtin.command"
      },
      {
       "module": "ansible.builtin.shell"
      },
      {
       "module": "ansible.windows.win_command"
      },
      {
       "module": "ansible.windows.win_shell"
      }
     ],
     "short_description": "Executes a low-down and dirty command",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Bootstrap a host without python2 installed\n  ansible.builtin.raw: dnf install -y python2 python2-dnf libselinux-python\n\n- name: Run a command that uses non-posix shell-isms (in this example /bin/sh doesn't handle redirection and wildcards together but bash does)\n  ansible.builtin.raw: cat < /tmp/*txt\n  args:\n    executable: /bin/bash\n\n- name: Safely use templated variables. Always use quote filter to avoid injection issues.\n  ansible.builtin.raw: \"{{ package_mgr|quote }} {{ pkg_flags|quote }} install {{ python|quote }}\"\n\n- name: List user accounts on a Windows system\n  ansible.builtin.raw: Get-WmiObject -Class Win32_UserAccount\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.reboot": {
    "doc": {
     "attributes": {
      "action": {
       "description": "Indicates this has a corresponding action plugin so some parts of the options can be executed on the controller",
       "support": "full"
      },
      "async": {
       "description": "Supports being used with the C(async) keyword",
       "support": "none"
      },
      "bypass_host_loop": {
       "description": [
        "Forces a 'global' task that does not execute per host, this bypasses per host templating and serial, throttle and other loop considerations",
        "Conditionals will work as if C(run_once) is being used, variables used will be from the first available host",
        "This action will not work normally outside of lockstep strategies"
       ],
       "support": "none"
      },
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "N/A"
      }
     },
     "author": [
      "Matt Davis (@nitzmahone)",
      "Sam Doran (@samdoran)"
     ],
     "collection": "ansible.builtin",
     "description": [
      "Reboot a machine, wait for it to go down, come back up, and respond to commands.",
      "For Windows targets, use the M(ansible.windows.win_reboot) module instead."
     ],
     "filename": "/ansible/modules/reboot.py",
     "has_action": true,
     "module": "reboot",
     "notes": [
      "E(PATH) is ignored on the remote node when searching for the C(shutdown) command. Use O(search_paths) to specify locations to search if the default paths do not work."
     ],
     "options": {
      "boot_time_command": {
       "default": "cat /proc/sys/kernel/random/boot_id",
       "description": [
        "Command to run that returns a unique string indicating the last time the system was booted.",
        "Setting this to a command that has different output each time it is run will cause the task to fail."
       ],
       "type": "str",
       "version_added": "2.10",
       "version_added_collection": "ansible.builtin"
      },
      "connect_timeout": {
       "description": [
        "Maximum seconds to wait for a successful connection to the managed hosts before trying again.",
        "If unspecified, the default setting for the underlying connection plugin is used."
       ],
       "type": "int"
      },
      "msg": {
       "default": "Reboot initiated by Ansible",
       "description": [
        "Message to display to users before reboot."
       ],
       "type": "str"
      },
      "post_reboot_delay": {
       "default": 0,
       "description": [
        "Seconds to wait after the reboot command was successful before attempting to validate the system rebooted successfully.",
        "This is useful if you want wait for something to settle despite your connection already working."
       ],
       "type": "int"
      },
      "pre_reboot_delay": {
       "default": 0,
       "description": [
        "Seconds to wait before reboot. Passed as a parameter to the reboot command.",
        "On Linux, macOS and OpenBSD, this is converted to minutes and rounded down. If less than 60, it will be set to 0.",
        "On Solaris and FreeBSD, this will be seconds."
       ],
       "type": "int"
      },
      "reboot_command": {
       "default": "[determined based on target OS]",
       "description": [
        "Command to run that reboots the system, including any parameters passed to the command.",
        "Can be an absolute path to the command or just the command name. If an absolute path to the command is not given, O(search_paths) on the target system will be searched to find the absolute path.",
        "This will cause O(pre_reboot_delay), O(post_reboot_delay), and O(msg) to be ignored."
       ],
       "type": "str",
       "version_added": "2.11",
       "version_added_collection": "ansible.builtin"
      },
      "reboot_timeout": {
       "default": 600,
       "description": [
        "Maximum seconds to wait for machine to reboot and respond to a test command.",
        "This timeout is evaluated separately for both reboot verification and test command success so the maximum execution time for the module is twice this amount."
       ],
       "type": "int"
      },
      "search_paths": {
       "default": [
        "/sbin",
        "/bin",
        "/usr/sbin",
        "/usr/bin",
        "/usr/local/sbin"
       ],
       "description": [
        "Paths to search on the remote machine for the C(shutdown) command.",
        "I(Only) these paths will be searched for the C(shutdown) command. E(PATH) is ignored in the remote node when searching for the C(shutdown) command."
       ],
       "elements": "str",
       "type": "list",
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      },
      "test_command": {
       "default": "whoami",
       "description": [
        "Command to run on the rebooted host and expect success from to determine the machine is ready for further tasks."
       ],
       "type": "str"
      }
     },
     "seealso": [
      {
       "module": "ansible.windows.win_reboot"
      }
     ],
     "short_description": "Reboot a machine",
     "version_added": "2.7",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Unconditionally reboot the machine with all defaults\n  ansible.builtin.reboot:\n\n- name: Reboot a slow machine that might have lots of updates to apply\n  ansible.builtin.reboot:\n    reboot_timeout: 3600\n\n- name: Reboot a machine with shutdown command in unusual place\n  ansible.builtin.reboot:\n    search_paths:\n     - '/lib/molly-guard'\n\n- name: Reboot machine using a custom reboot command\n  ansible.builtin.reboot:\n    reboot_command: launchctl reboot userspace\n    boot_time_command: uptime | cut -d ' ' -f 5\n\n- name: Reboot machine and send a message\n  ansible.builtin.reboot:\n    msg: \"Rebooting machine in 5 seconds\"\n\n",
    "metadata": null,
    "return": {
     "elapsed": {
      "description": "The number of seconds that elapsed waiting for the system to be rebooted.",
      "returned": "always",
      "sample": 23,
      "type": "int"
     },
     "rebooted": {
      "description": "true if the machine was rebooted",
      "returned": "always",
      "sample": true,
      "type": "bool"
     }
    }
   },
   "ansible.builtin.replace": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "full"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "N/A"
      },
      "safe_file_operations": {
       "description": "Uses Ansible's strict file operation functions to ensure proper permissions and avoid data corruption",
       "support": "full"
      },
      "vault": {
       "description": "Can automatically decrypt Ansible vaulted files",
       "support": "none"
      }
     },
     "author": "Evan Kaufman (@EvanK)",
     "collection": "ansible.builtin",
     "description": [
      "This module will replace all instances of a pattern within a file.",
      "It is up to the user to maintain idempotence by ensuring that the same pattern would never match any replacements made."
     ],
     "filename": "/ansible/modules/replace.py",
     "has_action": false,
     "module": "replace",
     "notes": [
      "As of Ansible 2.3, the O(dest) option has been changed to O(path) as default, but O(dest) still works as well.",
      "As of Ansible 2.7.10, the combined use of O(before) and O(after) works properly. If you were relying on the previous incorrect behavior, you may be need to adjust your tasks. See U(https://github.com/ansible/ansible/issues/31354) for details.",
      "Option O(ignore:follow) has been removed in Ansible 2.5, because this module modifies the contents of the file so O(ignore:follow=no) does not make sense."
     ],
     "options": {
      "after": {
       "description": [
        "If specified, only content after this match will be replaced/removed.",
        "Can be used in combination with O(before).",
        "Uses Python regular expressions; see U(https://docs.python.org/3/library/re.html).",
        "Uses DOTALL, which means the V(.) special character I(can match newlines)."
       ],
       "type": "str",
       "version_added": "2.4",
       "version_added_collection": "ansible.builtin"
      },
      "attributes": {
       "aliases": [
        "attr"
       ],
       "description": [
        "The attributes the resulting filesystem object should have.",
        "To get supported flags look at the man page for I(chattr) on the target system.",
        "This string should contain the attributes in the same order as the one displayed by I(lsattr).",
        "The C(=) operator is assumed as default, otherwise C(+) or C(-) operators need to be included in the string."
       ],
       "type": "str",
       "version_added": "2.3",
       "version_added_collection": "ansible.builtin"
      },
      "backup": {
       "default": false,
       "description": [
        "Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly."
       ],
       "type": "bool"
      },
      "before": {
       "description": [
        "If specified, only content before this match will be replaced/removed.",
        "Can be used in combination with O(after).",
        "Uses Python regular expressions; see U(https://docs.python.org/3/library/re.html).",
        "Uses DOTALL, which means the V(.) special character I(can match newlines)."
       ],
       "type": "str",
       "version_added": "2.4",
       "version_added_collection": "ansible.builtin"
      },
      "encoding": {
       "default": "utf-8",
       "description": [
        "The character encoding for reading and writing the file."
       ],
       "type": "str",
       "version_added": "2.4",
       "version_added_collection": "ansible.builtin"
      },
      "group": {
       "description": [
        "Name of the group that should own the filesystem object, as would be fed to I(chown).",
        "When left unspecified, it uses the current group of the current user unless you are root, in which case it can preserve the previous ownership."
       ],
       "type": "str"
      },
      "mode": {
       "description": [
        "The permissions the resulting filesystem object should have.",
        "For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must give Ansible enough information to parse them correctly. For consistent results, quote octal numbers (for example, V('644') or V('1777')) so Ansible receives a string and can do its own conversion from string into number. Adding a leading zero (for example, V(0755)) works sometimes, but can fail in loops and some other circumstances.",
        "Giving Ansible a number without following either of these rules will end up with a decimal number which will have unexpected results.",
        "As of Ansible 1.8, the mode may be specified as a symbolic mode (for example, V(u+rwx) or V(u=rw,g=r,o=r)).",
        "If O(mode) is not specified and the destination filesystem object B(does not) exist, the default C(umask) on the system will be used when setting the mode for the newly created filesystem object.",
        "If O(mode) is not specified and the destination filesystem object B(does) exist, the mode of the existing filesystem object will be used.",
        "Specifying O(mode) is the best way to ensure filesystem objects are created with the correct permissions. See CVE-2020-1736 for further details."
       ],
       "type": "raw"
      },
      "others": {
       "description": [
        "All arguments accepted by the M(ansible.builtin.file) module also work here."
       ],
       "type": "str"
      },
      "owner": {
       "description": [
        "Name of the user that should own the filesystem object, as would be fed to I(chown).",
        "When left unspecified, it uses the current user unless you are root, in which case it can preserve the previous ownership.",
        "Specifying a numeric username will be assumed to be a user ID and not a username. Avoid numeric usernames to avoid this confusion."
       ],
       "type": "str"
      },
      "path": {
       "aliases": [
        "dest",
        "destfile",
        "name"
       ],
       "description": [
        "The file to modify.",
        "Before Ansible 2.3 this option was only usable as O(dest), O(destfile) and O(name)."
       ],
       "required": true,
       "type": "path"
      },
      "regexp": {
       "description": [
        "The regular expression to look for in the contents of the file.",
        "Uses Python regular expressions; see U(https://docs.python.org/3/library/re.html).",
        "Uses MULTILINE mode, which means V(^) and V($) match the beginning and end of the file, as well as the beginning and end respectively of I(each line) of the file.",
        "Does not use DOTALL, which means the V(.) special character matches any character I(except newlines). A common mistake is to assume that a negated character set like V([^#]) will also not match newlines.",
        "In order to exclude newlines, they must be added to the set like V([^#\\\\n]).",
        "Note that, as of Ansible 2.0, short form tasks should have any escape sequences backslash-escaped in order to prevent them being parsed as string literal escapes. See the examples."
       ],
       "required": true,
       "type": "str"
      },
      "replace": {
       "default": "",
       "description": [
        "The string to replace regexp matches.",
        "May contain backreferences that will get expanded with the regexp capture groups if the regexp matches.",
        "If not set, matches are removed entirely.",
        "Backreferences can be used ambiguously like V(\\\\1), or explicitly like V(\\\\g<1>)."
       ],
       "type": "str"
      },
      "selevel": {
       "description": [
        "The level part of the SELinux filesystem object context.",
        "This is the MLS/MCS attribute, sometimes known as the C(range).",
        "When set to V(_default), it will use the C(level) portion of the policy if available."
       ],
       "type": "str"
      },
      "serole": {
       "description": [
        "The role part of the SELinux filesystem object context.",
        "When set to V(_default), it will use the C(role) portion of the policy if available."
       ],
       "type": "str"
      },
      "setype": {
       "description": [
        "The type part of the SELinux filesystem object context.",
        "When set to V(_default), it will use the C(type) portion of the policy if available."
       ],
       "type": "str"
      },
      "seuser": {
       "description": [
        "The user part of the SELinux filesystem object context.",
        "By default it uses the V(system) policy, where applicable.",
        "When set to V(_default), it will use the C(user) portion of the policy if available."
       ],
       "type": "str"
      },
      "unsafe_writes": {
       "default": false,
       "description": [
        "Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target filesystem object.",
        "By default this module uses atomic operations to prevent data corruption or inconsistent reads from the target filesystem objects, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted filesystem objects, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.",
        "This option allows Ansible to fall back to unsafe methods of updating filesystem objects when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes).",
        "IMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption."
       ],
       "type": "bool",
       "version_added": "2.2",
       "version_added_collection": "ansible.builtin"
      },
      "validate": {
       "description": [
        "The validation command to run before copying the updated file into the final destination.",
        "A temporary file path is used to validate, passed in through '%s' which must be present as in the examples below.",
        "Also, the command is passed securely so shell features such as expansion and pipes will not work.",
        "For an example on how to handle more complex validation than what this option provides, see R(handling complex validation,complex_configuration_validation)."
       ],
       "type": "str"
      }
     },
     "short_description": "Replace all instances of a particular string in a file using a back-referenced regular expression",
     "version_added": "1.6",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Replace old hostname with new hostname (requires Ansible >= 2.4)\n  ansible.builtin.replace:\n    path: /etc/hosts\n    regexp: '(\\s+)old\\.host\\.name(\\s+.*)?$'\n    replace: '\\1new.host.name\\2'\n\n- name: Replace after the expression till the end of the file (requires Ansible >= 2.4)\n  ansible.builtin.replace:\n    path: /etc/apache2/sites-available/default.conf\n    after: 'NameVirtualHost [*]'\n    regexp: '^(.+)$'\n    replace: '# \\1'\n\n- name: Replace before the expression till the begin of the file (requires Ansible >= 2.4)\n  ansible.builtin.replace:\n    path: /etc/apache2/sites-available/default.conf\n    before: '# live site config'\n    regexp: '^(.+)$'\n    replace: '# \\1'\n\n# Prior to Ansible 2.7.10, using before and after in combination did the opposite of what was intended.\n# see https://github.com/ansible/ansible/issues/31354 for details.\n- name: Replace between the expressions (requires Ansible >= 2.4)\n  ansible.builtin.replace:\n    path: /etc/hosts\n    after: '<VirtualHost [*]>'\n    before: '</VirtualHost>'\n    regexp: '^(.+)$'\n    replace: '# \\1'\n\n- name: Supports common file attributes\n  ansible.builtin.replace:\n    path: /home/jdoe/.ssh/known_hosts\n    regexp: '^old\\.host\\.name[^\\n]*\\n'\n    owner: jdoe\n    group: jdoe\n    mode: '0644'\n\n- name: Supports a validate command\n  ansible.builtin.replace:\n    path: /etc/apache/ports\n    regexp: '^(NameVirtualHost|Listen)\\s+80\\s*$'\n    replace: '\\1 127.0.0.1:8080'\n    validate: '/usr/sbin/apache2ctl -f %s -t'\n\n- name: Short form task (in ansible 2+) necessitates backslash-escaped sequences\n  ansible.builtin.replace: path=/etc/hosts regexp='\\\\b(localhost)(\\\\d*)\\\\b' replace='\\\\1\\\\2.localdomain\\\\2 \\\\1\\\\2'\n\n- name: Long form task does not\n  ansible.builtin.replace:\n    path: /etc/hosts\n    regexp: '\\b(localhost)(\\d*)\\b'\n    replace: '\\1\\2.localdomain\\2 \\1\\2'\n\n- name: Explicitly specifying positional matched groups in replacement\n  ansible.builtin.replace:\n    path: /etc/ssh/sshd_config\n    regexp: '^(ListenAddress[ ]+)[^\\n]+$'\n    replace: '\\g<1>0.0.0.0'\n\n- name: Explicitly specifying named matched groups\n  ansible.builtin.replace:\n    path: /etc/ssh/sshd_config\n    regexp: '^(?P<dctv>ListenAddress[ ]+)(?P<host>[^\\n]+)$'\n    replace: '#\\g<dctv>\\g<host>\\n\\g<dctv>0.0.0.0'\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.rpm_key": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "rhel",
       "support": "N/A"
      }
     },
     "author": [
      "Hector Acosta (@hacosta) <hector.acosta@gazzang.com>"
     ],
     "collection": "ansible.builtin",
     "description": [
      "Adds or removes (rpm --import) a gpg key to your rpm database."
     ],
     "filename": "/ansible/modules/rpm_key.py",
     "has_action": false,
     "module": "rpm_key",
     "options": {
      "fingerprint": {
       "description": [
        "The long-form fingerprint of the key being imported.",
        "This will be used to verify the specified key."
       ],
       "type": "str",
       "version_added": 2.9,
       "version_added_collection": "ansible.builtin"
      },
      "key": {
       "description": [
        "Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key already exists in the database."
       ],
       "required": true,
       "type": "str"
      },
      "state": {
       "choices": [
        "absent",
        "present"
       ],
       "default": "present",
       "description": [
        "If the key will be imported or removed from the rpm db."
       ],
       "type": "str"
      },
      "validate_certs": {
       "default": "yes",
       "description": [
        "If V(false) and the O(key) is a url starting with V(https), SSL certificates will not be validated.",
        "This should only be used on personally controlled sites using self-signed certificates."
       ],
       "type": "bool"
      }
     },
     "short_description": "Adds or removes a gpg key from the rpm db",
     "version_added": "1.3",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.script": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "details": "while the script itself is arbitrary and cannot be subject to the check mode semantics it adds O(creates)/O(removes) options as a workaround",
       "support": "partial"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "details": "This action is one of the few that requires no Python on the remote as it passes the command directly into the connection string",
       "platforms": "all",
       "support": "N/A"
      },
      "raw": {
       "description": "Indicates if an action takes a 'raw' or 'free form' string as an option and has it's own special parsing of it",
       "support": "full"
      },
      "safe_file_operations": {
       "description": "Uses Ansible's strict file operation functions to ensure proper permissions and avoid data corruption",
       "support": "none"
      },
      "vault": {
       "description": "Can automatically decrypt Ansible vaulted files",
       "support": "full"
      }
     },
     "author": [
      "Ansible Core Team",
      "Michael DeHaan"
     ],
     "collection": "ansible.builtin",
     "description": [
      "The M(ansible.builtin.script) module takes the script name followed by a list of space-delimited arguments.",
      "Either a free-form command or O(cmd) parameter is required, see the examples.",
      "The local script at the path will be transferred to the remote node and then executed.",
      "The given script will be processed through the shell environment on the remote node.",
      "This module does not require Python on the remote system, much like the M(ansible.builtin.raw) module.",
      "This module is also supported for Windows targets."
     ],
     "filename": "/ansible/modules/script.py",
     "has_action": true,
     "module": "script",
     "notes": [
      "It is usually preferable to write Ansible modules rather than pushing scripts. Convert your script to an Ansible module for bonus points!",
      "The P(ansible.builtin.ssh#connection) connection plugin will force pseudo-tty allocation via C(-tt) when scripts are executed. Pseudo-ttys do not have a stderr channel and all stderr is sent to stdout. If you depend on separated stdout and stderr result keys, please switch to a set of tasks that comprises M(ansible.builtin.copy) with M(ansible.builtin.command) instead of using M(ansible.builtin.script).",
      "If the path to the local script contains spaces, it needs to be quoted.",
      "This module is also supported for Windows targets.",
      "If the script returns non-UTF-8 data, it must be encoded to avoid issues. One option is to pipe the output through C(base64)."
     ],
     "options": {
      "chdir": {
       "description": [
        "Change into this directory on the remote node before running the script."
       ],
       "type": "str",
       "version_added": "2.4",
       "version_added_collection": "ansible.builtin"
      },
      "cmd": {
       "description": [
        "Path to the local script to run followed by optional arguments."
       ],
       "type": "str"
      },
      "creates": {
       "description": [
        "A filename on the remote node, when it already exists, this step will B(not) be run."
       ],
       "type": "str",
       "version_added": "1.5",
       "version_added_collection": "ansible.builtin"
      },
      "decrypt": {
       "default": true,
       "description": [
        "This option controls the auto-decryption of source files using vault."
       ],
       "type": "bool",
       "version_added": "2.4",
       "version_added_collection": "ansible.builtin"
      },
      "executable": {
       "description": [
        "Name or path of an executable to invoke the script with."
       ],
       "type": "str",
       "version_added": "2.6",
       "version_added_collection": "ansible.builtin"
      },
      "free_form": {
       "description": [
        "Path to the local script file followed by optional arguments."
       ],
       "type": "str"
      },
      "removes": {
       "description": [
        "A filename on the remote node, when it does not exist, this step will B(not) be run."
       ],
       "type": "str",
       "version_added": "1.5",
       "version_added_collection": "ansible.builtin"
      }
     },
     "seealso": [
      {
       "module": "ansible.builtin.shell"
      },
      {
       "module": "ansible.windows.win_shell"
      }
     ],
     "short_description": "Runs a local script on a remote node after transferring it",
     "version_added": "0.9",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Run a script with arguments (free form)\n  ansible.builtin.script: /some/local/script.sh --some-argument 1234\n\n- name: Run a script with arguments (using 'cmd' parameter)\n  ansible.builtin.script:\n    cmd: /some/local/script.sh --some-argument 1234\n\n- name: Run a script only if file.txt does not exist on the remote node\n  ansible.builtin.script: /some/local/create_file.sh --some-argument 1234\n  args:\n    creates: /the/created/file.txt\n\n- name: Run a script only if file.txt exists on the remote node\n  ansible.builtin.script: /some/local/remove_file.sh --some-argument 1234\n  args:\n    removes: /the/removed/file.txt\n\n- name: Run a script using an executable in a non-system path\n  ansible.builtin.script: /some/local/script\n  args:\n    executable: /some/remote/executable\n\n- name: Run a script using an executable in a system path\n  ansible.builtin.script: /some/local/script.py\n  args:\n    executable: python3\n\n- name: Run a Powershell script on a Windows host\n  script: subdirectories/under/path/with/your/playbook/script.ps1\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.service": {
    "doc": {
     "attributes": {
      "action": {
       "description": "Indicates this has a corresponding action plugin so some parts of the options can be executed on the controller",
       "support": "full"
      },
      "async": {
       "description": "Supports being used with the C(async) keyword",
       "support": "full"
      },
      "bypass_host_loop": {
       "description": [
        "Forces a 'global' task that does not execute per host, this bypasses per host templating and serial, throttle and other loop considerations",
        "Conditionals will work as if C(run_once) is being used, variables used will be from the first available host",
        "This action will not work normally outside of lockstep strategies"
       ],
       "support": "none"
      },
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "details": "support depends on the underlying plugin invoked",
       "support": "N/A"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "details": "support depends on the underlying plugin invoked",
       "support": "N/A"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "details": "The support depends on the availability for the specific plugin for each platform and if fact gathering is able to detect it",
       "platforms": "all",
       "support": "N/A"
      }
     },
     "author": [
      "Ansible Core Team",
      "Michael DeHaan"
     ],
     "collection": "ansible.builtin",
     "description": [
      "Controls services on remote hosts. Supported init systems include BSD init, OpenRC, SysV, Solaris SMF, systemd, upstart.",
      "This module acts as a proxy to the underlying service manager module. While all arguments will be passed to the underlying module, not all modules support the same arguments. This documentation only covers the minimum intersection of module arguments that all service manager modules support.",
      "This module is a proxy for multiple more specific service manager modules (such as M(ansible.builtin.systemd) and M(ansible.builtin.sysvinit)). This allows management of a heterogeneous environment of machines without creating a specific task for each service manager. The module to be executed is determined by the O(use) option, which defaults to the service manager discovered by M(ansible.builtin.setup).  If M(ansible.builtin.setup) was not yet run, this module may run it.",
      "For Windows targets, use the M(ansible.windows.win_service) module instead."
     ],
     "filename": "/ansible/modules/service.py",
     "has_action": true,
     "module": "service",
     "notes": [
      "For AIX, group subsystem names can be used.",
      "The C(service) command line utility is not part of any service manager system but a convenience. It does not have a standard implementation across systems, and this action cannot use it directly. Though it might be used if found in certain circumstances, the detected system service manager is normally preferred."
     ],
     "options": {
      "arguments": {
       "aliases": [
        "args"
       ],
       "default": "",
       "description": [
        "Additional arguments provided on the command line.",
        "While using remote hosts with systemd this setting will be ignored."
       ],
       "type": "str"
      },
      "enabled": {
       "description": [
        "Whether the service should start on boot.",
        "B(At least one of state and enabled are required.)"
       ],
       "type": "bool"
      },
      "name": {
       "description": [
        "Name of the service."
       ],
       "required": true,
       "type": "str"
      },
      "pattern": {
       "description": [
        "If the service does not respond to the status command, name a substring to look for as would be found in the output of the I(ps) command as a stand-in for a status result.",
        "If the string is found, the service will be assumed to be started.",
        "While using remote hosts with systemd this setting will be ignored."
       ],
       "type": "str",
       "version_added": "0.7",
       "version_added_collection": "ansible.builtin"
      },
      "runlevel": {
       "default": "default",
       "description": [
        "For OpenRC init scripts (e.g. Gentoo) only.",
        "The runlevel that this service belongs to.",
        "While using remote hosts with systemd this setting will be ignored."
       ],
       "type": "str"
      },
      "sleep": {
       "description": [
        "If the service is being V(restarted) then sleep this many seconds between the stop and start command.",
        "This helps to work around badly-behaving init scripts that exit immediately after signaling a process to stop.",
        "Not all service managers support sleep, i.e when using systemd this setting will be ignored."
       ],
       "type": "int",
       "version_added": "1.3",
       "version_added_collection": "ansible.builtin"
      },
      "state": {
       "choices": [
        "reloaded",
        "restarted",
        "started",
        "stopped"
       ],
       "description": [
        "V(started)/V(stopped) are idempotent actions that will not run commands unless necessary.",
        "V(restarted) will always bounce the service.",
        "V(reloaded) will always reload.",
        "B(At least one of state and enabled are required.)",
        "Note that reloaded will start the service if it is not already started, even if your chosen init system wouldn't normally."
       ],
       "type": "str"
      },
      "use": {
       "default": "auto",
       "description": [
        "The service module actually uses system specific modules, normally through auto detection, this setting can force a specific module.",
        "Normally it uses the value of the 'ansible_service_mgr' fact and falls back to the old 'service' module when none matching is found.",
        "The 'old service module' still uses autodetection and in no way does it correspond to the C(service) command."
       ],
       "type": "str",
       "version_added": 2.2,
       "version_added_collection": "ansible.builtin"
      }
     },
     "seealso": [
      {
       "module": "ansible.windows.win_service"
      }
     ],
     "short_description": "Manage services",
     "version_added": "0.1",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Start service httpd, if not started\n  ansible.builtin.service:\n    name: httpd\n    state: started\n\n- name: Stop service httpd, if started\n  ansible.builtin.service:\n    name: httpd\n    state: stopped\n\n- name: Restart service httpd, in all cases\n  ansible.builtin.service:\n    name: httpd\n    state: restarted\n\n- name: Reload service httpd, in all cases\n  ansible.builtin.service:\n    name: httpd\n    state: reloaded\n\n- name: Enable service httpd, and not touch the state\n  ansible.builtin.service:\n    name: httpd\n    enabled: yes\n\n- name: Start service foo, based on running process /usr/bin/foo\n  ansible.builtin.service:\n    name: foo\n    pattern: /usr/bin/foo\n    state: started\n\n- name: Restart network service for interface eth0\n  ansible.builtin.service:\n    name: network\n    state: restarted\n    args: eth0\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.service_facts": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "facts": {
       "description": "Action returns an C(ansible_facts) dictionary that will update existing host facts",
       "support": "full"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "N/A"
      }
     },
     "author": [
      "Adam Miller (@maxamillion)"
     ],
     "collection": "ansible.builtin",
     "description": [
      "Return service state information as fact data for various service management utilities."
     ],
     "filename": "/ansible/modules/service_facts.py",
     "has_action": false,
     "module": "service_facts",
     "notes": [
      "When accessing the RV(ansible_facts.services) facts collected by this module, it is recommended to not use \"dot notation\" because services can have a C(-) character in their name which would result in invalid \"dot notation\", such as C(ansible_facts.services.zuul-gateway). It is instead recommended to using the string value of the service name as the key in order to obtain the fact data value like C(ansible_facts.services['zuul-gateway'])",
      "AIX SRC was added in version 2.11."
     ],
     "requirements": [
      "Any of the following supported init systems: systemd, sysv, upstart, openrc, AIX SRC"
     ],
     "short_description": "Return service state information as fact data",
     "version_added": "2.5",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Populate service facts\n  ansible.builtin.service_facts:\n\n- name: Print service facts\n  ansible.builtin.debug:\n    var: ansible_facts.services\n",
    "metadata": null,
    "return": {
     "ansible_facts": {
      "contains": {
       "services": {
        "contains": {
         "name": {
          "description": "Name of the service.",
          "returned": "always",
          "sample": "arp-ethers.service",
          "type": "str"
         },
         "source": {
          "description": [
           "Init system of the service.",
           "One of V(rcctl), V(systemd), V(sysv), V(upstart), V(src)."
          ],
          "returned": "always",
          "sample": "sysv",
          "type": "str"
         },
         "state": {
          "description": [
           "State of the service.",
           "This commonly includes (but is not limited to) the following: V(failed), V(running), V(stopped) or V(unknown).",
           "Depending on the used init system additional states might be returned."
          ],
          "returned": "always",
          "sample": "running",
          "type": "str"
         },
         "status": {
          "description": [
           "State of the service.",
           "Either V(enabled), V(disabled), V(static), V(indirect) or V(unknown)."
          ],
          "returned": "systemd systems or RedHat/SUSE flavored sysvinit/upstart or OpenBSD",
          "sample": "enabled",
          "type": "str"
         }
        },
        "description": "States of the services with service name as key.",
        "elements": "dict",
        "returned": "always",
        "type": "list"
       }
      },
      "description": "Facts to add to ansible_facts about the services on the system",
      "returned": "always",
      "type": "complex"
     }
    }
   },
   "ansible.builtin.set_fact": {
    "doc": {
     "attributes": {
      "action": {
       "description": "Indicates this has a corresponding action plugin so some parts of the options can be executed on the controller",
       "details": "While the action plugin does do some of the work it relies on the core engine to actually create the variables, that part cannot be overridden",
       "support": "partial"
      },
      "async": {
       "description": "Supports being used with the C(async) keyword",
       "support": "none"
      },
      "become": {
       "description": "Is usable alongside become keywords",
       "support": "none"
      },
      "bypass_host_loop": {
       "description": [
        "Forces a 'global' task that does not execute per host, this bypasses per host templating and serial, throttle and other loop considerations",
        "Conditionals will work as if C(run_once) is being used, variables used will be from the first available host",
        "This action will not work normally outside of lockstep strategies"
       ],
       "support": "none"
      },
      "bypass_task_loop": {
       "description": "These tasks ignore the C(loop) and C(with_) keywords",
       "support": "none"
      },
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "connection": {
       "description": "Uses the target's configured connection information to execute code on it",
       "support": "none"
      },
      "core": {
       "description": "This is a 'core engine' feature and is not implemented like most task actions, so it is not overridable in any way via the plugin system.",
       "details": "While parts of this action are implemented in core, other parts are still available as normal plugins and can be partially overridden",
       "support": "partial"
      },
      "delegation": {
       "description": "Can be used in conjunction with delegate_to and related keywords",
       "details": [
        "while variable assignment can be delegated to a different host the execution context is always the current inventory_hostname",
        "connection variables, if set at all, would reflect the host it would target, even if we are not connecting at all in this case"
       ],
       "support": "partial"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "ignore_conditional": {
       "description": "The action is not subject to conditional execution so it will ignore the C(when:) keyword",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "all",
       "support": "N/A"
      },
      "tags": {
       "description": "Allows for the 'tags' keyword to control the selection of this action for execution",
       "support": "full"
      },
      "until": {
       "description": "Denotes if this action obeys until/retry/poll keywords",
       "support": "full"
      }
     },
     "author": [
      "Dag Wieers (@dagwieers)"
     ],
     "collection": "ansible.builtin",
     "description": [
      "This action allows setting variables associated to the current host.",
      "These variables will be available to subsequent plays during an ansible-playbook run via the host they were set on.",
      "Set O(cacheable) to V(true) to save variables across executions using a fact cache. Variables will keep the set_fact precedence for the current run, but will used 'cached fact' precedence for subsequent ones.",
      "Per the standard Ansible variable precedence rules, other types of variables have a higher priority, so this value may be overridden."
     ],
     "filename": "/ansible/modules/set_fact.py",
     "has_action": true,
     "module": "set_fact",
     "notes": [
      "Because of the nature of tasks, set_fact will produce 'static' values for a variable. Unlike normal 'lazy' variables, the value gets evaluated and templated on assignment.",
      "Some boolean values (yes, no, true, false) will always be converted to boolean type, unless C(DEFAULT_JINJA2_NATIVE) is enabled.  This is done so the C(var=value) booleans, otherwise it would only be able to create strings, but it also prevents using those values to create YAML strings. Using the setting will restrict k=v to strings, but will allow you to specify string or boolean in YAML.",
      "To create lists/arrays or dictionary/hashes use YAML notation C(var: [val1, val2]).",
      "Since 'cacheable' is now a module param, 'cacheable' is no longer a valid fact name."
     ],
     "options": {
      "cacheable": {
       "default": false,
       "description": [
        "This boolean converts the variable into an actual 'fact' which will also be added to the fact cache. It does not enable fact caching across runs, it just means it will work with it if already enabled.",
        "Normally this module creates 'host level variables' and has much higher precedence, this option changes the nature and precedence (by 7 steps) of the variable created. U(https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable)",
        "This actually creates 2 copies of the variable, a normal 'set_fact' host variable with high precedence and a lower 'ansible_fact' one that is available for persistence via the facts cache plugin. This creates a possibly confusing interaction with C(meta: clear_facts) as it will remove the 'ansible_fact' but not the host variable."
       ],
       "type": "bool",
       "version_added": "2.4",
       "version_added_collection": "ansible.builtin"
      },
      "key_value": {
       "description": [
        "The M(ansible.builtin.set_fact) module takes C(key=value) pairs or C(key: value) (YAML notation) as variables to set in the playbook scope. The 'key' is the resulting variable name and the value is, of course, the value of said variable.",
        "You can create multiple variables at once, by supplying multiple pairs, but do NOT mix notations."
       ],
       "required": true
      }
     },
     "seealso": [
      {
       "module": "ansible.builtin.include_vars"
      },
      {
       "description": "More information related to variable precedence and which type of variable wins over others.",
       "ref": "ansible_variable_precedence"
      }
     ],
     "short_description": "Set host variable(s) and fact(s).",
     "version_added": "1.2",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Setting host facts using key=value pairs, this format can only create strings or booleans\n  ansible.builtin.set_fact: one_fact=\"something\" other_fact=\"{{ local_var }}\"\n\n- name: Setting host facts using complex arguments\n  ansible.builtin.set_fact:\n    one_fact: something\n    other_fact: \"{{ local_var * 2 }}\"\n    another_fact: \"{{ some_registered_var.results | map(attribute='ansible_facts.some_fact') | list }}\"\n\n- name: Setting facts so that they will be persisted in the fact cache\n  ansible.builtin.set_fact:\n    one_fact: something\n    other_fact: \"{{ local_var * 2 }}\"\n    cacheable: yes\n\n- name: Creating list and dictionary variables\n  ansible.builtin.set_fact:\n    one_dict:\n        something: here\n        other: there\n    one_list:\n        - a\n        - b\n        - c\n# As of Ansible 1.8, Ansible will convert boolean strings ('true', 'false', 'yes', 'no')\n# to proper boolean values when using the key=value syntax, however it is still\n# recommended that booleans be set using the complex argument style:\n- name: Setting booleans using complex argument style\n  ansible.builtin.set_fact:\n    one_fact: yes\n    other_fact: no\n\n- name: Creating list and dictionary variables using 'shorthand' YAML\n  ansible.builtin.set_fact:\n    two_dict: {'something': here2, 'other': somewhere}\n    two_list: [1,2,3]\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.set_stats": {
    "doc": {
     "attributes": {
      "action": {
       "description": "Indicates this has a corresponding action plugin so some parts of the options can be executed on the controller",
       "details": "While the action plugin does do some of the work it relies on the core engine to actually create the variables, that part cannot be overridden",
       "support": "partial"
      },
      "async": {
       "description": "Supports being used with the C(async) keyword",
       "support": "none"
      },
      "become": {
       "description": "Is usable alongside become keywords",
       "support": "none"
      },
      "bypass_host_loop": {
       "description": [
        "Forces a 'global' task that does not execute per host, this bypasses per host templating and serial, throttle and other loop considerations",
        "Conditionals will work as if C(run_once) is being used, variables used will be from the first available host",
        "This action will not work normally outside of lockstep strategies"
       ],
       "support": "none"
      },
      "bypass_task_loop": {
       "description": "These tasks ignore the C(loop) and C(with_) keywords",
       "support": "none"
      },
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "connection": {
       "description": "Uses the target's configured connection information to execute code on it",
       "support": "none"
      },
      "core": {
       "description": "This is a 'core engine' feature and is not implemented like most task actions, so it is not overridable in any way via the plugin system.",
       "details": "While parts of this action are implemented in core, other parts are still available as normal plugins and can be partially overridden",
       "support": "partial"
      },
      "delegation": {
       "description": "Can be used in conjunction with delegate_to and related keywords",
       "support": "none"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "ignore_conditional": {
       "description": "The action is not subject to conditional execution so it will ignore the C(when:) keyword",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "all",
       "support": "N/A"
      },
      "tags": {
       "description": "Allows for the 'tags' keyword to control the selection of this action for execution",
       "support": "full"
      },
      "until": {
       "description": "Denotes if this action obeys until/retry/poll keywords",
       "support": "full"
      }
     },
     "author": "Brian Coca (@bcoca)",
     "collection": "ansible.builtin",
     "description": [
      "This module allows setting/accumulating stats on the current ansible run, either per host or for all hosts in the run.",
      "This module is also supported for Windows targets."
     ],
     "filename": "/ansible/modules/set_stats.py",
     "has_action": true,
     "module": "set_stats",
     "notes": [
      "In order for custom stats to be displayed, you must set C(show_custom_stats) in section C([defaults]) in C(ansible.cfg) or by defining environment variable C(ANSIBLE_SHOW_CUSTOM_STATS) to V(true). See the P(ansible.builtin.default#callback) callback plugin for details."
     ],
     "options": {
      "aggregate": {
       "default": true,
       "description": [
        "Whether the provided value is aggregated to the existing stat V(true) or will replace it V(false)."
       ],
       "type": "bool"
      },
      "data": {
       "description": [
        "A dictionary of which each key represents a stat (or variable) you want to keep track of."
       ],
       "required": true,
       "type": "dict"
      },
      "per_host": {
       "default": false,
       "description": [
        "whether the stats are per host or for all hosts in the run."
       ],
       "type": "bool"
      }
     },
     "short_description": "Define and display stats for the current ansible run",
     "version_added": "2.3",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Aggregating packages_installed stat per host\n  ansible.builtin.set_stats:\n    data:\n      packages_installed: 31\n    per_host: yes\n\n- name: Aggregating random stats for all hosts using complex arguments\n  ansible.builtin.set_stats:\n    data:\n      one_stat: 11\n      other_stat: \"{{ local_var * 2 }}\"\n      another_stat: \"{{ some_registered_var.results | map(attribute='ansible_facts.some_fact') | list }}\"\n    per_host: no\n\n- name: Setting stats (not aggregating)\n  ansible.builtin.set_stats:\n    data:\n      the_answer: 42\n    aggregate: no\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.setup": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "facts": {
       "description": "Action returns an C(ansible_facts) dictionary that will update existing host facts",
       "support": "full"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix, windows",
       "support": "N/A"
      }
     },
     "author": [
      "Ansible Core Team",
      "Michael DeHaan"
     ],
     "collection": "ansible.builtin",
     "description": [
      "This module is automatically called by playbooks to gather useful variables about remote hosts that can be used in playbooks. It can also be executed directly by C(/usr/bin/ansible) to check what variables are available to a host. Ansible provides many I(facts) about the system, automatically.",
      "This module is also supported for Windows targets."
     ],
     "filename": "/ansible/modules/setup.py",
     "has_action": false,
     "module": "setup",
     "notes": [
      "More ansible facts will be added with successive releases. If I(facter) or I(ohai) are installed, variables from these programs will also be snapshotted into the JSON file for usage in templating. These variables are prefixed with C(facter_) and C(ohai_) so it's easy to tell their source. All variables are bubbled up to the caller. Using the ansible facts and choosing to not install I(facter) and I(ohai) means you can avoid Ruby-dependencies on your remote systems. (See also M(community.general.facter) and M(community.general.ohai).)",
      "The filter option filters only the first level subkey below ansible_facts.",
      "If the target host is Windows, you will not currently have the ability to use O(filter) as this is provided by a simpler implementation of the module.",
      "This module should be run with elevated privileges on BSD systems to gather facts like ansible_product_version.",
      "For more information about delegated facts, please check U(https://docs.ansible.com/ansible/latest/user_guide/playbooks_delegation.html#delegating-facts)."
     ],
     "options": {
      "fact_path": {
       "default": "/etc/ansible/facts.d",
       "description": [
        "Path used for local ansible facts (C(*.fact)) - files in this dir will be run (if executable) and their results be added to C(ansible_local) facts. If a file is not executable it is read instead. File/results format can be JSON or INI-format. The default O(fact_path) can be specified in C(ansible.cfg) for when setup is automatically called as part of C(gather_facts). NOTE - For windows clients, the results will be added to a variable named after the local file (without extension suffix), rather than C(ansible_local).",
        "Since Ansible 2.1, Windows hosts can use O(fact_path). Make sure that this path exists on the target host. Files in this path MUST be PowerShell scripts C(.ps1) which outputs an object. This object will be formatted by Ansible as json so the script should be outputting a raw hashtable, array, or other primitive object."
       ],
       "type": "path",
       "version_added": "1.3",
       "version_added_collection": "ansible.builtin"
      },
      "filter": {
       "default": [],
       "description": [
        "If supplied, only return facts that match one of the shell-style (fnmatch) pattern. An empty list basically means 'no filter'. As of Ansible 2.11, the type has changed from string to list and the default has became an empty list. A simple string is still accepted and works as a single pattern. The behaviour prior to Ansible 2.11 remains."
       ],
       "elements": "str",
       "type": "list",
       "version_added": "1.1",
       "version_added_collection": "ansible.builtin"
      },
      "gather_subset": {
       "default": "all",
       "description": [
        "If supplied, restrict the additional facts collected to the given subset. Possible values: V(all), V(all_ipv4_addresses), V(all_ipv6_addresses), V(apparmor), V(architecture), V(caps), V(chroot),V(cmdline), V(date_time), V(default_ipv4), V(default_ipv6), V(devices), V(distribution), V(distribution_major_version), V(distribution_release), V(distribution_version), V(dns), V(effective_group_ids), V(effective_user_id), V(env), V(facter), V(fips), V(hardware), V(interfaces), V(is_chroot), V(iscsi), V(kernel), V(local), V(lsb), V(machine), V(machine_id), V(mounts), V(network), V(ohai), V(os_family), V(pkg_mgr), V(platform), V(processor), V(processor_cores), V(processor_count), V(python), V(python_version), V(real_user_id), V(selinux), V(service_mgr), V(ssh_host_key_dsa_public), V(ssh_host_key_ecdsa_public), V(ssh_host_key_ed25519_public), V(ssh_host_key_rsa_public), V(ssh_host_pub_keys), V(ssh_pub_keys), V(system), V(system_capabilities), V(system_capabilities_enforced), V(user), V(user_dir), V(user_gecos), V(user_gid), V(user_id), V(user_shell), V(user_uid), V(virtual), V(virtualization_role), V(virtualization_type). Can specify a list of values to specify a larger subset. Values can also be used with an initial C(!) to specify that that specific subset should not be collected.  For instance: V(!hardware,!network,!virtual,!ohai,!facter). If V(!all) is specified then only the min subset is collected. To avoid collecting even the min subset, specify V(!all,!min). To collect only specific facts, use V(!all,!min), and specify the particular fact subsets. Use the filter parameter if you do not want to display some collected facts."
       ],
       "elements": "str",
       "type": "list",
       "version_added": "2.1",
       "version_added_collection": "ansible.builtin"
      },
      "gather_timeout": {
       "default": 10,
       "description": [
        "Set the default timeout in seconds for individual fact gathering."
       ],
       "type": "int",
       "version_added": "2.2",
       "version_added_collection": "ansible.builtin"
      }
     },
     "short_description": "Gathers facts about remote hosts",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# Display facts from all hosts and store them indexed by `hostname` at `/tmp/facts`.\n# ansible all -m ansible.builtin.setup --tree /tmp/facts\n\n# Display only facts regarding memory found by ansible on all hosts and output them.\n# ansible all -m ansible.builtin.setup -a 'filter=ansible_*_mb'\n\n# Display only facts returned by facter.\n# ansible all -m ansible.builtin.setup -a 'filter=facter_*'\n\n# Collect only facts returned by facter.\n# ansible all -m ansible.builtin.setup -a 'gather_subset=!all,facter'\n\n- name: Collect only facts returned by facter\n  ansible.builtin.setup:\n    gather_subset:\n      - '!all'\n      - '!<any valid subset>'\n      - facter\n\n- name: Filter and return only selected facts\n  ansible.builtin.setup:\n    filter:\n      - 'ansible_distribution'\n      - 'ansible_machine_id'\n      - 'ansible_*_mb'\n\n# Display only facts about certain interfaces.\n# ansible all -m ansible.builtin.setup -a 'filter=ansible_eth[0-2]'\n\n# Restrict additional gathered facts to network and virtual (includes default minimum facts)\n# ansible all -m ansible.builtin.setup -a 'gather_subset=network,virtual'\n\n# Collect only network and virtual (excludes default minimum facts)\n# ansible all -m ansible.builtin.setup -a 'gather_subset=!all,network,virtual'\n\n# Do not call puppet facter or ohai even if present.\n# ansible all -m ansible.builtin.setup -a 'gather_subset=!facter,!ohai'\n\n# Only collect the default minimum amount of facts:\n# ansible all -m ansible.builtin.setup -a 'gather_subset=!all'\n\n# Collect no facts, even the default minimum subset of facts:\n# ansible all -m ansible.builtin.setup -a 'gather_subset=!all,!min'\n\n# Display facts from Windows hosts with custom facts stored in C:\\custom_facts.\n# ansible windows -m ansible.builtin.setup -a \"fact_path='c:\\custom_facts'\"\n\n# Gathers facts for the machines in the dbservers group (a.k.a Delegating facts)\n- hosts: app_servers\n  tasks:\n    - name: Gather facts from db servers\n      ansible.builtin.setup:\n      delegate_to: \"{{ item }}\"\n      delegate_facts: true\n      loop: \"{{ groups['dbservers'] }}\"\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.shell": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "details": "while the command itself is arbitrary and cannot be subject to the check mode semantics it adds O(creates)/O(removes) options as a workaround",
       "support": "partial"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "full"
      },
      "raw": {
       "description": "Indicates if an action takes a 'raw' or 'free form' string as an option and has it's own special parsing of it",
       "support": "full"
      }
     },
     "author": [
      "Ansible Core Team",
      "Michael DeHaan"
     ],
     "collection": "ansible.builtin",
     "description": [
      "The M(ansible.builtin.shell) module takes the command name followed by a list of space-delimited arguments.",
      "Either a free form command or O(cmd) parameter is required, see the examples.",
      "It is almost exactly like the M(ansible.builtin.command) module but runs the command through a shell (C(/bin/sh)) on the remote node.",
      "For Windows targets, use the M(ansible.windows.win_shell) module instead."
     ],
     "filename": "/ansible/modules/shell.py",
     "has_action": true,
     "module": "shell",
     "notes": [
      "If you want to execute a command securely and predictably, it may be better to use the M(ansible.builtin.command) module instead. Best practices when writing playbooks will follow the trend of using M(ansible.builtin.command) unless the M(ansible.builtin.shell) module is explicitly required. When running ad-hoc commands, use your best judgement.",
      "To sanitize any variables passed to the shell module, you should use C({{ var | quote }}) instead of just C({{ var }}) to make sure they do not include evil things like semicolons.",
      "An alternative to using inline shell scripts with this module is to use the M(ansible.builtin.script) module possibly together with the M(ansible.builtin.template) module.",
      "For rebooting systems, use the M(ansible.builtin.reboot) or M(ansible.windows.win_reboot) module.",
      "If the command returns non UTF-8 data, it must be encoded to avoid issues. One option is to pipe the output through C(base64)."
     ],
     "options": {
      "chdir": {
       "description": [
        "Change into this directory before running the command."
       ],
       "type": "path",
       "version_added": "0.6",
       "version_added_collection": "ansible.builtin"
      },
      "cmd": {
       "description": [
        "The command to run followed by optional arguments."
       ],
       "type": "str"
      },
      "creates": {
       "description": [
        "A filename, when it already exists, this step will B(not) be run."
       ],
       "type": "path"
      },
      "executable": {
       "description": [
        "Change the shell used to execute the command.",
        "This expects an absolute path to the executable."
       ],
       "type": "path",
       "version_added": "0.9",
       "version_added_collection": "ansible.builtin"
      },
      "free_form": {
       "description": [
        "The shell module takes a free form command to run, as a string.",
        "There is no actual parameter named 'free form'.",
        "See the examples on how to use this module."
       ],
       "type": "str"
      },
      "removes": {
       "description": [
        "A filename, when it does not exist, this step will B(not) be run."
       ],
       "type": "path",
       "version_added": "0.8",
       "version_added_collection": "ansible.builtin"
      },
      "stdin": {
       "description": [
        "Set the stdin of the command directly to the specified value."
       ],
       "type": "str",
       "version_added": "2.4",
       "version_added_collection": "ansible.builtin"
      },
      "stdin_add_newline": {
       "default": true,
       "description": [
        "Whether to append a newline to stdin data."
       ],
       "type": "bool",
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      }
     },
     "seealso": [
      {
       "module": "ansible.builtin.command"
      },
      {
       "module": "ansible.builtin.raw"
      },
      {
       "module": "ansible.builtin.script"
      },
      {
       "module": "ansible.windows.win_shell"
      }
     ],
     "short_description": "Execute shell commands on targets",
     "version_added": "0.2",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Execute the command in remote shell; stdout goes to the specified file on the remote\n  ansible.builtin.shell: somescript.sh >> somelog.txt\n\n- name: Change the working directory to somedir/ before executing the command\n  ansible.builtin.shell: somescript.sh >> somelog.txt\n  args:\n    chdir: somedir/\n\n# You can also use the 'args' form to provide the options.\n- name: This command will change the working directory to somedir/ and will only run when somedir/somelog.txt doesn't exist\n  ansible.builtin.shell: somescript.sh >> somelog.txt\n  args:\n    chdir: somedir/\n    creates: somelog.txt\n\n# You can also use the 'cmd' parameter instead of free form format.\n- name: This command will change the working directory to somedir/\n  ansible.builtin.shell:\n    cmd: ls -l | grep log\n    chdir: somedir/\n\n- name: Run a command that uses non-posix shell-isms (in this example /bin/sh doesn't handle redirection and wildcards together but bash does)\n  ansible.builtin.shell: cat < /tmp/*txt\n  args:\n    executable: /bin/bash\n\n- name: Run a command using a templated variable (always use quote filter to avoid injection)\n  ansible.builtin.shell: cat {{ myfile|quote }}\n\n# You can use shell to run other executables to perform actions inline\n- name: Run expect to wait for a successful PXE boot via out-of-band CIMC\n  ansible.builtin.shell: |\n    set timeout 300\n    spawn ssh admin@{{ cimc_host }}\n\n    expect \"password:\"\n    send \"{{ cimc_password }}\\n\"\n\n    expect \"\\n{{ cimc_name }}\"\n    send \"connect host\\n\"\n\n    expect \"pxeboot.n12\"\n    send \"\\n\"\n\n    exit 0\n  args:\n    executable: /usr/bin/expect\n  delegate_to: localhost\n",
    "metadata": null,
    "return": {
     "cmd": {
      "description": "The command executed by the task.",
      "returned": "always",
      "sample": "rabbitmqctl join_cluster rabbit@master",
      "type": "str"
     },
     "delta": {
      "description": "The command execution delta time.",
      "returned": "always",
      "sample": "0:00:00.325771",
      "type": "str"
     },
     "end": {
      "description": "The command execution end time.",
      "returned": "always",
      "sample": "2016-02-25 09:18:26.755339",
      "type": "str"
     },
     "msg": {
      "description": "changed",
      "returned": "always",
      "sample": true,
      "type": "bool"
     },
     "rc": {
      "description": "The command return code (0 means success).",
      "returned": "always",
      "sample": 0,
      "type": "int"
     },
     "start": {
      "description": "The command execution start time.",
      "returned": "always",
      "sample": "2016-02-25 09:18:26.429568",
      "type": "str"
     },
     "stderr": {
      "description": "The command standard error.",
      "returned": "always",
      "sample": "ls: cannot access foo: No such file or directory",
      "type": "str"
     },
     "stderr_lines": {
      "description": "The command standard error split in lines.",
      "returned": "always",
      "sample": [
       {
        "u'ls cannot access foo": "No such file or directory'"
       },
       "u'ls \u2026'"
      ],
      "type": "list"
     },
     "stdout": {
      "description": "The command standard output.",
      "returned": "always",
      "sample": "Clustering node rabbit@slave1 with rabbit@master \u2026",
      "type": "str"
     },
     "stdout_lines": {
      "description": "The command standard output split in lines.",
      "returned": "always",
      "sample": [
       "u'Clustering node rabbit@slave1 with rabbit@master \u2026'"
      ],
      "type": "list"
     }
    }
   },
   "ansible.builtin.slurp": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix, windows",
       "support": "N/A"
      }
     },
     "author": [
      "Ansible Core Team",
      "Michael DeHaan (@mpdehaan)"
     ],
     "collection": "ansible.builtin",
     "description": [
      "This module works like M(ansible.builtin.fetch). It is used for fetching a base64- encoded blob containing the data in a remote file.",
      "This module is also supported for Windows targets."
     ],
     "filename": "/ansible/modules/slurp.py",
     "has_action": false,
     "module": "slurp",
     "notes": [
      "This module returns an 'in memory' base64 encoded version of the file, take into account that this will require at least twice the RAM as the original file size."
     ],
     "options": {
      "src": {
       "aliases": [
        "path"
       ],
       "description": [
        "The file on the remote system to fetch. This I(must) be a file, not a directory."
       ],
       "required": true,
       "type": "path"
      }
     },
     "seealso": [
      {
       "module": "ansible.builtin.fetch"
      }
     ],
     "short_description": "Slurps a file from remote nodes",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Find out what the remote machine's mounts are\n  ansible.builtin.slurp:\n    src: /proc/mounts\n  register: mounts\n\n- name: Print returned information\n  ansible.builtin.debug:\n    msg: \"{{ mounts['content'] | b64decode }}\"\n\n# From the commandline, find the pid of the remote machine's sshd\n# $ ansible host -m ansible.builtin.slurp -a 'src=/var/run/sshd.pid'\n# host | SUCCESS => {\n#     \"changed\": false,\n#     \"content\": \"MjE3OQo=\",\n#     \"encoding\": \"base64\",\n#     \"source\": \"/var/run/sshd.pid\"\n# }\n# $ echo MjE3OQo= | base64 -d\n# 2179\n",
    "metadata": null,
    "return": {
     "content": {
      "description": "Encoded file content",
      "returned": "success",
      "sample": "MjE3OQo=",
      "type": "str"
     },
     "encoding": {
      "description": "Type of encoding used for file",
      "returned": "success",
      "sample": "base64",
      "type": "str"
     },
     "source": {
      "description": "Actual path of file slurped",
      "returned": "success",
      "sample": "/var/run/sshd.pid",
      "type": "str"
     }
    }
   },
   "ansible.builtin.stat": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "N/A"
      }
     },
     "author": "Bruce Pennypacker (@bpennypacker)",
     "collection": "ansible.builtin",
     "description": [
      "Retrieves facts for a file similar to the Linux/Unix 'stat' command.",
      "For Windows targets, use the M(ansible.windows.win_stat) module instead."
     ],
     "filename": "/ansible/modules/stat.py",
     "has_action": false,
     "module": "stat",
     "options": {
      "checksum_algorithm": {
       "aliases": [
        "checksum",
        "checksum_algo"
       ],
       "choices": [
        "md5",
        "sha1",
        "sha224",
        "sha256",
        "sha384",
        "sha512"
       ],
       "default": "sha1",
       "description": [
        "Algorithm to determine checksum of file.",
        "Will throw an error if the host is unable to use specified algorithm.",
        "The remote host has to support the hashing method specified, V(md5) can be unavailable if the host is FIPS-140 compliant."
       ],
       "type": "str",
       "version_added": "2.0",
       "version_added_collection": "ansible.builtin"
      },
      "follow": {
       "default": false,
       "description": [
        "Whether to follow symlinks."
       ],
       "type": "bool"
      },
      "get_attributes": {
       "aliases": [
        "attr",
        "attributes"
       ],
       "default": true,
       "description": [
        "Get file attributes using lsattr tool if present."
       ],
       "type": "bool",
       "version_added": "2.3",
       "version_added_collection": "ansible.builtin"
      },
      "get_checksum": {
       "default": true,
       "description": [
        "Whether to return a checksum of the file."
       ],
       "type": "bool",
       "version_added": "1.8",
       "version_added_collection": "ansible.builtin"
      },
      "get_mime": {
       "aliases": [
        "mime",
        "mime_type",
        "mime-type"
       ],
       "default": true,
       "description": [
        "Use file magic and return data about the nature of the file. this uses the 'file' utility found on most Linux/Unix systems.",
        "This will add both RV(stat.mimetype) and RV(stat.charset) fields to the return, if possible.",
        "In Ansible 2.3 this option changed from O(mime) to O(get_mime) and the default changed to V(true)."
       ],
       "type": "bool",
       "version_added": "2.1",
       "version_added_collection": "ansible.builtin"
      },
      "path": {
       "aliases": [
        "dest",
        "name"
       ],
       "description": [
        "The full path of the file/object to get the facts of."
       ],
       "required": true,
       "type": "path"
      }
     },
     "seealso": [
      {
       "module": "ansible.builtin.file"
      },
      {
       "module": "ansible.windows.win_stat"
      }
     ],
     "short_description": "Retrieve file or file system status",
     "version_added": "1.3",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n# Obtain the stats of /etc/foo.conf, and check that the file still belongs\n# to 'root'. Fail otherwise.\n- name: Get stats of a file\n  ansible.builtin.stat:\n    path: /etc/foo.conf\n  register: st\n- name: Fail if the file does not belong to 'root'\n  ansible.builtin.fail:\n    msg: \"Whoops! file ownership has changed\"\n  when: st.stat.pw_name != 'root'\n\n# Determine if a path exists and is a symlink. Note that if the path does\n# not exist, and we test sym.stat.islnk, it will fail with an error. So\n# therefore, we must test whether it is defined.\n# Run this to understand the structure, the skipped ones do not pass the\n# check performed by 'when'\n- name: Get stats of the FS object\n  ansible.builtin.stat:\n    path: /path/to/something\n  register: sym\n\n- name: Print a debug message\n  ansible.builtin.debug:\n    msg: \"islnk isn't defined (path doesn't exist)\"\n  when: sym.stat.islnk is not defined\n\n- name: Print a debug message\n  ansible.builtin.debug:\n    msg: \"islnk is defined (path must exist)\"\n  when: sym.stat.islnk is defined\n\n- name: Print a debug message\n  ansible.builtin.debug:\n    msg: \"Path exists and is a symlink\"\n  when: sym.stat.islnk is defined and sym.stat.islnk\n\n- name: Print a debug message\n  ansible.builtin.debug:\n    msg: \"Path exists and isn't a symlink\"\n  when: sym.stat.islnk is defined and sym.stat.islnk == False\n\n\n# Determine if a path exists and is a directory.  Note that we need to test\n# both that p.stat.isdir actually exists, and also that it's set to true.\n- name: Get stats of the FS object\n  ansible.builtin.stat:\n    path: /path/to/something\n  register: p\n- name: Print a debug message\n  ansible.builtin.debug:\n    msg: \"Path exists and is a directory\"\n  when: p.stat.isdir is defined and p.stat.isdir\n\n- name: Do not calculate the checksum\n  ansible.builtin.stat:\n    path: /path/to/myhugefile\n    get_checksum: no\n\n- name: Use sha256 to calculate the checksum\n  ansible.builtin.stat:\n    path: /path/to/something\n    checksum_algorithm: sha256\n",
    "metadata": null,
    "return": {
     "stat": {
      "contains": {
       "atime": {
        "description": "Time of last access",
        "returned": "success, path exists and user can read stats",
        "sample": 1424348972.575,
        "type": "float"
       },
       "attributes": {
        "description": "list of file attributes",
        "returned": "success, path exists and user can execute the path",
        "sample": [
         "immutable",
         "extent"
        ],
        "type": "list",
        "version_added": 2.3,
        "version_added_collection": "ansible.builtin"
       },
       "charset": {
        "description": "file character set or encoding",
        "returned": "success, path exists and user can read stats and installed python supports it and the O(get_mime) option was V(true), will return V(unknown) on error.",
        "sample": "us-ascii",
        "type": "str"
       },
       "checksum": {
        "description": "hash of the file",
        "returned": "success, path exists, user can read stats, path supports hashing and supplied checksum algorithm is available",
        "sample": "50ba294cdf28c0d5bcde25708df53346825a429f",
        "type": "str"
       },
       "ctime": {
        "description": "Time of last metadata update or creation (depends on OS)",
        "returned": "success, path exists and user can read stats",
        "sample": 1424348972.575,
        "type": "float"
       },
       "dev": {
        "description": "Device the inode resides on",
        "returned": "success, path exists and user can read stats",
        "sample": 33,
        "type": "int"
       },
       "executable": {
        "description": "Tells you if the invoking user has execute permission on the path",
        "returned": "success, path exists and user can execute the path",
        "sample": false,
        "type": "bool",
        "version_added": 2.2,
        "version_added_collection": "ansible.builtin"
       },
       "exists": {
        "description": "If the destination path actually exists or not",
        "returned": "success",
        "sample": true,
        "type": "bool"
       },
       "gid": {
        "description": "Numeric id representing the group of the owner",
        "returned": "success, path exists and user can read stats",
        "sample": 1003,
        "type": "int"
       },
       "gr_name": {
        "description": "Group name of owner",
        "returned": "success, path exists, user can read stats, owner group can be looked up and installed python supports it",
        "sample": "www-data",
        "type": "str"
       },
       "inode": {
        "description": "Inode number of the path",
        "returned": "success, path exists and user can read stats",
        "sample": 12758,
        "type": "int"
       },
       "isblk": {
        "description": "Tells you if the path is a block device",
        "returned": "success, path exists and user can read stats",
        "sample": false,
        "type": "bool"
       },
       "ischr": {
        "description": "Tells you if the path is a character device",
        "returned": "success, path exists and user can read stats",
        "sample": false,
        "type": "bool"
       },
       "isdir": {
        "description": "Tells you if the path is a directory",
        "returned": "success, path exists and user can read stats",
        "sample": false,
        "type": "bool"
       },
       "isfifo": {
        "description": "Tells you if the path is a named pipe",
        "returned": "success, path exists and user can read stats",
        "sample": false,
        "type": "bool"
       },
       "isgid": {
        "description": "Tells you if the invoking user's group id matches the owner's group id",
        "returned": "success, path exists and user can read stats",
        "sample": false,
        "type": "bool"
       },
       "islnk": {
        "description": "Tells you if the path is a symbolic link",
        "returned": "success, path exists and user can read stats",
        "sample": false,
        "type": "bool"
       },
       "isreg": {
        "description": "Tells you if the path is a regular file",
        "returned": "success, path exists and user can read stats",
        "sample": true,
        "type": "bool"
       },
       "issock": {
        "description": "Tells you if the path is a unix domain socket",
        "returned": "success, path exists and user can read stats",
        "sample": false,
        "type": "bool"
       },
       "isuid": {
        "description": "Tells you if the invoking user's id matches the owner's id",
        "returned": "success, path exists and user can read stats",
        "sample": false,
        "type": "bool"
       },
       "lnk_source": {
        "description": "Target of the symlink normalized for the remote filesystem",
        "returned": "success, path exists and user can read stats and the path is a symbolic link",
        "sample": "/home/foobar/21102015-1445431274-908472971",
        "type": "str"
       },
       "lnk_target": {
        "description": "Target of the symlink.  Note that relative paths remain relative",
        "returned": "success, path exists and user can read stats and the path is a symbolic link",
        "sample": "../foobar/21102015-1445431274-908472971",
        "type": "str",
        "version_added": 2.4,
        "version_added_collection": "ansible.builtin"
       },
       "mimetype": {
        "description": "file magic data or mime-type",
        "returned": "success, path exists and user can read stats and installed python supports it and the O(get_mime) option was V(true), will return V(unknown) on error.",
        "sample": "application/pdf; charset=binary",
        "type": "str"
       },
       "mode": {
        "description": "Unix permissions of the file in octal representation as a string",
        "returned": "success, path exists and user can read stats",
        "sample": 1755,
        "type": "str"
       },
       "mtime": {
        "description": "Time of last modification",
        "returned": "success, path exists and user can read stats",
        "sample": 1424348972.575,
        "type": "float"
       },
       "nlink": {
        "description": "Number of links to the inode (hard links)",
        "returned": "success, path exists and user can read stats",
        "sample": 1,
        "type": "int"
       },
       "path": {
        "description": "The full path of the file/object to get the facts of",
        "returned": "success and if path exists",
        "sample": "/path/to/file",
        "type": "str"
       },
       "pw_name": {
        "description": "User name of owner",
        "returned": "success, path exists, user can read stats, owner name can be looked up and installed python supports it",
        "sample": "httpd",
        "type": "str"
       },
       "readable": {
        "description": "Tells you if the invoking user has the right to read the path",
        "returned": "success, path exists and user can read the path",
        "sample": false,
        "type": "bool",
        "version_added": 2.2,
        "version_added_collection": "ansible.builtin"
       },
       "rgrp": {
        "description": "Tells you if the owner's group has read permission",
        "returned": "success, path exists and user can read stats",
        "sample": true,
        "type": "bool"
       },
       "roth": {
        "description": "Tells you if others have read permission",
        "returned": "success, path exists and user can read stats",
        "sample": true,
        "type": "bool"
       },
       "rusr": {
        "description": "Tells you if the owner has read permission",
        "returned": "success, path exists and user can read stats",
        "sample": true,
        "type": "bool"
       },
       "size": {
        "description": "Size in bytes for a plain file, amount of data for some special files",
        "returned": "success, path exists and user can read stats",
        "sample": 203,
        "type": "int"
       },
       "uid": {
        "description": "Numeric id representing the file owner",
        "returned": "success, path exists and user can read stats",
        "sample": 1003,
        "type": "int"
       },
       "version": {
        "description": "The version/generation attribute of a file according to the filesystem",
        "returned": "success, path exists, user can execute the path, lsattr is available and filesystem supports",
        "sample": "381700746",
        "type": "str",
        "version_added": 2.3,
        "version_added_collection": "ansible.builtin"
       },
       "wgrp": {
        "description": "Tells you if the owner's group has write permission",
        "returned": "success, path exists and user can read stats",
        "sample": false,
        "type": "bool"
       },
       "woth": {
        "description": "Tells you if others have write permission",
        "returned": "success, path exists and user can read stats",
        "sample": false,
        "type": "bool"
       },
       "writeable": {
        "description": "Tells you if the invoking user has the right to write the path",
        "returned": "success, path exists and user can write the path",
        "sample": false,
        "type": "bool",
        "version_added": 2.2,
        "version_added_collection": "ansible.builtin"
       },
       "wusr": {
        "description": "Tells you if the owner has write permission",
        "returned": "success, path exists and user can read stats",
        "sample": true,
        "type": "bool"
       },
       "xgrp": {
        "description": "Tells you if the owner's group has execute permission",
        "returned": "success, path exists and user can read stats",
        "sample": true,
        "type": "bool"
       },
       "xoth": {
        "description": "Tells you if others have execute permission",
        "returned": "success, path exists and user can read stats",
        "sample": true,
        "type": "bool"
       },
       "xusr": {
        "description": "Tells you if the owner has execute permission",
        "returned": "success, path exists and user can read stats",
        "sample": true,
        "type": "bool"
       }
      },
      "description": "Dictionary containing all the stat data, some platforms might add additional fields.",
      "returned": "success",
      "type": "dict"
     }
    }
   },
   "ansible.builtin.subversion": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "N/A"
      }
     },
     "author": [
      "Dane Summers (@dsummersl) <njharman@gmail.com>"
     ],
     "collection": "ansible.builtin",
     "description": [
      "Deploy given repository URL / revision to dest. If dest exists, update to the specified revision, otherwise perform a checkout."
     ],
     "filename": "/ansible/modules/subversion.py",
     "has_action": false,
     "module": "subversion",
     "notes": [
      "This module does not handle externals."
     ],
     "options": {
      "checkout": {
       "default": "yes",
       "description": [
        "If V(false), do not check out the repository if it does not exist locally."
       ],
       "type": "bool",
       "version_added": "2.3",
       "version_added_collection": "ansible.builtin"
      },
      "dest": {
       "description": [
        "Absolute path where the repository should be deployed.",
        "The destination directory must be specified unless O(checkout=no), O(update=no), and O(export=no)."
       ],
       "type": "path"
      },
      "executable": {
       "description": [
        "Path to svn executable to use. If not supplied, the normal mechanism for resolving binary paths will be used."
       ],
       "type": "path",
       "version_added": "1.4",
       "version_added_collection": "ansible.builtin"
      },
      "export": {
       "default": "no",
       "description": [
        "If V(true), do export instead of checkout/update."
       ],
       "type": "bool",
       "version_added": "1.6",
       "version_added_collection": "ansible.builtin"
      },
      "force": {
       "default": "no",
       "description": [
        "If V(true), modified files will be discarded. If V(false), module will fail if it encounters modified files. Prior to 1.9 the default was V(true)."
       ],
       "type": "bool"
      },
      "in_place": {
       "default": "no",
       "description": [
        "If the directory exists, then the working copy will be checked-out over-the-top using svn checkout --force; if force is specified then existing files with different content are reverted."
       ],
       "type": "bool",
       "version_added": "2.6",
       "version_added_collection": "ansible.builtin"
      },
      "password": {
       "description": [
        "C(--password) parameter passed to svn when svn is less than version 1.10.0. This is not secure and the password will be leaked to argv.",
        "C(--password-from-stdin) parameter when svn is greater or equal to version 1.10.0."
       ],
       "type": "str"
      },
      "repo": {
       "aliases": [
        "name",
        "repository"
       ],
       "description": [
        "The subversion URL to the repository."
       ],
       "required": true,
       "type": "str"
      },
      "revision": {
       "aliases": [
        "rev",
        "version"
       ],
       "default": "HEAD",
       "description": [
        "Specific revision to checkout."
       ],
       "type": "str"
      },
      "switch": {
       "default": "yes",
       "description": [
        "If V(false), do not call svn switch before update."
       ],
       "type": "bool",
       "version_added": "2.0",
       "version_added_collection": "ansible.builtin"
      },
      "update": {
       "default": "yes",
       "description": [
        "If V(false), do not retrieve new revisions from the origin repository."
       ],
       "type": "bool",
       "version_added": "2.3",
       "version_added_collection": "ansible.builtin"
      },
      "username": {
       "description": [
        "C(--username) parameter passed to svn."
       ],
       "type": "str"
      },
      "validate_certs": {
       "default": "no",
       "description": [
        "If V(false), passes the C(--trust-server-cert) flag to svn.",
        "If V(true), does not pass the flag."
       ],
       "type": "bool",
       "version_added": "2.11",
       "version_added_collection": "ansible.builtin"
      }
     },
     "requirements": [
      "subversion (the command line tool with C(svn) entrypoint)"
     ],
     "short_description": "Deploys a subversion repository",
     "version_added": "0.7",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Checkout subversion repository to specified folder\n  ansible.builtin.subversion:\n    repo: svn+ssh://an.example.org/path/to/repo\n    dest: /src/checkout\n\n- name: Export subversion directory to folder\n  ansible.builtin.subversion:\n    repo: svn+ssh://an.example.org/path/to/repo\n    dest: /src/export\n    export: yes\n\n- name: Get information about the repository whether or not it has already been cloned locally\n  ansible.builtin.subversion:\n    repo: svn+ssh://an.example.org/path/to/repo\n    dest: /src/checkout\n    checkout: no\n    update: no\n",
    "metadata": null,
    "return": null
   },
   "ansible.builtin.systemd_service": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "N/A"
      }
     },
     "author": [
      "Ansible Core Team"
     ],
     "collection": "ansible.builtin",
     "description": [
      "Controls systemd units (services, timers, and so on) on remote hosts.",
      "M(ansible.builtin.systemd) is renamed to M(ansible.builtin.systemd_service) to better reflect the scope of the module. M(ansible.builtin.systemd) is kept as an alias for backward compatibility."
     ],
     "filename": "/ansible/modules/systemd_service.py",
     "has_action": false,
     "module": "systemd_service",
     "notes": [
      "Since 2.4, one of the following options is required O(state), O(enabled), O(masked), O(daemon_reload), (O(daemon_reexec) since 2.8), and all except O(daemon_reload) and (O(daemon_reexec) since 2.8) also require O(name).",
      "Before 2.4 you always required O(name).",
      "Globs are not supported in name, in other words, C(postgres*.service).",
      "The service names might vary by specific OS/distribution",
      "The order of execution when having multiple properties is to first enable/disable, then mask/unmask and then deal with the service state. It has been reported that systemctl can behave differently depending on the order of operations if you do the same manually."
     ],
     "options": {
      "daemon_reexec": {
       "aliases": [
        "daemon-reexec"
       ],
       "default": false,
       "description": [
        "Run daemon_reexec command before doing any other operations, the systemd manager will serialize the manager state."
       ],
       "type": "bool",
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      },
      "daemon_reload": {
       "aliases": [
        "daemon-reload"
       ],
       "default": false,
       "description": [
        "Run daemon-reload before doing any other operations, to make sure systemd has read any changes.",
        "When set to V(true), runs daemon-reload even if the module does not start or stop anything."
       ],
       "type": "bool"
      },
      "enabled": {
       "description": [
        "Whether the unit should start on boot. B(At least one of the states and enabled are required.)"
       ],
       "type": "bool"
      },
      "force": {
       "description": [
        "Whether to override existing symlinks."
       ],
       "type": "bool",
       "version_added": 2.6,
       "version_added_collection": "ansible.builtin"
      },
      "masked": {
       "description": [
        "Whether the unit should be masked or not, a masked unit is impossible to start."
       ],
       "type": "bool"
      },
      "name": {
       "aliases": [
        "service",
        "unit"
       ],
       "description": [
        "Name of the unit. This parameter takes the name of exactly one unit to work with.",
        "When no extension is given, it is implied to a C(.service) as systemd.",
        "When using in a chroot environment you always need to specify the name of the unit with the extension. For example, C(crond.service)."
       ],
       "type": "str"
      },
      "no_block": {
       "default": false,
       "description": [
        "Do not synchronously wait for the requested operation to finish. Enqueued job will continue without Ansible blocking on its completion."
       ],
       "type": "bool",
       "version_added": "2.3",
       "version_added_collection": "ansible.builtin"
      },
      "scope": {
       "choices": [
        "system",
        "user",
        "global"
       ],
       "default": "system",
       "description": [
        "Run systemctl within a given service manager scope, either as the default system scope V(system), the current user's scope V(user), or the scope of all users V(global).",
        "For systemd to work with 'user', the executing user must have its own instance of dbus started and accessible (systemd requirement).",
        "The user dbus process is normally started during normal login, but not during the run of Ansible tasks. Otherwise you will probably get a 'Failed to connect to bus: no such file or directory' error.",
        "The user must have access, normally given via setting the C(XDG_RUNTIME_DIR) variable, see the example below."
       ],
       "type": "str",
       "version_added": "2.7",
       "version_added_collection": "ansible.builtin"
      },
      "state": {
       "choices": [
        "reloaded",
        "restarted",
        "started",
        "stopped"
       ],
       "description": [
        "V(started)/V(stopped) are idempotent actions that will not run commands unless necessary. V(restarted) will always bounce the unit. V(reloaded) will always reload and if the service is not running at the moment of the reload, it is started."
       ],
       "type": "str"
      }
     },
     "requirements": [
      "A system managed by systemd."
     ],
     "short_description": "Manage systemd units",
     "version_added": "2.2",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Make sure a service unit is running\n  ansible.builtin.systemd_service:\n    state: started\n    name: httpd\n\n- name: Stop service cron on debian, if running\n  ansible.builtin.systemd_service:\n    name: cron\n    state: stopped\n\n- name: Restart service cron on centos, in all cases, also issue daemon-reload to pick up config changes\n  ansible.builtin.systemd_service:\n    state: restarted\n    daemon_reload: true\n    name: crond\n\n- name: Reload service httpd, in all cases\n  ansible.builtin.systemd_service:\n    name: httpd.service\n    state: reloaded\n\n- name: Enable service httpd and ensure it is not masked\n  ansible.builtin.systemd_service:\n    name: httpd\n    enabled: true\n    masked: no\n\n- name: Enable a timer unit for dnf-automatic\n  ansible.builtin.systemd_service:\n    name: dnf-automatic.timer\n    state: started\n    enabled: true\n\n- name: Just force systemd to reread configs (2.4 and above)\n  ansible.builtin.systemd_service:\n    daemon_reload: true\n\n- name: Just force systemd to re-execute itself (2.8 and above)\n  ansible.builtin.systemd_service:\n    daemon_reexec: true\n\n- name: Run a user service when XDG_RUNTIME_DIR is not set on remote login\n  ansible.builtin.systemd_service:\n    name: myservice\n    state: started\n    scope: user\n  environment:\n    XDG_RUNTIME_DIR: \"/run/user/{{ myuid }}\"\n",
    "metadata": null,
    "return": {
     "status": {
      "description": "A dictionary with the key=value pairs returned from C(systemctl show).",
      "returned": "success",
      "sample": {
       "ActiveEnterTimestamp": "Sun 2016-05-15 18:28:49 EDT",
       "ActiveEnterTimestampMonotonic": "8135942",
       "ActiveExitTimestampMonotonic": "0",
       "ActiveState": "active",
       "After": "auditd.service systemd-user-sessions.service time-sync.target systemd-journald.socket basic.target system.slice",
       "AllowIsolate": "no",
       "Before": "shutdown.target multi-user.target",
       "BlockIOAccounting": "no",
       "BlockIOWeight": "1000",
       "CPUAccounting": "no",
       "CPUSchedulingPolicy": "0",
       "CPUSchedulingPriority": "0",
       "CPUSchedulingResetOnFork": "no",
       "CPUShares": "1024",
       "CanIsolate": "no",
       "CanReload": "yes",
       "CanStart": "yes",
       "CanStop": "yes",
       "CapabilityBoundingSet": "18446744073709551615",
       "ConditionResult": "yes",
       "ConditionTimestamp": "Sun 2016-05-15 18:28:49 EDT",
       "ConditionTimestampMonotonic": "7902742",
       "Conflicts": "shutdown.target",
       "ControlGroup": "/system.slice/crond.service",
       "ControlPID": "0",
       "DefaultDependencies": "yes",
       "Delegate": "no",
       "Description": "Command Scheduler",
       "DevicePolicy": "auto",
       "EnvironmentFile": "/etc/sysconfig/crond (ignore_errors=no)",
       "ExecMainCode": "0",
       "ExecMainExitTimestampMonotonic": "0",
       "ExecMainPID": "595",
       "ExecMainStartTimestamp": "Sun 2016-05-15 18:28:49 EDT",
       "ExecMainStartTimestampMonotonic": "8134990",
       "ExecMainStatus": "0",
       "ExecReload": "{ path=/bin/kill ; argv[]=/bin/kill -HUP $MAINPID ; ignore_errors=no ; start_time=[n/a] ; stop_time=[n/a] ; pid=0 ; code=(null) ; status=0/0 }",
       "ExecStart": "{ path=/usr/sbin/crond ; argv[]=/usr/sbin/crond -n $CRONDARGS ; ignore_errors=no ; start_time=[n/a] ; stop_time=[n/a] ; pid=0 ; code=(null) ; status=0/0 }",
       "FragmentPath": "/usr/lib/systemd/system/crond.service",
       "GuessMainPID": "yes",
       "IOScheduling": "0",
       "Id": "crond.service",
       "IgnoreOnIsolate": "no",
       "IgnoreOnSnapshot": "no",
       "IgnoreSIGPIPE": "yes",
       "InactiveEnterTimestampMonotonic": "0",
       "InactiveExitTimestamp": "Sun 2016-05-15 18:28:49 EDT",
       "InactiveExitTimestampMonotonic": "8135942",
       "JobTimeoutUSec": "0",
       "KillMode": "process",
       "KillSignal": "15",
       "LimitAS": "18446744073709551615",
       "LimitCORE": "18446744073709551615",
       "LimitCPU": "18446744073709551615",
       "LimitDATA": "18446744073709551615",
       "LimitFSIZE": "18446744073709551615",
       "LimitLOCKS": "18446744073709551615",
       "LimitMEMLOCK": "65536",
       "LimitMSGQUEUE": "819200",
       "LimitNICE": "0",
       "LimitNOFILE": "4096",
       "LimitNPROC": "3902",
       "LimitRSS": "18446744073709551615",
       "LimitRTPRIO": "0",
       "LimitRTTIME": "18446744073709551615",
       "LimitSIGPENDING": "3902",
       "LimitSTACK": "18446744073709551615",
       "LoadState": "loaded",
       "MainPID": "595",
       "MemoryAccounting": "no",
       "MemoryLimit": "18446744073709551615",
       "MountFlags": "0",
       "Names": "crond.service",
       "NeedDaemonReload": "no",
       "Nice": "0",
       "NoNewPrivileges": "no",
       "NonBlocking": "no",
       "NotifyAccess": "none",
       "OOMScoreAdjust": "0",
       "OnFailureIsolate": "no",
       "PermissionsStartOnly": "no",
       "PrivateNetwork": "no",
       "PrivateTmp": "no",
       "RefuseManualStart": "no",
       "RefuseManualStop": "no",
       "RemainAfterExit": "no",
       "Requires": "basic.target",
       "Restart": "no",
       "RestartUSec": "100ms",
       "Result": "success",
       "RootDirectoryStartOnly": "no",
       "SameProcessGroup": "no",
       "SecureBits": "0",
       "SendSIGHUP": "no",
       "SendSIGKILL": "yes",
       "Slice": "system.slice",
       "StandardError": "inherit",
       "StandardInput": "null",
       "StandardOutput": "journal",
       "StartLimitAction": "none",
       "StartLimitBurst": "5",
       "StartLimitInterval": "10000000",
       "StatusErrno": "0",
       "StopWhenUnneeded": "no",
       "SubState": "running",
       "SyslogLevelPrefix": "yes",
       "SyslogPriority": "30",
       "TTYReset": "no",
       "TTYVHangup": "no",
       "TTYVTDisallocate": "no",
       "TimeoutStartUSec": "1min 30s",
       "TimeoutStopUSec": "1min 30s",
       "TimerSlackNSec": "50000",
       "Transient": "no",
       "Type": "simple",
       "UMask": "0022",
       "UnitFileState": "enabled",
       "WantedBy": "multi-user.target",
       "Wants": "system.slice",
       "WatchdogTimestampMonotonic": "0",
       "WatchdogUSec": "0"
      },
      "type": "dict"
     }
    }
   },
   "ansible.builtin.sysvinit": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "N/A"
      }
     },
     "author": [
      "Ansible Core Team"
     ],
     "collection": "ansible.builtin",
     "description": [
      "Controls services on target hosts that use the SysV init system."
     ],
     "filename": "/ansible/modules/sysvinit.py",
     "has_action": false,
     "module": "sysvinit",
     "notes": [
      "One option other than name is required.",
      "The service names might vary by specific OS/distribution"
     ],
     "options": {
      "arguments": {
       "aliases": [
        "args"
       ],
       "description": [
        "Additional arguments provided on the command line that some init scripts accept."
       ],
       "type": "str"
      },
      "daemonize": {
       "default": false,
       "description": [
        "Have the module daemonize as the service itself might not do so properly.",
        "This is useful with badly written init scripts or daemons, which commonly manifests as the task hanging as it is still holding the tty or the service dying when the task is over as the connection closes the session."
       ],
       "type": "bool"
      },
      "enabled": {
       "description": [
        "Whether the service should start on boot. B(At least one of state and enabled are required.)"
       ],
       "type": "bool"
      },
      "name": {
       "aliases": [
        "service"
       ],
       "description": [
        "Name of the service."
       ],
       "required": true,
       "type": "str"
      },
      "pattern": {
       "description": [
        "A substring to look for as would be found in the output of the I(ps) command as a stand-in for a status result.",
        "If the string is found, the service will be assumed to be running.",
        "This option is mainly for use with init scripts that don't support the 'status' option."
       ],
       "type": "str"
      },
      "runlevels": {
       "description": [
        "The runlevels this script should be enabled/disabled from.",
        "Use this to override the defaults set by the package or init script itself."
       ],
       "elements": "str",
       "type": "list"
      },
      "sleep": {
       "default": 1,
       "description": [
        "If the service is being V(restarted) or V(reloaded) then sleep this many seconds between the stop and start command. This helps to workaround badly behaving services."
       ],
       "type": "int"
      },
      "state": {
       "choices": [
        "started",
        "stopped",
        "restarted",
        "reloaded"
       ],
       "description": [
        "V(started)/V(stopped) are idempotent actions that will not run commands unless necessary. Not all init scripts support V(restarted) nor V(reloaded) natively, so these will both trigger a stop and start as needed."
       ],
       "type": "str"
      }
     },
     "requirements": [
      "That the service managed has a corresponding init script."
     ],
     "short_description": "Manage SysV services.",
     "version_added": "2.6",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Make sure apache2 is started\n  ansible.builtin.sysvinit:\n      name: apache2\n      state: started\n      enabled: yes\n\n- name: Sleep for 5 seconds between stop and start command of badly behaving service\n  ansible.builtin.sysvinit:\n    name: apache2\n    state: restarted\n    sleep: 5\n\n- name: Make sure apache2 is started on runlevels 3 and 5\n  ansible.builtin.sysvinit:\n      name: apache2\n      state: started\n      enabled: yes\n      runlevels:\n        - 3\n        - 5\n",
    "metadata": null,
    "return": {
     "results": {
      "contains": {
       "name": {
        "description": "Name of the service",
        "returned": "always",
        "sample": "apache2",
        "type": "str"
       },
       "status": {
        "description": "Status of the service",
        "returned": "changed",
        "sample": {
         "enabled": {
          "changed": true,
          "rc": 0,
          "stderr": "",
          "stdout": ""
         },
         "stopped": {
          "changed": true,
          "rc": 0,
          "stderr": "",
          "stdout": "Stopping web server: apache2.\n"
         }
        },
        "type": "dict"
       }
      },
      "description": "results from actions taken",
      "returned": "always",
      "type": "complex"
     }
    }
   },
   "ansible.builtin.tempfile": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "none"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "N/A"
      }
     },
     "author": [
      "Krzysztof Magosa (@krzysztof-magosa)"
     ],
     "collection": "ansible.builtin",
     "description": [
      "The M(ansible.builtin.tempfile) module creates temporary files and directories. C(mktemp) command takes different parameters on various systems, this module helps to avoid troubles related to that. Files/directories created by module are accessible only by creator. In case you need to make them world-accessible you need to use M(ansible.builtin.file) module.",
      "For Windows targets, use the M(ansible.windows.win_tempfile) module instead."
     ],
     "filename": "/ansible/modules/tempfile.py",
     "has_action": false,
     "module": "tempfile",
     "options": {
      "path": {
       "description": [
        "Location where temporary file or directory should be created.",
        "If path is not specified, the default system temporary directory will be used."
       ],
       "type": "path"
      },
      "prefix": {
       "default": "ansible.",
       "description": [
        "Prefix of file/directory name created by module."
       ],
       "type": "str"
      },
      "state": {
       "choices": [
        "directory",
        "file"
       ],
       "default": "file",
       "description": [
        "Whether to create file or directory."
       ],
       "type": "str"
      },
      "suffix": {
       "default": "",
       "description": [
        "Suffix of file/directory name created by module."
       ],
       "type": "str"
      }
     },
     "seealso": [
      {
       "module": "ansible.builtin.file"
      },
      {
       "module": "ansible.windows.win_tempfile"
      }
     ],
     "short_description": "Creates temporary files and directories",
     "version_added": "2.3",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Create temporary build directory\n  ansible.builtin.tempfile:\n    state: directory\n    suffix: build\n\n- name: Create temporary file\n  ansible.builtin.tempfile:\n    state: file\n    suffix: temp\n  register: tempfile_1\n\n- name: Create a temporary file with a specific prefix\n  ansible.builtin.tempfile:\n     state: file\n     suffix: txt\n     prefix: myfile_\n\n- name: Use the registered var and the file module to remove the temporary file\n  ansible.builtin.file:\n    path: \"{{ tempfile_1.path }}\"\n    state: absent\n  when: tempfile_1.path is defined\n",
    "metadata": null,
    "return": {
     "path": {
      "description": "Path to created file or directory.",
      "returned": "success",
      "sample": "/tmp/ansible.bMlvdk",
      "type": "str"
     }
    }
   },
   "ansible.builtin.template": {
    "doc": {
     "attributes": {
      "action": {
       "description": "Indicates this has a corresponding action plugin so some parts of the options can be executed on the controller",
       "support": "full"
      },
      "async": {
       "description": "Supports being used with the C(async) keyword",
       "support": "none"
      },
      "bypass_host_loop": {
       "description": [
        "Forces a 'global' task that does not execute per host, this bypasses per host templating and serial, throttle and other loop considerations",
        "Conditionals will work as if C(run_once) is being used, variables used will be from the first available host",
        "This action will not work normally outside of lockstep strategies"
       ],
       "support": "none"
      },
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "full"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "N/A"
      },
      "safe_file_operations": {
       "description": "Uses Ansible's strict file operation functions to ensure proper permissions and avoid data corruption",
       "support": "full"
      },
      "vault": {
       "description": "Can automatically decrypt Ansible vaulted files",
       "support": "full"
      }
     },
     "author": [
      "Ansible Core Team",
      "Michael DeHaan"
     ],
     "collection": "ansible.builtin",
     "description": [
      "Templates are processed by the L(Jinja2 templating language,http://jinja.pocoo.org/docs/).",
      "Documentation on the template formatting can be found in the L(Template Designer Documentation,http://jinja.pocoo.org/docs/templates/).",
      "Additional variables listed below can be used in templates.",
      "C(ansible_managed) (configurable via the C(defaults) section of C(ansible.cfg)) contains a string which can be used to describe the template name, host, modification time of the template file and the owner uid.",
      "C(template_host) contains the node name of the template's machine.",
      "C(template_uid) is the numeric user id of the owner.",
      "C(template_path) is the path of the template.",
      "C(template_fullpath) is the absolute path of the template.",
      "C(template_destpath) is the path of the template on the remote system (added in 2.8).",
      "C(template_run_date) is the date that the template was rendered."
     ],
     "filename": "/ansible/modules/template.py",
     "has_action": true,
     "module": "template",
     "notes": [
      "For Windows you can use M(ansible.windows.win_template) which uses V(\\\\r\\\\n) as O(newline_sequence) by default.",
      "The C(jinja2_native) setting has no effect. Native types are never used in the M(ansible.builtin.template) module which is by design used for generating text files. For working with templates and utilizing Jinja2 native types see the O(ansible.builtin.template#lookup:jinja2_native) parameter of the P(ansible.builtin.template#lookup) lookup.",
      "Including a string that uses a date in the template will result in the template being marked 'changed' each time.",
      "Since Ansible 0.9, templates are loaded with O(trim_blocks=True).",
      "Also, you can override jinja2 settings by adding a special header to template file. that is C(#jinja2:variable_start_string:'[%', variable_end_string:'%]', trim_blocks: False) which changes the variable interpolation markers to C([% var %]) instead of C({{ var }}). This is the best way to prevent evaluation of things that look like, but should not be Jinja2.\n",
      "To find Byte Order Marks in files, use C(Format-Hex <file> -Count 16) on Windows, and use C(od -a -t x1 -N 16 <file>) on Linux."
     ],
     "options": {
      "attributes": {
       "aliases": [
        "attr"
       ],
       "description": [
        "The attributes the resulting filesystem object should have.",
        "To get supported flags look at the man page for I(chattr) on the target system.",
        "This string should contain the attributes in the same order as the one displayed by I(lsattr).",
        "The C(=) operator is assumed as default, otherwise C(+) or C(-) operators need to be included in the string."
       ],
       "type": "str",
       "version_added": "2.3",
       "version_added_collection": "ansible.builtin"
      },
      "backup": {
       "default": false,
       "description": [
        "Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly."
       ],
       "type": "bool"
      },
      "block_end_string": {
       "default": "%}",
       "description": [
        "The string marking the end of a block."
       ],
       "type": "str",
       "version_added": "2.4",
       "version_added_collection": "ansible.builtin"
      },
      "block_start_string": {
       "default": "{%",
       "description": [
        "The string marking the beginning of a block."
       ],
       "type": "str",
       "version_added": "2.4",
       "version_added_collection": "ansible.builtin"
      },
      "comment_end_string": {
       "description": [
        "The string marking the end of a comment statement."
       ],
       "type": "str",
       "version_added": "2.12",
       "version_added_collection": "ansible.builtin"
      },
      "comment_start_string": {
       "description": [
        "The string marking the beginning of a comment statement."
       ],
       "type": "str",
       "version_added": "2.12",
       "version_added_collection": "ansible.builtin"
      },
      "dest": {
       "description": [
        "Location to render the template to on the remote machine."
       ],
       "required": true,
       "type": "path"
      },
      "follow": {
       "default": false,
       "description": [
        "Determine whether symbolic links should be followed.",
        "When set to V(true) symbolic links will be followed, if they exist.",
        "When set to V(false) symbolic links will not be followed.",
        "Previous to Ansible 2.4, this was hardcoded as V(true)."
       ],
       "type": "bool",
       "version_added": "2.4",
       "version_added_collection": "ansible.builtin"
      },
      "force": {
       "default": true,
       "description": [
        "Determine when the file is being transferred if the destination already exists.",
        "When set to C(yes), replace the remote file when contents are different than the source.",
        "When set to C(no), the file will only be transferred if the destination does not exist."
       ],
       "type": "bool"
      },
      "group": {
       "description": [
        "Name of the group that should own the filesystem object, as would be fed to I(chown).",
        "When left unspecified, it uses the current group of the current user unless you are root, in which case it can preserve the previous ownership."
       ],
       "type": "str"
      },
      "lstrip_blocks": {
       "default": false,
       "description": [
        "Determine when leading spaces and tabs should be stripped.",
        "When set to V(yes) leading spaces and tabs are stripped from the start of a line to a block."
       ],
       "type": "bool",
       "version_added": "2.6",
       "version_added_collection": "ansible.builtin"
      },
      "mode": {
       "description": [
        "The permissions the resulting filesystem object should have.",
        "For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must give Ansible enough information to parse them correctly. For consistent results, quote octal numbers (for example, V('644') or V('1777')) so Ansible receives a string and can do its own conversion from string into number. Adding a leading zero (for example, V(0755)) works sometimes, but can fail in loops and some other circumstances.",
        "Giving Ansible a number without following either of these rules will end up with a decimal number which will have unexpected results.",
        "As of Ansible 1.8, the mode may be specified as a symbolic mode (for example, V(u+rwx) or V(u=rw,g=r,o=r)).",
        "If O(mode) is not specified and the destination filesystem object B(does not) exist, the default C(umask) on the system will be used when setting the mode for the newly created filesystem object.",
        "If O(mode) is not specified and the destination filesystem object B(does) exist, the mode of the existing filesystem object will be used.",
        "Specifying O(mode) is the best way to ensure filesystem objects are created with the correct permissions. See CVE-2020-1736 for further details."
       ],
       "type": "raw"
      },
      "newline_sequence": {
       "choices": [
        "\\n",
        "\\r",
        "\\r\\n"
       ],
       "default": "\\n",
       "description": [
        "Specify the newline sequence to use for templating files."
       ],
       "type": "str",
       "version_added": "2.4",
       "version_added_collection": "ansible.builtin"
      },
      "output_encoding": {
       "default": "utf-8",
       "description": [
        "Overrides the encoding used to write the template file defined by O(dest).",
        "It defaults to C(utf-8), but any encoding supported by python can be used.",
        "The source template file must always be encoded using C(utf-8), for homogeneity."
       ],
       "type": "str",
       "version_added": "2.7",
       "version_added_collection": "ansible.builtin"
      },
      "owner": {
       "description": [
        "Name of the user that should own the filesystem object, as would be fed to I(chown).",
        "When left unspecified, it uses the current user unless you are root, in which case it can preserve the previous ownership.",
        "Specifying a numeric username will be assumed to be a user ID and not a username. Avoid numeric usernames to avoid this confusion."
       ],
       "type": "str"
      },
      "selevel": {
       "description": [
        "The level part of the SELinux filesystem object context.",
        "This is the MLS/MCS attribute, sometimes known as the C(range).",
        "When set to V(_default), it will use the C(level) portion of the policy if available."
       ],
       "type": "str"
      },
      "serole": {
       "description": [
        "The role part of the SELinux filesystem object context.",
        "When set to V(_default), it will use the C(role) portion of the policy if available."
       ],
       "type": "str"
      },
      "setype": {
       "description": [
        "The type part of the SELinux filesystem object context.",
        "When set to V(_default), it will use the C(type) portion of the policy if available."
       ],
       "type": "str"
      },
      "seuser": {
       "description": [
        "The user part of the SELinux filesystem object context.",
        "By default it uses the V(system) policy, where applicable.",
        "When set to V(_default), it will use the C(user) portion of the policy if available."
       ],
       "type": "str"
      },
      "src": {
       "description": [
        "Path of a Jinja2 formatted template on the Ansible controller.",
        "This can be a relative or an absolute path.",
        "The file must be encoded with C(utf-8) but O(output_encoding) can be used to control the encoding of the output template."
       ],
       "required": true,
       "type": "path"
      },
      "trim_blocks": {
       "default": true,
       "description": [
        "Determine when newlines should be removed from blocks.",
        "When set to V(yes) the first newline after a block is removed (block, not variable tag!)."
       ],
       "type": "bool",
       "version_added": "2.4",
       "version_added_collection": "ansible.builtin"
      },
      "unsafe_writes": {
       "default": false,
       "description": [
        "Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target filesystem object.",
        "By default this module uses atomic operations to prevent data corruption or inconsistent reads from the target filesystem objects, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted filesystem objects, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.",
        "This option allows Ansible to fall back to unsafe methods of updating filesystem objects when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes).",
        "IMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption."
       ],
       "type": "bool",
       "version_added": "2.2",
       "version_added_collection": "ansible.builtin"
      },
      "validate": {
       "description": [
        "The validation command to run before copying the updated file into the final destination.",
        "A temporary file path is used to validate, passed in through '%s' which must be present as in the examples below.",
        "Also, the command is passed securely so shell features such as expansion and pipes will not work.",
        "For an example on how to handle more complex validation than what this option provides, see R(handling complex validation,complex_configuration_validation)."
       ],
       "type": "str"
      },
      "variable_end_string": {
       "default": "}}",
       "description": [
        "The string marking the end of a print statement."
       ],
       "type": "str",
       "version_added": "2.4",
       "version_added_collection": "ansible.builtin"
      },
      "variable_start_string": {
       "default": "{{",
       "description": [
        "The string marking the beginning of a print statement."
       ],
       "type": "str",
       "version_added": "2.4",
       "version_added_collection": "ansible.builtin"
      }
     },
     "seealso": [
      {
       "module": "ansible.builtin.copy"
      },
      {
       "module": "ansible.windows.win_copy"
      },
      {
       "module": "ansible.windows.win_template"
      }
     ],
     "short_description": "Template a file out to a target host",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Template a file to /etc/file.conf\n  ansible.builtin.template:\n    src: /mytemplates/foo.j2\n    dest: /etc/file.conf\n    owner: bin\n    group: wheel\n    mode: '0644'\n\n- name: Template a file, using symbolic modes (equivalent to 0644)\n  ansible.builtin.template:\n    src: /mytemplates/foo.j2\n    dest: /etc/file.conf\n    owner: bin\n    group: wheel\n    mode: u=rw,g=r,o=r\n\n- name: Copy a version of named.conf that is dependent on the OS. setype obtained by doing ls -Z /etc/named.conf on original file\n  ansible.builtin.template:\n    src: named.conf_{{ ansible_os_family }}.j2\n    dest: /etc/named.conf\n    group: named\n    setype: named_conf_t\n    mode: '0640'\n\n- name: Create a DOS-style text file from a template\n  ansible.builtin.template:\n    src: config.ini.j2\n    dest: /share/windows/config.ini\n    newline_sequence: '\\r\\n'\n\n- name: Copy a new sudoers file into place, after passing validation with visudo\n  ansible.builtin.template:\n    src: /mine/sudoers\n    dest: /etc/sudoers\n    validate: /usr/sbin/visudo -cf %s\n\n- name: Update sshd configuration safely, avoid locking yourself out\n  ansible.builtin.template:\n    src: etc/ssh/sshd_config.j2\n    dest: /etc/ssh/sshd_config\n    owner: root\n    group: root\n    mode: '0600'\n    validate: /usr/sbin/sshd -t -f %s\n    backup: yes\n",
    "metadata": null,
    "return": {
     "checksum": {
      "description": "SHA1 checksum of the rendered file",
      "returned": "always",
      "sample": "373296322247ab85d26d5d1257772757e7afd172",
      "type": "str"
     },
     "dest": {
      "description": "Destination file/path, equal to the value passed to I(dest).",
      "returned": "success",
      "sample": "/path/to/file.txt",
      "type": "str"
     },
     "gid": {
      "description": "Numeric id representing the group of the owner",
      "returned": "success",
      "sample": 1003,
      "type": "int"
     },
     "group": {
      "description": "Group name of owner",
      "returned": "success",
      "sample": "www-data",
      "type": "str"
     },
     "md5sum": {
      "description": "MD5 checksum of the rendered file",
      "returned": "changed",
      "sample": "d41d8cd98f00b204e9800998ecf8427e",
      "type": "str"
     },
     "mode": {
      "description": "Unix permissions of the file in octal representation as a string",
      "returned": "success",
      "sample": 1755,
      "type": "str"
     },
     "owner": {
      "description": "User name of owner",
      "returned": "success",
      "sample": "httpd",
      "type": "str"
     },
     "size": {
      "description": "Size of the rendered file in bytes",
      "returned": "success",
      "sample": 42,
      "type": "int"
     },
     "src": {
      "description": "Source file used for the copy on the target machine.",
      "returned": "changed",
      "sample": "/home/httpd/.ansible/tmp/ansible-tmp-1423796390.97-147729857856000/source",
      "type": "str"
     },
     "uid": {
      "description": "Numeric id representing the file owner",
      "returned": "success",
      "sample": 1003,
      "type": "int"
     }
    }
   },
   "ansible.builtin.unarchive": {
    "doc": {
     "attributes": {
      "action": {
       "description": "Indicates this has a corresponding action plugin so some parts of the options can be executed on the controller",
       "support": "full"
      },
      "async": {
       "description": "Supports being used with the C(async) keyword",
       "support": "none"
      },
      "bypass_host_loop": {
       "description": [
        "Forces a 'global' task that does not execute per host, this bypasses per host templating and serial, throttle and other loop considerations",
        "Conditionals will work as if C(run_once) is being used, variables used will be from the first available host",
        "This action will not work normally outside of lockstep strategies"
       ],
       "support": "none"
      },
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "details": "Not supported for gzipped tar files.",
       "support": "partial"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "details": "Uses gtar's C(--diff) arg to calculate if changed or not. If this C(arg) is not supported, it will always unpack the archive.",
       "support": "partial"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "N/A"
      },
      "safe_file_operations": {
       "description": "Uses Ansible's strict file operation functions to ensure proper permissions and avoid data corruption",
       "support": "none"
      },
      "vault": {
       "description": "Can automatically decrypt Ansible vaulted files",
       "support": "full"
      }
     },
     "author": "Michael DeHaan",
     "collection": "ansible.builtin",
     "description": [
      "The M(ansible.builtin.unarchive) module unpacks an archive. It will not unpack a compressed file that does not contain an archive.",
      "By default, it will copy the source file from the local system to the target before unpacking.",
      "Set O(remote_src=yes) to unpack an archive which already exists on the target.",
      "If checksum validation is desired, use M(ansible.builtin.get_url) or M(ansible.builtin.uri) instead to fetch the file and set O(remote_src=yes).",
      "For Windows targets, use the M(community.windows.win_unzip) module instead."
     ],
     "filename": "/ansible/modules/unarchive.py",
     "has_action": true,
     "module": "unarchive",
     "notes": [
      "Requires C(zipinfo) and C(gtar)/C(unzip) command on target host.",
      "Requires C(zstd) command on target host to expand I(.tar.zst) files.",
      "Can handle I(.zip) files using C(unzip) as well as I(.tar), I(.tar.gz), I(.tar.bz2), I(.tar.xz), and I(.tar.zst) files using C(gtar).",
      "Does not handle I(.gz) files, I(.bz2) files, I(.xz), or I(.zst) files that do not contain a I(.tar) archive.",
      "Existing files/directories in the destination which are not in the archive are not touched. This is the same behavior as a normal archive extraction.",
      "Existing files/directories in the destination which are not in the archive are ignored for purposes of deciding if the archive should be unpacked or not."
     ],
     "options": {
      "attributes": {
       "aliases": [
        "attr"
       ],
       "description": [
        "The attributes the resulting filesystem object should have.",
        "To get supported flags look at the man page for I(chattr) on the target system.",
        "This string should contain the attributes in the same order as the one displayed by I(lsattr).",
        "The C(=) operator is assumed as default, otherwise C(+) or C(-) operators need to be included in the string."
       ],
       "type": "str",
       "version_added": "2.3",
       "version_added_collection": "ansible.builtin"
      },
      "copy": {
       "default": true,
       "description": [
        "If true, the file is copied from local controller to the managed (remote) node, otherwise, the plugin will look for src archive on the managed machine.",
        "This option has been deprecated in favor of O(remote_src).",
        "This option is mutually exclusive with O(remote_src)."
       ],
       "type": "bool"
      },
      "creates": {
       "description": [
        "If the specified absolute path (file or directory) already exists, this step will B(not) be run.",
        "The specified absolute path (file or directory) must be below the base path given with O(dest)."
       ],
       "type": "path",
       "version_added": "1.6",
       "version_added_collection": "ansible.builtin"
      },
      "decrypt": {
       "default": true,
       "description": [
        "This option controls the auto-decryption of source files using vault."
       ],
       "type": "bool",
       "version_added": "2.4",
       "version_added_collection": "ansible.builtin"
      },
      "dest": {
       "description": [
        "Remote absolute path where the archive should be unpacked.",
        "The given path must exist. Base directory is not created by this module."
       ],
       "required": true,
       "type": "path"
      },
      "exclude": {
       "default": [],
       "description": [
        "List the directory and file entries that you would like to exclude from the unarchive action.",
        "Mutually exclusive with O(include)."
       ],
       "elements": "str",
       "type": "list",
       "version_added": "2.1",
       "version_added_collection": "ansible.builtin"
      },
      "extra_opts": {
       "default": [],
       "description": [
        "Specify additional options by passing in an array.",
        "Each space-separated command-line option should be a new element of the array. See examples.",
        "Command-line options with multiple elements must use multiple lines in the array, one for each element."
       ],
       "elements": "str",
       "type": "list",
       "version_added": "2.1",
       "version_added_collection": "ansible.builtin"
      },
      "group": {
       "description": [
        "Name of the group that should own the filesystem object, as would be fed to I(chown).",
        "When left unspecified, it uses the current group of the current user unless you are root, in which case it can preserve the previous ownership."
       ],
       "type": "str"
      },
      "include": {
       "default": [],
       "description": [
        "List of directory and file entries that you would like to extract from the archive. If O(include) is not empty, only files listed here will be extracted.",
        "Mutually exclusive with O(exclude)."
       ],
       "elements": "str",
       "type": "list",
       "version_added": "2.11",
       "version_added_collection": "ansible.builtin"
      },
      "io_buffer_size": {
       "default": 65536,
       "description": [
        "Size of the volatile memory buffer that is used for extracting files from the archive in bytes."
       ],
       "type": "int",
       "version_added": "2.12",
       "version_added_collection": "ansible.builtin"
      },
      "keep_newer": {
       "default": false,
       "description": [
        "Do not replace existing files that are newer than files from the archive."
       ],
       "type": "bool",
       "version_added": "2.1",
       "version_added_collection": "ansible.builtin"
      },
      "list_files": {
       "default": false,
       "description": [
        "If set to True, return the list of files that are contained in the tarball."
       ],
       "type": "bool",
       "version_added": "2.0",
       "version_added_collection": "ansible.builtin"
      },
      "mode": {
       "description": [
        "The permissions the resulting filesystem object should have.",
        "For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must give Ansible enough information to parse them correctly. For consistent results, quote octal numbers (for example, V('644') or V('1777')) so Ansible receives a string and can do its own conversion from string into number. Adding a leading zero (for example, V(0755)) works sometimes, but can fail in loops and some other circumstances.",
        "Giving Ansible a number without following either of these rules will end up with a decimal number which will have unexpected results.",
        "As of Ansible 1.8, the mode may be specified as a symbolic mode (for example, V(u+rwx) or V(u=rw,g=r,o=r)).",
        "If O(mode) is not specified and the destination filesystem object B(does not) exist, the default C(umask) on the system will be used when setting the mode for the newly created filesystem object.",
        "If O(mode) is not specified and the destination filesystem object B(does) exist, the mode of the existing filesystem object will be used.",
        "Specifying O(mode) is the best way to ensure filesystem objects are created with the correct permissions. See CVE-2020-1736 for further details."
       ],
       "type": "raw"
      },
      "owner": {
       "description": [
        "Name of the user that should own the filesystem object, as would be fed to I(chown).",
        "When left unspecified, it uses the current user unless you are root, in which case it can preserve the previous ownership.",
        "Specifying a numeric username will be assumed to be a user ID and not a username. Avoid numeric usernames to avoid this confusion."
       ],
       "type": "str"
      },
      "remote_src": {
       "default": false,
       "description": [
        "Set to V(true) to indicate the archived file is already on the remote system and not local to the Ansible controller.",
        "This option is mutually exclusive with O(copy)."
       ],
       "type": "bool",
       "version_added": "2.2",
       "version_added_collection": "ansible.builtin"
      },
      "selevel": {
       "description": [
        "The level part of the SELinux filesystem object context.",
        "This is the MLS/MCS attribute, sometimes known as the C(range).",
        "When set to V(_default), it will use the C(level) portion of the policy if available."
       ],
       "type": "str"
      },
      "serole": {
       "description": [
        "The role part of the SELinux filesystem object context.",
        "When set to V(_default), it will use the C(role) portion of the policy if available."
       ],
       "type": "str"
      },
      "setype": {
       "description": [
        "The type part of the SELinux filesystem object context.",
        "When set to V(_default), it will use the C(type) portion of the policy if available."
       ],
       "type": "str"
      },
      "seuser": {
       "description": [
        "The user part of the SELinux filesystem object context.",
        "By default it uses the V(system) policy, where applicable.",
        "When set to V(_default), it will use the C(user) portion of the policy if available."
       ],
       "type": "str"
      },
      "src": {
       "description": [
        "If O(remote_src=no) (default), local path to archive file to copy to the target server; can be absolute or relative. If O(remote_src=yes), path on the target server to existing archive file to unpack.",
        "If O(remote_src=yes) and O(src) contains V(://), the remote machine will download the file from the URL first. (version_added 2.0). This is only for simple cases, for full download support use the M(ansible.builtin.get_url) module."
       ],
       "required": true,
       "type": "path"
      },
      "unsafe_writes": {
       "default": false,
       "description": [
        "Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target filesystem object.",
        "By default this module uses atomic operations to prevent data corruption or inconsistent reads from the target filesystem objects, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted filesystem objects, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.",
        "This option allows Ansible to fall back to unsafe methods of updating filesystem objects when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes).",
        "IMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption."
       ],
       "type": "bool",
       "version_added": "2.2",
       "version_added_collection": "ansible.builtin"
      },
      "validate_certs": {
       "default": true,
       "description": [
        "This only applies if using a https URL as the source of the file.",
        "This should only set to V(false) used on personally controlled sites using self-signed certificate.",
        "Prior to 2.2 the code worked as if this was set to V(true)."
       ],
       "type": "bool",
       "version_added": "2.2",
       "version_added_collection": "ansible.builtin"
      }
     },
     "seealso": [
      {
       "module": "community.general.archive"
      },
      {
       "module": "community.general.iso_extract"
      },
      {
       "module": "community.windows.win_unzip"
      }
     ],
     "short_description": "Unpacks an archive after (optionally) copying it from the local machine",
     "todo": [
      "Re-implement tar support using native tarfile module.",
      "Re-implement zip support using native zipfile module."
     ],
     "version_added": "1.4",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Extract foo.tgz into /var/lib/foo\n  ansible.builtin.unarchive:\n    src: foo.tgz\n    dest: /var/lib/foo\n\n- name: Unarchive a file that is already on the remote machine\n  ansible.builtin.unarchive:\n    src: /tmp/foo.zip\n    dest: /usr/local/bin\n    remote_src: yes\n\n- name: Unarchive a file that needs to be downloaded (added in 2.0)\n  ansible.builtin.unarchive:\n    src: https://example.com/example.zip\n    dest: /usr/local/bin\n    remote_src: yes\n\n- name: Unarchive a file with extra options\n  ansible.builtin.unarchive:\n    src: /tmp/foo.zip\n    dest: /usr/local/bin\n    extra_opts:\n    - --transform\n    - s/^xxx/yyy/\n",
    "metadata": null,
    "return": {
     "dest": {
      "description": "Path to the destination directory.",
      "returned": "always",
      "sample": "/opt/software",
      "type": "str"
     },
     "files": {
      "description": "List of all the files in the archive.",
      "returned": "When O(list_files) is V(True)",
      "sample": "[\"file1\", \"file2\"]",
      "type": "list"
     },
     "gid": {
      "description": "Numerical ID of the group that owns the destination directory.",
      "returned": "always",
      "sample": 1000,
      "type": "int"
     },
     "group": {
      "description": "Name of the group that owns the destination directory.",
      "returned": "always",
      "sample": "librarians",
      "type": "str"
     },
     "handler": {
      "description": "Archive software handler used to extract and decompress the archive.",
      "returned": "always",
      "sample": "TgzArchive",
      "type": "str"
     },
     "mode": {
      "description": "String that represents the octal permissions of the destination directory.",
      "returned": "always",
      "sample": "0755",
      "type": "str"
     },
     "owner": {
      "description": "Name of the user that owns the destination directory.",
      "returned": "always",
      "sample": "paul",
      "type": "str"
     },
     "size": {
      "description": "The size of destination directory in bytes. Does not include the size of files or subdirectories contained within.",
      "returned": "always",
      "sample": 36,
      "type": "int"
     },
     "src": {
      "description": [
       "The source archive's path.",
       "If O(src) was a remote web URL, or from the local ansible controller, this shows the temporary location where the download was stored."
      ],
      "returned": "always",
      "sample": "/home/paul/test.tar.gz",
      "type": "str"
     },
     "state": {
      "description": "State of the destination. Effectively always \"directory\".",
      "returned": "always",
      "sample": "directory",
      "type": "str"
     },
     "uid": {
      "description": "Numerical ID of the user that owns the destination directory.",
      "returned": "always",
      "sample": 1000,
      "type": "int"
     }
    }
   },
   "ansible.builtin.uri": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "none"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "N/A"
      }
     },
     "author": [
      "Romeo Theriault (@romeotheriault)"
     ],
     "collection": "ansible.builtin",
     "description": [
      "Interacts with HTTP and HTTPS web services and supports Digest, Basic and WSSE HTTP authentication mechanisms.",
      "For Windows targets, use the M(ansible.windows.win_uri) module instead."
     ],
     "filename": "/ansible/modules/uri.py",
     "has_action": true,
     "module": "uri",
     "notes": [
      "The dependency on httplib2 was removed in Ansible 2.1.",
      "The module returns all the HTTP headers in lower-case.",
      "For Windows targets, use the M(ansible.windows.win_uri) module instead."
     ],
     "options": {
      "attributes": {
       "aliases": [
        "attr"
       ],
       "description": [
        "The attributes the resulting filesystem object should have.",
        "To get supported flags look at the man page for I(chattr) on the target system.",
        "This string should contain the attributes in the same order as the one displayed by I(lsattr).",
        "The C(=) operator is assumed as default, otherwise C(+) or C(-) operators need to be included in the string."
       ],
       "type": "str",
       "version_added": "2.3",
       "version_added_collection": "ansible.builtin"
      },
      "body": {
       "description": [
        "The body of the http request/response to the web service. If O(body_format) is set to V(json) it will take an already formatted JSON string or convert a data structure into JSON.",
        "If O(body_format) is set to V(form-urlencoded) it will convert a dictionary or list of tuples into an 'application/x-www-form-urlencoded' string. (Added in v2.7)",
        "If O(body_format) is set to V(form-multipart) it will convert a dictionary into 'multipart/form-multipart' body. (Added in v2.10)"
       ],
       "type": "raw"
      },
      "body_format": {
       "choices": [
        "form-urlencoded",
        "json",
        "raw",
        "form-multipart"
       ],
       "default": "raw",
       "description": [
        "The serialization format of the body. When set to V(json), V(form-multipart), or V(form-urlencoded), encodes the body argument, if needed, and automatically sets the Content-Type header accordingly.",
        "As of v2.3 it is possible to override the C(Content-Type) header, when set to V(json) or V(form-urlencoded) via the O(headers) option.",
        "The 'Content-Type' header cannot be overridden when using V(form-multipart)",
        "V(form-urlencoded) was added in v2.7.",
        "V(form-multipart) was added in v2.10."
       ],
       "type": "str",
       "version_added": "2.0",
       "version_added_collection": "ansible.builtin"
      },
      "ca_path": {
       "description": [
        "PEM formatted file that contains a CA certificate to be used for validation"
       ],
       "type": "path",
       "version_added": "2.11",
       "version_added_collection": "ansible.builtin"
      },
      "ciphers": {
       "description": [
        "SSL/TLS Ciphers to use for the request.",
        "When a list is provided, all ciphers are joined in order with V(:)",
        "See the L(OpenSSL Cipher List Format,https://www.openssl.org/docs/manmaster/man1/openssl-ciphers.html#CIPHER-LIST-FORMAT) for more details.",
        "The available ciphers is dependent on the Python and OpenSSL/LibreSSL versions"
       ],
       "elements": "str",
       "type": "list",
       "version_added": "2.14",
       "version_added_collection": "ansible.builtin"
      },
      "client_cert": {
       "description": [
        "PEM formatted certificate chain file to be used for SSL client authentication.",
        "This file can also include the key as well, and if the key is included, O(client_key) is not required"
       ],
       "type": "path",
       "version_added": "2.4",
       "version_added_collection": "ansible.builtin"
      },
      "client_key": {
       "description": [
        "PEM formatted file that contains your private key to be used for SSL client authentication.",
        "If O(client_cert) contains both the certificate and key, this option is not required."
       ],
       "type": "path",
       "version_added": "2.4",
       "version_added_collection": "ansible.builtin"
      },
      "creates": {
       "description": [
        "A filename, when it already exists, this step will not be run."
       ],
       "type": "path"
      },
      "decompress": {
       "default": true,
       "description": [
        "Whether to attempt to decompress gzip content-encoded responses"
       ],
       "type": "bool",
       "version_added": "2.14",
       "version_added_collection": "ansible.builtin"
      },
      "dest": {
       "description": [
        "A path of where to download the file to (if desired). If O(dest) is a directory, the basename of the file on the remote server will be used."
       ],
       "type": "path"
      },
      "follow_redirects": {
       "choices": [
        "all",
        "no",
        "none",
        "safe",
        "urllib2",
        "yes"
       ],
       "default": "safe",
       "description": [
        "Whether or not the URI module should follow redirects. V(all) will follow all redirects. V(safe) will follow only \"safe\" redirects, where \"safe\" means that the client is only doing a GET or HEAD on the URI to which it is being redirected. V(none) will not follow any redirects. Note that V(true) and V(false) choices are accepted for backwards compatibility, where V(true) is the equivalent of V(all) and V(false) is the equivalent of V(safe). V(true) and V(false) are deprecated and will be removed in some future version of Ansible."
       ],
       "type": "str"
      },
      "force": {
       "default": false,
       "description": [
        "If V(true) do not get a cached copy."
       ],
       "type": "bool"
      },
      "force_basic_auth": {
       "default": false,
       "description": [
        "Force the sending of the Basic authentication header upon initial request.",
        "When this setting is V(false), this module will first try an unauthenticated request, and when the server replies with an C(HTTP 401) error, it will submit the Basic authentication header.",
        "When this setting is V(true), this module will immediately send a Basic authentication header on the first request.",
        "Use this setting in any of the following scenarios:",
        "You know the webservice endpoint always requires HTTP Basic authentication, and you want to speed up your requests by eliminating the first roundtrip.",
        "The web service does not properly send an HTTP 401 error to your client, so Ansible's HTTP library will not properly respond with HTTP credentials, and logins will fail.",
        "The webservice bans or rate-limits clients that cause any HTTP 401 errors."
       ],
       "type": "bool"
      },
      "group": {
       "description": [
        "Name of the group that should own the filesystem object, as would be fed to I(chown).",
        "When left unspecified, it uses the current group of the current user unless you are root, in which case it can preserve the previous ownership."
       ],
       "type": "str"
      },
      "headers": {
       "default": {},
       "description": [
        "Add custom HTTP headers to a request in the format of a YAML hash. As of Ansible 2.3 supplying C(Content-Type) here will override the header generated by supplying V(json) or V(form-urlencoded) for O(body_format)."
       ],
       "type": "dict",
       "version_added": "2.1",
       "version_added_collection": "ansible.builtin"
      },
      "http_agent": {
       "default": "ansible-httpget",
       "description": [
        "Header to identify as, generally appears in web server logs."
       ],
       "type": "str"
      },
      "method": {
       "default": "GET",
       "description": [
        "The HTTP method of the request or response.",
        "In more recent versions we do not restrict the method at the module level anymore but it still must be a valid method accepted by the service handling the request."
       ],
       "type": "str"
      },
      "mode": {
       "description": [
        "The permissions the resulting filesystem object should have.",
        "For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must give Ansible enough information to parse them correctly. For consistent results, quote octal numbers (for example, V('644') or V('1777')) so Ansible receives a string and can do its own conversion from string into number. Adding a leading zero (for example, V(0755)) works sometimes, but can fail in loops and some other circumstances.",
        "Giving Ansible a number without following either of these rules will end up with a decimal number which will have unexpected results.",
        "As of Ansible 1.8, the mode may be specified as a symbolic mode (for example, V(u+rwx) or V(u=rw,g=r,o=r)).",
        "If O(mode) is not specified and the destination filesystem object B(does not) exist, the default C(umask) on the system will be used when setting the mode for the newly created filesystem object.",
        "If O(mode) is not specified and the destination filesystem object B(does) exist, the mode of the existing filesystem object will be used.",
        "Specifying O(mode) is the best way to ensure filesystem objects are created with the correct permissions. See CVE-2020-1736 for further details."
       ],
       "type": "raw"
      },
      "owner": {
       "description": [
        "Name of the user that should own the filesystem object, as would be fed to I(chown).",
        "When left unspecified, it uses the current user unless you are root, in which case it can preserve the previous ownership.",
        "Specifying a numeric username will be assumed to be a user ID and not a username. Avoid numeric usernames to avoid this confusion."
       ],
       "type": "str"
      },
      "remote_src": {
       "default": false,
       "description": [
        "If V(false), the module will search for the O(src) on the controller node.",
        "If V(true), the module will search for the O(src) on the managed (remote) node."
       ],
       "type": "bool",
       "version_added": "2.7",
       "version_added_collection": "ansible.builtin"
      },
      "removes": {
       "description": [
        "A filename, when it does not exist, this step will not be run."
       ],
       "type": "path"
      },
      "return_content": {
       "default": false,
       "description": [
        "Whether or not to return the body of the response as a \"content\" key in the dictionary result no matter it succeeded or failed.",
        "Independently of this option, if the reported Content-type is \"application/json\", then the JSON is always loaded into a key called RV(ignore:json) in the dictionary results."
       ],
       "type": "bool"
      },
      "selevel": {
       "description": [
        "The level part of the SELinux filesystem object context.",
        "This is the MLS/MCS attribute, sometimes known as the C(range).",
        "When set to V(_default), it will use the C(level) portion of the policy if available."
       ],
       "type": "str"
      },
      "serole": {
       "description": [
        "The role part of the SELinux filesystem object context.",
        "When set to V(_default), it will use the C(role) portion of the policy if available."
       ],
       "type": "str"
      },
      "setype": {
       "description": [
        "The type part of the SELinux filesystem object context.",
        "When set to V(_default), it will use the C(type) portion of the policy if available."
       ],
       "type": "str"
      },
      "seuser": {
       "description": [
        "The user part of the SELinux filesystem object context.",
        "By default it uses the V(system) policy, where applicable.",
        "When set to V(_default), it will use the C(user) portion of the policy if available."
       ],
       "type": "str"
      },
      "src": {
       "description": [
        "Path to file to be submitted to the remote server.",
        "Cannot be used with O(body).",
        "Should be used with O(force_basic_auth) to ensure success when the remote end sends a 401."
       ],
       "type": "path",
       "version_added": "2.7",
       "version_added_collection": "ansible.builtin"
      },
      "status_code": {
       "default": [
        200
       ],
       "description": [
        "A list of valid, numeric, HTTP status codes that signifies success of the request."
       ],
       "elements": "int",
       "type": "list"
      },
      "timeout": {
       "default": 30,
       "description": [
        "The socket level timeout in seconds"
       ],
       "type": "int"
      },
      "unix_socket": {
       "description": [
        "Path to Unix domain socket to use for connection"
       ],
       "type": "path",
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      },
      "unredirected_headers": {
       "default": [],
       "description": [
        "A list of header names that will not be sent on subsequent redirected requests. This list is case insensitive. By default all headers will be redirected. In some cases it may be beneficial to list headers such as C(Authorization) here to avoid potential credential exposure."
       ],
       "elements": "str",
       "type": "list",
       "version_added": "2.12",
       "version_added_collection": "ansible.builtin"
      },
      "unsafe_writes": {
       "default": false,
       "description": [
        "Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target filesystem object.",
        "By default this module uses atomic operations to prevent data corruption or inconsistent reads from the target filesystem objects, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted filesystem objects, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.",
        "This option allows Ansible to fall back to unsafe methods of updating filesystem objects when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes).",
        "IMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption."
       ],
       "type": "bool",
       "version_added": "2.2",
       "version_added_collection": "ansible.builtin"
      },
      "url": {
       "description": [
        "HTTP or HTTPS URL in the form (http|https)://host.domain[:port]/path"
       ],
       "required": true,
       "type": "str"
      },
      "url_password": {
       "aliases": [
        "password"
       ],
       "description": [
        "A password for the module to use for Digest, Basic or WSSE authentication."
       ],
       "type": "str"
      },
      "url_username": {
       "aliases": [
        "user"
       ],
       "description": [
        "A username for the module to use for Digest, Basic or WSSE authentication."
       ],
       "type": "str"
      },
      "use_gssapi": {
       "default": false,
       "description": [
        "Use GSSAPI to perform the authentication, typically this is for Kerberos or Kerberos through Negotiate authentication.",
        "Requires the Python library L(gssapi,https://github.com/pythongssapi/python-gssapi) to be installed.",
        "Credentials for GSSAPI can be specified with O(url_username)/O(url_password) or with the GSSAPI env var C(KRB5CCNAME) that specified a custom Kerberos credential cache.",
        "NTLM authentication is B(not) supported even if the GSSAPI mech for NTLM has been installed."
       ],
       "type": "bool",
       "version_added": "2.11",
       "version_added_collection": "ansible.builtin"
      },
      "use_netrc": {
       "default": true,
       "description": [
        "Determining whether to use credentials from ``~/.netrc`` file",
        "By default .netrc is used with Basic authentication headers",
        "When set to False, .netrc credentials are ignored"
       ],
       "type": "bool",
       "version_added": "2.14",
       "version_added_collection": "ansible.builtin"
      },
      "use_proxy": {
       "default": true,
       "description": [
        "If V(false), it will not use a proxy, even if one is defined in an environment variable on the target hosts."
       ],
       "type": "bool"
      },
      "validate_certs": {
       "default": true,
       "description": [
        "If V(false), SSL certificates will not be validated.",
        "This should only set to V(false) used on personally controlled sites using self-signed certificates.",
        "Prior to 1.9.2 the code defaulted to V(false)."
       ],
       "type": "bool",
       "version_added": "1.9.2",
       "version_added_collection": "ansible.builtin"
      }
     },
     "seealso": [
      {
       "module": "ansible.builtin.get_url"
      },
      {
       "module": "ansible.windows.win_uri"
      }
     ],
     "short_description": "Interacts with webservices",
     "version_added": "1.1",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Check that you can connect (GET) to a page and it returns a status 200\n  ansible.builtin.uri:\n    url: http://www.example.com\n\n- name: Check that a page returns successfully but fail if the word AWESOME is not in the page contents\n  ansible.builtin.uri:\n    url: http://www.example.com\n    return_content: true\n  register: this\n  failed_when: this is failed or \"'AWESOME' not in this.content\"\n\n- name: Create a JIRA issue\n  ansible.builtin.uri:\n    url: https://your.jira.example.com/rest/api/2/issue/\n    user: your_username\n    password: your_pass\n    method: POST\n    body: \"{{ lookup('ansible.builtin.file','issue.json') }}\"\n    force_basic_auth: true\n    status_code: 201\n    body_format: json\n\n- name: Login to a form based webpage, then use the returned cookie to access the app in later tasks\n  ansible.builtin.uri:\n    url: https://your.form.based.auth.example.com/index.php\n    method: POST\n    body_format: form-urlencoded\n    body:\n      name: your_username\n      password: your_password\n      enter: Sign in\n    status_code: 302\n  register: login\n\n- name: Login to a form based webpage using a list of tuples\n  ansible.builtin.uri:\n    url: https://your.form.based.auth.example.com/index.php\n    method: POST\n    body_format: form-urlencoded\n    body:\n    - [ name, your_username ]\n    - [ password, your_password ]\n    - [ enter, Sign in ]\n    status_code: 302\n  register: login\n\n- name: Upload a file via multipart/form-multipart\n  ansible.builtin.uri:\n    url: https://httpbin.org/post\n    method: POST\n    body_format: form-multipart\n    body:\n      file1:\n        filename: /bin/true\n        mime_type: application/octet-stream\n      file2:\n        content: text based file content\n        filename: fake.txt\n        mime_type: text/plain\n      text_form_field: value\n\n- name: Connect to website using a previously stored cookie\n  ansible.builtin.uri:\n    url: https://your.form.based.auth.example.com/dashboard.php\n    method: GET\n    return_content: true\n    headers:\n      Cookie: \"{{ login.cookies_string }}\"\n\n- name: Queue build of a project in Jenkins\n  ansible.builtin.uri:\n    url: http://{{ jenkins.host }}/job/{{ jenkins.job }}/build?token={{ jenkins.token }}\n    user: \"{{ jenkins.user }}\"\n    password: \"{{ jenkins.password }}\"\n    method: GET\n    force_basic_auth: true\n    status_code: 201\n\n- name: POST from contents of local file\n  ansible.builtin.uri:\n    url: https://httpbin.org/post\n    method: POST\n    src: file.json\n\n- name: POST from contents of remote file\n  ansible.builtin.uri:\n    url: https://httpbin.org/post\n    method: POST\n    src: /path/to/my/file.json\n    remote_src: true\n\n- name: Create workspaces in Log analytics Azure\n  ansible.builtin.uri:\n    url: https://www.mms.microsoft.com/Embedded/Api/ConfigDataSources/LogManagementData/Save\n    method: POST\n    body_format: json\n    status_code: [200, 202]\n    return_content: true\n    headers:\n      Content-Type: application/json\n      x-ms-client-workspace-path: /subscriptions/{{ sub_id }}/resourcegroups/{{ res_group }}/providers/microsoft.operationalinsights/workspaces/{{ w_spaces }}\n      x-ms-client-platform: ibiza\n      x-ms-client-auth-token: \"{{ token_az }}\"\n    body:\n\n- name: Pause play until a URL is reachable from this host\n  ansible.builtin.uri:\n    url: \"http://192.0.2.1/some/test\"\n    follow_redirects: none\n    method: GET\n  register: _result\n  until: _result.status == 200\n  retries: 720 # 720 * 5 seconds = 1hour (60*60/5)\n  delay: 5 # Every 5 seconds\n\n- name: Provide SSL/TLS ciphers as a list\n  uri:\n    url: https://example.org\n    ciphers:\n      - '@SECLEVEL=2'\n      - ECDH+AESGCM\n      - ECDH+CHACHA20\n      - ECDH+AES\n      - DHE+AES\n      - '!aNULL'\n      - '!eNULL'\n      - '!aDSS'\n      - '!SHA1'\n      - '!AESCCM'\n\n- name: Provide SSL/TLS ciphers as an OpenSSL formatted cipher list\n  uri:\n    url: https://example.org\n    ciphers: '@SECLEVEL=2:ECDH+AESGCM:ECDH+CHACHA20:ECDH+AES:DHE+AES:!aNULL:!eNULL:!aDSS:!SHA1:!AESCCM'\n",
    "metadata": null,
    "return": {
     "content": {
      "description": "The response body content.",
      "returned": "status not in status_code or return_content is true",
      "sample": "{}",
      "type": "str"
     },
     "cookies": {
      "description": "The cookie values placed in cookie jar.",
      "returned": "on success",
      "sample": {
       "SESSIONID": "[SESSIONID]"
      },
      "type": "dict",
      "version_added": "2.4",
      "version_added_collection": "ansible.builtin"
     },
     "cookies_string": {
      "description": "The value for future request Cookie headers.",
      "returned": "on success",
      "sample": "SESSIONID=[SESSIONID]",
      "type": "str",
      "version_added": "2.6",
      "version_added_collection": "ansible.builtin"
     },
     "elapsed": {
      "description": "The number of seconds that elapsed while performing the download.",
      "returned": "on success",
      "sample": 23,
      "type": "int"
     },
     "msg": {
      "description": "The HTTP message from the request.",
      "returned": "always",
      "sample": "OK (unknown bytes)",
      "type": "str"
     },
     "path": {
      "description": "destination file/path",
      "returned": "dest is defined",
      "sample": "/path/to/file.txt",
      "type": "str"
     },
     "redirected": {
      "description": "Whether the request was redirected.",
      "returned": "on success",
      "sample": false,
      "type": "bool"
     },
     "status": {
      "description": "The HTTP status code from the request.",
      "returned": "always",
      "sample": 200,
      "type": "int"
     },
     "url": {
      "description": "The actual URL used for the request.",
      "returned": "always",
      "sample": "https://www.ansible.com/",
      "type": "str"
     }
    }
   },
   "ansible.builtin.user": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "N/A"
      }
     },
     "author": [
      "Stephen Fromm (@sfromm)"
     ],
     "collection": "ansible.builtin",
     "description": [
      "Manage user accounts and user attributes.",
      "For Windows targets, use the M(ansible.windows.win_user) module instead."
     ],
     "filename": "/ansible/modules/user.py",
     "has_action": false,
     "module": "user",
     "notes": [
      "There are specific requirements per platform on user management utilities. However they generally come pre-installed with the system and Ansible will require they are present at runtime. If they are not, a descriptive error message will be shown.",
      "On SunOS platforms, the shadow file is backed up automatically since this module edits it directly. On other platforms, the shadow file is backed up by the underlying tools used by this module.",
      "On macOS, this module uses C(dscl) to create, modify, and delete accounts. C(dseditgroup) is used to modify group membership. Accounts are hidden from the login window by modifying C(/Library/Preferences/com.apple.loginwindow.plist).",
      "On FreeBSD, this module uses C(pw useradd) and C(chpass) to create, C(pw usermod) and C(chpass) to modify, C(pw userdel) remove, C(pw lock) to lock, and C(pw unlock) to unlock accounts.",
      "On all other platforms, this module uses C(useradd) to create, C(usermod) to modify, and C(userdel) to remove accounts."
     ],
     "options": {
      "append": {
       "default": false,
       "description": [
        "If V(true), add the user to the groups specified in O(groups).",
        "If V(false), user will only be added to the groups specified in O(groups), removing them from all other groups."
       ],
       "type": "bool"
      },
      "authorization": {
       "description": [
        "Sets the authorization of the user.",
        "Can set multiple authorizations using comma separation.",
        "To delete all authorizations, use O(authorization='').",
        "Currently supported on Illumos/Solaris. Does nothing when used with other platforms."
       ],
       "type": "str",
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      },
      "comment": {
       "description": [
        "Optionally sets the description (aka I(GECOS)) of user account.",
        "On macOS, this defaults to the O(name) option."
       ],
       "type": "str"
      },
      "create_home": {
       "aliases": [
        "createhome"
       ],
       "default": true,
       "description": [
        "Unless set to V(false), a home directory will be made for the user when the account is created or if the home directory does not exist.",
        "Changed from O(createhome) to O(create_home) in Ansible 2.5."
       ],
       "type": "bool"
      },
      "expires": {
       "description": [
        "An expiry time for the user in epoch, it will be ignored on platforms that do not support this.",
        "Currently supported on GNU/Linux, FreeBSD, and DragonFlyBSD.",
        "Since Ansible 2.6 you can remove the expiry time by specifying a negative value. Currently supported on GNU/Linux and FreeBSD."
       ],
       "type": "float",
       "version_added": "1.9",
       "version_added_collection": "ansible.builtin"
      },
      "force": {
       "default": false,
       "description": [
        "This only affects O(state=absent), it forces removal of the user and associated directories on supported platforms.",
        "The behavior is the same as C(userdel --force), check the man page for C(userdel) on your system for details and support.",
        "When used with O(generate_ssh_key=yes) this forces an existing key to be overwritten."
       ],
       "type": "bool"
      },
      "generate_ssh_key": {
       "default": false,
       "description": [
        "Whether to generate a SSH key for the user in question.",
        "This will B(not) overwrite an existing SSH key unless used with O(force=yes)."
       ],
       "type": "bool",
       "version_added": "0.9",
       "version_added_collection": "ansible.builtin"
      },
      "group": {
       "description": [
        "Optionally sets the user's primary group (takes a group name).",
        "On macOS, this defaults to V('staff')"
       ],
       "type": "str"
      },
      "groups": {
       "description": [
        "A list of supplementary groups which the user is also a member of.",
        "By default, the user is removed from all other groups. Configure O(append) to modify this.",
        "When set to an empty string V(''), the user is removed from all groups except the primary group.",
        "Before Ansible 2.3, the only input format allowed was a comma separated string."
       ],
       "elements": "str",
       "type": "list"
      },
      "hidden": {
       "description": [
        "macOS only, optionally hide the user from the login window and system preferences.",
        "The default will be V(true) if the O(system) option is used."
       ],
       "type": "bool",
       "version_added": "2.6",
       "version_added_collection": "ansible.builtin"
      },
      "home": {
       "description": [
        "Optionally set the user's home directory."
       ],
       "type": "path"
      },
      "local": {
       "default": false,
       "description": [
        "Forces the use of \"local\" command alternatives on platforms that implement it.",
        "This is useful in environments that use centralized authentication when you want to manipulate the local users (in other words, it uses C(luseradd) instead of C(useradd)).",
        "This will check C(/etc/passwd) for an existing account before invoking commands. If the local account database exists somewhere other than C(/etc/passwd), this setting will not work properly.",
        "This requires that the above commands as well as C(/etc/passwd) must exist on the target host, otherwise it will be a fatal error."
       ],
       "type": "bool",
       "version_added": "2.4",
       "version_added_collection": "ansible.builtin"
      },
      "login_class": {
       "description": [
        "Optionally sets the user's login class, a feature of most BSD OSs."
       ],
       "type": "str"
      },
      "move_home": {
       "default": false,
       "description": [
        "If set to V(true) when used with O(home), attempt to move the user's old home directory to the specified directory if it isn't there already and the old home exists."
       ],
       "type": "bool"
      },
      "name": {
       "aliases": [
        "user"
       ],
       "description": [
        "Name of the user to create, remove or modify."
       ],
       "required": true,
       "type": "str"
      },
      "non_unique": {
       "default": false,
       "description": [
        "Optionally when used with the -u option, this option allows to change the user ID to a non-unique value."
       ],
       "type": "bool",
       "version_added": "1.1",
       "version_added_collection": "ansible.builtin"
      },
      "password": {
       "description": [
        "If provided, set the user's password to the provided encrypted hash (Linux) or plain text password (macOS).",
        "B(Linux/Unix/POSIX:) Enter the hashed password as the value.",
        "See L(FAQ entry,https://docs.ansible.com/ansible/latest/reference_appendices/faq.html#how-do-i-generate-encrypted-passwords-for-the-user-module) for details on various ways to generate the hash of a password.",
        "To create an account with a locked/disabled password on Linux systems, set this to V('!') or V('*').",
        "To create an account with a locked/disabled password on OpenBSD, set this to V('*************').",
        "B(OS X/macOS:) Enter the cleartext password as the value. Be sure to take relevant security precautions.",
        "On macOS, the password specified in the C(password) option will always be set, regardless of whether the user account already exists or not.",
        "When the password is passed as an argument, the C(user) module will always return changed to C(true) for macOS systems. Since macOS no longer provides access to the hashed passwords directly."
       ],
       "type": "str"
      },
      "password_expire_max": {
       "description": [
        "Maximum number of days between password change.",
        "Supported on Linux only."
       ],
       "type": "int",
       "version_added": "2.11",
       "version_added_collection": "ansible.builtin"
      },
      "password_expire_min": {
       "description": [
        "Minimum number of days between password change.",
        "Supported on Linux only."
       ],
       "type": "int",
       "version_added": "2.11",
       "version_added_collection": "ansible.builtin"
      },
      "password_expire_warn": {
       "description": [
        "Number of days of warning before password expires.",
        "Supported on Linux only."
       ],
       "type": "int",
       "version_added": "2.16",
       "version_added_collection": "ansible.builtin"
      },
      "password_lock": {
       "description": [
        "Lock the password (C(usermod -L), C(usermod -U), C(pw lock)).",
        "Implementation differs by platform. This option does not always mean the user cannot login using other methods.",
        "This option does not disable the user, only lock the password.",
        "This must be set to V(False) in order to unlock a currently locked password. The absence of this parameter will not unlock a password.",
        "Currently supported on Linux, FreeBSD, DragonFlyBSD, NetBSD, OpenBSD."
       ],
       "type": "bool",
       "version_added": "2.6",
       "version_added_collection": "ansible.builtin"
      },
      "profile": {
       "description": [
        "Sets the profile of the user.",
        "Can set multiple profiles using comma separation.",
        "To delete all the profiles, use O(profile='').",
        "Currently supported on Illumos/Solaris. Does nothing when used with other platforms."
       ],
       "type": "str",
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      },
      "remove": {
       "default": false,
       "description": [
        "This only affects O(state=absent), it attempts to remove directories associated with the user.",
        "The behavior is the same as C(userdel --remove), check the man page for details and support."
       ],
       "type": "bool"
      },
      "role": {
       "description": [
        "Sets the role of the user.",
        "Can set multiple roles using comma separation.",
        "To delete all roles, use O(role='').",
        "Currently supported on Illumos/Solaris. Does nothing when used with other platforms."
       ],
       "type": "str",
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      },
      "seuser": {
       "description": [
        "Optionally sets the seuser type (user_u) on selinux enabled systems."
       ],
       "type": "str",
       "version_added": "2.1",
       "version_added_collection": "ansible.builtin"
      },
      "shell": {
       "description": [
        "Optionally set the user's shell.",
        "On macOS, before Ansible 2.5, the default shell for non-system users was V(/usr/bin/false). Since Ansible 2.5, the default shell for non-system users on macOS is V(/bin/bash).",
        "On other operating systems, the default shell is determined by the underlying tool invoked by this module. See Notes for a per platform list of invoked tools."
       ],
       "type": "str"
      },
      "skeleton": {
       "description": [
        "Optionally set a home skeleton directory.",
        "Requires O(create_home) option!"
       ],
       "type": "str",
       "version_added": "2.0",
       "version_added_collection": "ansible.builtin"
      },
      "ssh_key_bits": {
       "description": [
        "Optionally specify number of bits in SSH key to create.",
        "The default value depends on ssh-keygen."
       ],
       "type": "int",
       "version_added": "0.9",
       "version_added_collection": "ansible.builtin"
      },
      "ssh_key_comment": {
       "default": "ansible-generated on $HOSTNAME",
       "description": [
        "Optionally define the comment for the SSH key."
       ],
       "type": "str",
       "version_added": "0.9",
       "version_added_collection": "ansible.builtin"
      },
      "ssh_key_file": {
       "description": [
        "Optionally specify the SSH key filename.",
        "If this is a relative filename then it will be relative to the user's home directory.",
        "This parameter defaults to V(.ssh/id_rsa)."
       ],
       "type": "path",
       "version_added": "0.9",
       "version_added_collection": "ansible.builtin"
      },
      "ssh_key_passphrase": {
       "description": [
        "Set a passphrase for the SSH key.",
        "If no passphrase is provided, the SSH key will default to having no passphrase."
       ],
       "type": "str",
       "version_added": "0.9",
       "version_added_collection": "ansible.builtin"
      },
      "ssh_key_type": {
       "default": "rsa",
       "description": [
        "Optionally specify the type of SSH key to generate.",
        "Available SSH key types will depend on implementation present on target host."
       ],
       "type": "str",
       "version_added": "0.9",
       "version_added_collection": "ansible.builtin"
      },
      "state": {
       "choices": [
        "absent",
        "present"
       ],
       "default": "present",
       "description": [
        "Whether the account should exist or not, taking action if the state is different from what is stated.",
        "See this L(FAQ entry,https://docs.ansible.com/ansible/latest/reference_appendices/faq.html#running-on-macos-as-a-target) for additional requirements when removing users on macOS systems."
       ],
       "type": "str"
      },
      "system": {
       "default": false,
       "description": [
        "When creating an account O(state=present), setting this to V(true) makes the user a system account.",
        "This setting cannot be changed on existing users."
       ],
       "type": "bool"
      },
      "uid": {
       "description": [
        "Optionally sets the I(UID) of the user."
       ],
       "type": "int"
      },
      "umask": {
       "description": [
        "Sets the umask of the user.",
        "Currently supported on Linux. Does nothing when used with other platforms.",
        "Requires O(local) is omitted or V(False)."
       ],
       "type": "str",
       "version_added": "2.12",
       "version_added_collection": "ansible.builtin"
      },
      "update_password": {
       "choices": [
        "always",
        "on_create"
       ],
       "default": "always",
       "description": [
        "V(always) will update passwords if they differ.",
        "V(on_create) will only set the password for newly created users."
       ],
       "type": "str",
       "version_added": "1.3",
       "version_added_collection": "ansible.builtin"
      }
     },
     "seealso": [
      {
       "module": "ansible.posix.authorized_key"
      },
      {
       "module": "ansible.builtin.group"
      },
      {
       "module": "ansible.windows.win_user"
      }
     ],
     "short_description": "Manage user accounts",
     "version_added": "0.2",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Add the user 'johnd' with a specific uid and a primary group of 'admin'\n  ansible.builtin.user:\n    name: johnd\n    comment: John Doe\n    uid: 1040\n    group: admin\n\n- name: Create a user 'johnd' with a home directory\n  ansible.builtin.user:\n    name: johnd\n    create_home: yes\n\n- name: Add the user 'james' with a bash shell, appending the group 'admins' and 'developers' to the user's groups\n  ansible.builtin.user:\n    name: james\n    shell: /bin/bash\n    groups: admins,developers\n    append: yes\n\n- name: Remove the user 'johnd'\n  ansible.builtin.user:\n    name: johnd\n    state: absent\n    remove: yes\n\n- name: Create a 2048-bit SSH key for user jsmith in ~jsmith/.ssh/id_rsa\n  ansible.builtin.user:\n    name: jsmith\n    generate_ssh_key: yes\n    ssh_key_bits: 2048\n    ssh_key_file: .ssh/id_rsa\n\n- name: Added a consultant whose account you want to expire\n  ansible.builtin.user:\n    name: james18\n    shell: /bin/zsh\n    groups: developers\n    expires: 1422403387\n\n- name: Starting at Ansible 2.6, modify user, remove expiry time\n  ansible.builtin.user:\n    name: james18\n    expires: -1\n\n- name: Set maximum expiration date for password\n  ansible.builtin.user:\n    name: ram19\n    password_expire_max: 10\n\n- name: Set minimum expiration date for password\n  ansible.builtin.user:\n    name: pushkar15\n    password_expire_min: 5\n\n- name: Set number of warning days for password expiration\n  ansible.builtin.user:\n    name: jane157\n    password_expire_warn: 30\n",
    "metadata": null,
    "return": {
     "append": {
      "description": "Whether or not to append the user to groups.",
      "returned": "When O(state) is V(present) and the user exists",
      "sample": true,
      "type": "bool"
     },
     "comment": {
      "description": "Comment section from passwd file, usually the user name.",
      "returned": "When user exists",
      "sample": "Agent Smith",
      "type": "str"
     },
     "create_home": {
      "description": "Whether or not to create the home directory.",
      "returned": "When user does not exist and not check mode",
      "sample": true,
      "type": "bool"
     },
     "force": {
      "description": "Whether or not a user account was forcibly deleted.",
      "returned": "When O(state) is V(absent) and user exists",
      "sample": false,
      "type": "bool"
     },
     "group": {
      "description": "Primary user group ID",
      "returned": "When user exists",
      "sample": 1001,
      "type": "int"
     },
     "groups": {
      "description": "List of groups of which the user is a member.",
      "returned": "When O(groups) is not empty and O(state) is V(present)",
      "sample": "chrony,apache",
      "type": "str"
     },
     "home": {
      "description": "Path to user's home directory.",
      "returned": "When O(state) is V(present)",
      "sample": "/home/asmith",
      "type": "str"
     },
     "move_home": {
      "description": "Whether or not to move an existing home directory.",
      "returned": "When O(state) is V(present) and user exists",
      "sample": false,
      "type": "bool"
     },
     "name": {
      "description": "User account name.",
      "returned": "always",
      "sample": "asmith",
      "type": "str"
     },
     "password": {
      "description": "Masked value of the password.",
      "returned": "When O(state) is V(present) and O(password) is not empty",
      "sample": "NOT_LOGGING_PASSWORD",
      "type": "str"
     },
     "remove": {
      "description": "Whether or not to remove the user account.",
      "returned": "When O(state) is V(absent) and user exists",
      "sample": true,
      "type": "bool"
     },
     "shell": {
      "description": "User login shell.",
      "returned": "When O(state) is V(present)",
      "sample": "/bin/bash",
      "type": "str"
     },
     "ssh_fingerprint": {
      "description": "Fingerprint of generated SSH key.",
      "returned": "When O(generate_ssh_key) is V(True)",
      "sample": "2048 SHA256:aYNHYcyVm87Igh0IMEDMbvW0QDlRQfE0aJugp684ko8 ansible-generated on host (RSA)",
      "type": "str"
     },
     "ssh_key_file": {
      "description": "Path to generated SSH private key file.",
      "returned": "When O(generate_ssh_key) is V(True)",
      "sample": "/home/asmith/.ssh/id_rsa",
      "type": "str"
     },
     "ssh_public_key": {
      "description": "Generated SSH public key file.",
      "returned": "When O(generate_ssh_key) is V(True)",
      "sample": "'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC95opt4SPEC06tOYsJQJIuN23BbLMGmYo8ysVZQc4h2DZE9ugbjWWGS1/pweUGjVstgzMkBEeBCByaEf/RJKNecKRPeGd2Bw9DCj/bn5Z6rGfNENKBmo 618mUJBvdlEgea96QGjOwSB7/gmonduC7gsWDMNcOdSE3wJMTim4lddiBx4RgC9yXsJ6Tkz9BHD73MXPpT5ETnse+A3fw3IGVSjaueVnlUyUmOBf7fzmZbhlFVXf2Zi2rFTXqvbdGHKkzpw1U8eB8xFPP7y d5u1u0e6Acju/8aZ/l17IDFiLke5IzlqIMRTEbDwLNeO84YQKWTm9fODHzhYe0yvxqLiK07 ansible-generated on host'\n",
      "type": "str"
     },
     "stderr": {
      "description": "Standard error from running commands.",
      "returned": "When stderr is returned by a command that is run",
      "sample": "Group wheels does not exist",
      "type": "str"
     },
     "stdout": {
      "description": "Standard output from running commands.",
      "returned": "When standard output is returned by the command that is run",
      "sample": null,
      "type": "str"
     },
     "system": {
      "description": "Whether or not the account is a system account.",
      "returned": "When O(system) is passed to the module and the account does not exist",
      "sample": true,
      "type": "bool"
     },
     "uid": {
      "description": "User ID of the user account.",
      "returned": "When O(uid) is passed to the module",
      "sample": 1044,
      "type": "int"
     }
    }
   },
   "ansible.builtin.validate_argument_spec": {
    "doc": {
     "attributes": {
      "action": {
       "description": "Indicates this has a corresponding action plugin so some parts of the options can be executed on the controller",
       "support": "full"
      },
      "async": {
       "description": "Supports being used with the C(async) keyword",
       "support": "none"
      },
      "become": {
       "description": "Is usable alongside become keywords",
       "support": "none"
      },
      "bypass_host_loop": {
       "description": [
        "Forces a 'global' task that does not execute per host, this bypasses per host templating and serial, throttle and other loop considerations",
        "Conditionals will work as if C(run_once) is being used, variables used will be from the first available host",
        "This action will not work normally outside of lockstep strategies"
       ],
       "support": "none"
      },
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "connection": {
       "description": "Uses the target's configured connection information to execute code on it",
       "support": "none"
      },
      "delegation": {
       "description": "Can be used in conjunction with delegate_to and related keywords",
       "support": "none"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "all",
       "support": "N/A"
      }
     },
     "author": [
      "Ansible Core Team"
     ],
     "collection": "ansible.builtin",
     "description": [
      "This module validates role arguments with a defined argument specification."
     ],
     "filename": "/ansible/modules/validate_argument_spec.py",
     "has_action": true,
     "module": "validate_argument_spec",
     "options": {
      "argument_spec": {
       "description": [
        "A dictionary like AnsibleModule argument_spec. See R(argument spec definition,argument_spec)"
       ],
       "required": true
      },
      "provided_arguments": {
       "description": [
        "A dictionary of the arguments that will be validated according to argument_spec"
       ]
      }
     },
     "short_description": "Validate role argument specs.",
     "version_added": "2.11",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: verify vars needed for this task file are present when included\n  ansible.builtin.validate_argument_spec:\n        argument_spec: '{{ required_data }}'\n  vars:\n    required_data:\n      # unlike spec file, just put the options in directly\n      stuff:\n        description: stuff\n        type: str\n        choices: ['who', 'knows', 'what']\n        default: what\n      but:\n        description: i guess we need one\n        type: str\n        required: true\n\n\n- name: verify vars needed for this task file are present when included, with spec from a spec file\n  ansible.builtin.validate_argument_spec:\n    argument_spec: \"{{ (lookup('ansible.builtin.file', 'myargspec.yml') | from_yaml )['specname']['options'] }}\"\n\n\n- name: verify vars needed for next include and not from inside it, also with params i'll only define there\n  block:\n    - ansible.builtin.validate_argument_spec:\n        argument_spec: \"{{ lookup('ansible.builtin.file', 'nakedoptions.yml') }}\"\n        provided_arguments:\n          but: \"that i can define on the include itself, like in it's `vars:` keyword\"\n\n    - name: the include itself\n      vars:\n        stuff: knows\n        but: nobuts!\n",
    "metadata": null,
    "return": {
     "argument_errors": {
      "description": "A list of arg validation errors.",
      "elements": "str",
      "returned": "failure",
      "sample": [
       "error message 1",
       "error message 2"
      ],
      "type": "list"
     },
     "argument_spec_data": {
      "description": "A dict of the data from the 'argument_spec' arg.",
      "returned": "failure",
      "sample": {
       "some_arg": {
        "type": "str"
       },
       "some_other_arg": {
        "required": true,
        "type": "int"
       }
      },
      "type": "dict"
     },
     "validate_args_context": {
      "description": "A dict of info about where validate_args_spec was used",
      "returned": "always",
      "sample": {
       "argument_spec_name": "main",
       "name": "my_role",
       "path": "/home/user/roles/my_role/",
       "type": "role"
      },
      "type": "dict"
     }
    }
   },
   "ansible.builtin.wait_for": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "none"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "N/A"
      }
     },
     "author": [
      "Jeroen Hoekx (@jhoekx)",
      "John Jarvis (@jarv)",
      "Andrii Radyk (@AnderEnder)"
     ],
     "collection": "ansible.builtin",
     "description": [
      "You can wait for a set amount of time O(timeout), this is the default if nothing is specified or just O(timeout) is specified. This does not produce an error.",
      "Waiting for a port to become available is useful for when services are not immediately available after their init scripts return which is true of certain Java application servers.",
      "It is also useful when starting guests with the M(community.libvirt.virt) module and needing to pause until they are ready.",
      "This module can also be used to wait for a regex match a string to be present in a file.",
      "In Ansible 1.6 and later, this module can also be used to wait for a file to be available or absent on the filesystem.",
      "In Ansible 1.8 and later, this module can also be used to wait for active connections to be closed before continuing, useful if a node is being rotated out of a load balancer pool.",
      "For Windows targets, use the M(ansible.windows.win_wait_for) module instead."
     ],
     "filename": "/ansible/modules/wait_for.py",
     "has_action": false,
     "module": "wait_for",
     "notes": [
      "The ability to use search_regex with a port connection was added in Ansible 1.7.",
      "Prior to Ansible 2.4, testing for the absence of a directory or UNIX socket did not work correctly.",
      "Prior to Ansible 2.4, testing for the presence of a file did not work correctly if the remote user did not have read access to that file.",
      "Under some circumstances when using mandatory access control, a path may always be treated as being absent even if it exists, but can't be modified or created by the remote user either.",
      "When waiting for a path, symbolic links will be followed.  Many other modules that manipulate files do not follow symbolic links, so operations on the path using other modules may not work exactly as expected."
     ],
     "options": {
      "active_connection_states": {
       "default": [
        "ESTABLISHED",
        "FIN_WAIT1",
        "FIN_WAIT2",
        "SYN_RECV",
        "SYN_SENT",
        "TIME_WAIT"
       ],
       "description": [
        "The list of TCP connection states which are counted as active connections."
       ],
       "elements": "str",
       "type": "list",
       "version_added": "2.3",
       "version_added_collection": "ansible.builtin"
      },
      "connect_timeout": {
       "default": 5,
       "description": [
        "Maximum number of seconds to wait for a connection to happen before closing and retrying."
       ],
       "type": "int"
      },
      "delay": {
       "default": 0,
       "description": [
        "Number of seconds to wait before starting to poll."
       ],
       "type": "int"
      },
      "exclude_hosts": {
       "description": [
        "List of hosts or IPs to ignore when looking for active TCP connections for V(drained) state."
       ],
       "elements": "str",
       "type": "list",
       "version_added": "1.8",
       "version_added_collection": "ansible.builtin"
      },
      "host": {
       "default": "127.0.0.1",
       "description": [
        "A resolvable hostname or IP address to wait for."
       ],
       "type": "str"
      },
      "msg": {
       "description": [
        "This overrides the normal error message from a failure to meet the required conditions."
       ],
       "type": "str",
       "version_added": "2.4",
       "version_added_collection": "ansible.builtin"
      },
      "path": {
       "description": [
        "Path to a file on the filesystem that must exist before continuing.",
        "O(path) and O(port) are mutually exclusive parameters."
       ],
       "type": "path",
       "version_added": "1.4",
       "version_added_collection": "ansible.builtin"
      },
      "port": {
       "description": [
        "Port number to poll.",
        "O(path) and O(port) are mutually exclusive parameters."
       ],
       "type": "int"
      },
      "search_regex": {
       "description": [
        "Can be used to match a string in either a file or a socket connection.",
        "Defaults to a multiline regex."
       ],
       "type": "str",
       "version_added": "1.4",
       "version_added_collection": "ansible.builtin"
      },
      "sleep": {
       "default": 1,
       "description": [
        "Number of seconds to sleep between checks.",
        "Before Ansible 2.3 this was hardcoded to 1 second."
       ],
       "type": "int",
       "version_added": "2.3",
       "version_added_collection": "ansible.builtin"
      },
      "state": {
       "choices": [
        "absent",
        "drained",
        "present",
        "started",
        "stopped"
       ],
       "default": "started",
       "description": [
        "Either V(present), V(started), or V(stopped), V(absent), or V(drained).",
        "When checking a port V(started) will ensure the port is open, V(stopped) will check that it is closed, V(drained) will check for active connections.",
        "When checking for a file or a search string V(present) or V(started) will ensure that the file or string is present before continuing, V(absent) will check that file is absent or removed."
       ],
       "type": "str"
      },
      "timeout": {
       "default": 300,
       "description": [
        "Maximum number of seconds to wait for, when used with another condition it will force an error.",
        "When used without other conditions it is equivalent of just sleeping."
       ],
       "type": "int"
      }
     },
     "seealso": [
      {
       "module": "ansible.builtin.wait_for_connection"
      },
      {
       "module": "ansible.windows.win_wait_for"
      },
      {
       "module": "community.windows.win_wait_for_process"
      }
     ],
     "short_description": "Waits for a condition before continuing",
     "version_added": "0.7",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Sleep for 300 seconds and continue with play\n  ansible.builtin.wait_for:\n    timeout: 300\n  delegate_to: localhost\n\n- name: Wait for port 8000 to become open on the host, don't start checking for 10 seconds\n  ansible.builtin.wait_for:\n    port: 8000\n    delay: 10\n\n- name: Waits for port 8000 of any IP to close active connections, don't start checking for 10 seconds\n  ansible.builtin.wait_for:\n    host: 0.0.0.0\n    port: 8000\n    delay: 10\n    state: drained\n\n- name: Wait for port 8000 of any IP to close active connections, ignoring connections for specified hosts\n  ansible.builtin.wait_for:\n    host: 0.0.0.0\n    port: 8000\n    state: drained\n    exclude_hosts: 10.2.1.2,10.2.1.3\n\n- name: Wait until the file /tmp/foo is present before continuing\n  ansible.builtin.wait_for:\n    path: /tmp/foo\n\n- name: Wait until the string \"completed\" is in the file /tmp/foo before continuing\n  ansible.builtin.wait_for:\n    path: /tmp/foo\n    search_regex: completed\n\n- name: Wait until regex pattern matches in the file /tmp/foo and print the matched group\n  ansible.builtin.wait_for:\n    path: /tmp/foo\n    search_regex: completed (?P<task>\\w+)\n  register: waitfor\n- ansible.builtin.debug:\n    msg: Completed {{ waitfor['match_groupdict']['task'] }}\n\n- name: Wait until the lock file is removed\n  ansible.builtin.wait_for:\n    path: /var/lock/file.lock\n    state: absent\n\n- name: Wait until the process is finished and pid was destroyed\n  ansible.builtin.wait_for:\n    path: /proc/3466/status\n    state: absent\n\n- name: Output customized message when failed\n  ansible.builtin.wait_for:\n    path: /tmp/foo\n    state: present\n    msg: Timeout to find file /tmp/foo\n\n# Do not assume the inventory_hostname is resolvable and delay 10 seconds at start\n- name: Wait 300 seconds for port 22 to become open and contain \"OpenSSH\"\n  ansible.builtin.wait_for:\n    port: 22\n    host: '{{ (ansible_ssh_host|default(ansible_host))|default(inventory_hostname) }}'\n    search_regex: OpenSSH\n    delay: 10\n  connection: local\n\n# Same as above but you normally have ansible_connection set in inventory, which overrides 'connection'\n- name: Wait 300 seconds for port 22 to become open and contain \"OpenSSH\"\n  ansible.builtin.wait_for:\n    port: 22\n    host: '{{ (ansible_ssh_host|default(ansible_host))|default(inventory_hostname) }}'\n    search_regex: OpenSSH\n    delay: 10\n  vars:\n    ansible_connection: local\n",
    "metadata": null,
    "return": {
     "elapsed": {
      "description": "The number of seconds that elapsed while waiting",
      "returned": "always",
      "sample": 23,
      "type": "int"
     },
     "match_groupdict": {
      "description": "Dictionary containing all the named subgroups of the match, keyed by the subgroup name, as returned by U(https://docs.python.org/3/library/re.html#re.MatchObject.groupdict)",
      "returned": "always",
      "sample": {
       "group": "match"
      },
      "type": "dict"
     },
     "match_groups": {
      "description": "Tuple containing all the subgroups of the match as returned by U(https://docs.python.org/3/library/re.html#re.MatchObject.groups)",
      "returned": "always",
      "sample": [
       "match 1",
       "match 2"
      ],
      "type": "list"
     }
    }
   },
   "ansible.builtin.wait_for_connection": {
    "doc": {
     "attributes": {
      "action": {
       "description": "Indicates this has a corresponding action plugin so some parts of the options can be executed on the controller",
       "support": "full"
      },
      "async": {
       "description": "Supports being used with the C(async) keyword",
       "support": "none"
      },
      "bypass_host_loop": {
       "description": [
        "Forces a 'global' task that does not execute per host, this bypasses per host templating and serial, throttle and other loop considerations",
        "Conditionals will work as if C(run_once) is being used, variables used will be from the first available host",
        "This action will not work normally outside of lockstep strategies"
       ],
       "support": "none"
      },
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "none"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "none"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "details": "As long as there is a connection plugin",
       "platforms": "all",
       "support": "N/A"
      }
     },
     "author": [
      "Dag Wieers (@dagwieers)"
     ],
     "collection": "ansible.builtin",
     "description": [
      "Waits for a total of O(timeout) seconds.",
      "Retries the transport connection after a timeout of O(connect_timeout).",
      "Tests the transport connection every O(sleep) seconds.",
      "This module makes use of internal ansible transport (and configuration) and the ping/win_ping module to guarantee correct end-to-end functioning.",
      "This module is also supported for Windows targets."
     ],
     "filename": "/ansible/modules/wait_for_connection.py",
     "has_action": true,
     "module": "wait_for_connection",
     "options": {
      "connect_timeout": {
       "default": 5,
       "description": [
        "Maximum number of seconds to wait for a connection to happen before closing and retrying."
       ],
       "type": "int"
      },
      "delay": {
       "default": 0,
       "description": [
        "Number of seconds to wait before starting to poll."
       ],
       "type": "int"
      },
      "sleep": {
       "default": 1,
       "description": [
        "Number of seconds to sleep between checks."
       ],
       "type": "int"
      },
      "timeout": {
       "default": 600,
       "description": [
        "Maximum number of seconds to wait for."
       ],
       "type": "int"
      }
     },
     "seealso": [
      {
       "module": "ansible.builtin.wait_for"
      },
      {
       "module": "ansible.windows.win_wait_for"
      },
      {
       "module": "community.windows.win_wait_for_process"
      }
     ],
     "short_description": "Waits until remote system is reachable/usable",
     "version_added": "2.3",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Wait 600 seconds for target connection to become reachable/usable\n  ansible.builtin.wait_for_connection:\n\n- name: Wait 300 seconds, but only start checking after 60 seconds\n  ansible.builtin.wait_for_connection:\n    delay: 60\n    timeout: 300\n\n# Wake desktops, wait for them to become ready and continue playbook\n- hosts: all\n  gather_facts: no\n  tasks:\n  - name: Send magic Wake-On-Lan packet to turn on individual systems\n    community.general.wakeonlan:\n      mac: '{{ mac }}'\n      broadcast: 192.168.0.255\n    delegate_to: localhost\n\n  - name: Wait for system to become reachable\n    ansible.builtin.wait_for_connection:\n\n  - name: Gather facts for first time\n    ansible.builtin.setup:\n\n# Build a new VM, wait for it to become ready and continue playbook\n- hosts: all\n  gather_facts: no\n  tasks:\n  - name: Clone new VM, if missing\n    community.vmware.vmware_guest:\n      hostname: '{{ vcenter_ipaddress }}'\n      name: '{{ inventory_hostname_short }}'\n      template: Windows 2012R2\n      customization:\n        hostname: '{{ vm_shortname }}'\n        runonce:\n        - cmd.exe /c winrm.cmd quickconfig -quiet -force\n    delegate_to: localhost\n\n  - name: Wait for system to become reachable over WinRM\n    ansible.builtin.wait_for_connection:\n      timeout: 900\n\n  - name: Gather facts for first time\n    ansible.builtin.setup:\n",
    "metadata": null,
    "return": {
     "elapsed": {
      "description": "The number of seconds that elapsed waiting for the connection to appear.",
      "returned": "always",
      "sample": 23.1,
      "type": "float"
     }
    }
   },
   "ansible.builtin.yum_repository": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target, if not supported the action will be skipped.",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "full"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "rhel",
       "support": "N/A"
      }
     },
     "author": "Jiri Tyr (@jtyr)",
     "collection": "ansible.builtin",
     "description": [
      "Add or remove YUM repositories in RPM-based Linux distributions.",
      "If you wish to update an existing repository definition use M(community.general.ini_file) instead."
     ],
     "filename": "/ansible/modules/yum_repository.py",
     "has_action": false,
     "module": "yum_repository",
     "notes": [
      "All comments will be removed if modifying an existing repo file.",
      "Section order is preserved in an existing repo file.",
      "Parameters in a section are ordered alphabetically in an existing repo file.",
      "The repo file will be automatically deleted if it contains no repository.",
      "When removing a repository, beware that the metadata cache may still remain on disk until you run C(yum clean all). Use a notification handler for this.",
      "The O(ignore:params) parameter was removed in Ansible 2.5 due to circumventing Ansible's parameter handling"
     ],
     "options": {
      "async": {
       "description": [
        "If set to V(true) Yum will download packages and metadata from this repo in parallel, if possible.",
        "In ansible-core 2.11, 2.12, and 2.13 the default value is V(true).",
        "This option has been deprecated in RHEL 8. If you're using one of the versions listed above, you can set this option to None to avoid passing an unknown configuration option."
       ],
       "type": "bool"
      },
      "attributes": {
       "aliases": [
        "attr"
       ],
       "description": [
        "The attributes the resulting filesystem object should have.",
        "To get supported flags look at the man page for I(chattr) on the target system.",
        "This string should contain the attributes in the same order as the one displayed by I(lsattr).",
        "The C(=) operator is assumed as default, otherwise C(+) or C(-) operators need to be included in the string."
       ],
       "type": "str",
       "version_added": "2.3",
       "version_added_collection": "ansible.builtin"
      },
      "bandwidth": {
       "description": [
        "Maximum available network bandwidth in bytes/second. Used with the O(throttle) option.",
        "If O(throttle) is a percentage and bandwidth is V(0) then bandwidth throttling will be disabled. If O(throttle) is expressed as a data rate (bytes/sec) then this option is ignored. Default is V(0) (no bandwidth throttling)."
       ],
       "type": "str"
      },
      "baseurl": {
       "description": [
        "URL to the directory where the yum repository's 'repodata' directory lives.",
        "It can also be a list of multiple URLs.",
        "This, the O(metalink) or O(mirrorlist) parameters are required if O(state) is set to V(present)."
       ],
       "elements": "str",
       "type": "list"
      },
      "cost": {
       "description": [
        "Relative cost of accessing this repository. Useful for weighing one repo's packages as greater/less than any other."
       ],
       "type": "str"
      },
      "deltarpm_metadata_percentage": {
       "description": [
        "When the relative size of deltarpm metadata vs pkgs is larger than this, deltarpm metadata is not downloaded from the repo. Note that you can give values over V(100), so V(200) means that the metadata is required to be half the size of the packages. Use V(0) to turn off this check, and always download metadata."
       ],
       "type": "str"
      },
      "deltarpm_percentage": {
       "description": [
        "When the relative size of delta vs pkg is larger than this, delta is not used. Use V(0) to turn off delta rpm processing. Local repositories (with file://O(baseurl)) have delta rpms turned off by default."
       ],
       "type": "str"
      },
      "description": {
       "description": [
        "A human-readable string describing the repository. This option corresponds to the \"name\" property in the repo file.",
        "This parameter is only required if O(state) is set to V(present)."
       ],
       "type": "str"
      },
      "enabled": {
       "description": [
        "This tells yum whether or not use this repository.",
        "Yum default value is V(true)."
       ],
       "type": "bool"
      },
      "enablegroups": {
       "description": [
        "Determines whether yum will allow the use of package groups for this repository.",
        "Yum default value is V(true)."
       ],
       "type": "bool"
      },
      "exclude": {
       "description": [
        "List of packages to exclude from updates or installs. This should be a space separated list. Shell globs using wildcards (for example V(*) and V(?)) are allowed.",
        "The list can also be a regular YAML array."
       ],
       "elements": "str",
       "type": "list"
      },
      "failovermethod": {
       "choices": [
        "roundrobin",
        "priority"
       ],
       "description": [
        "V(roundrobin) randomly selects a URL out of the list of URLs to start with and proceeds through each of them as it encounters a failure contacting the host.",
        "V(priority) starts from the first O(baseurl) listed and reads through them sequentially."
       ],
       "type": "str"
      },
      "file": {
       "description": [
        "File name without the C(.repo) extension to save the repo in. Defaults to the value of O(name)."
       ],
       "type": "str"
      },
      "gpgcakey": {
       "description": [
        "A URL pointing to the ASCII-armored CA key file for the repository."
       ],
       "type": "str"
      },
      "gpgcheck": {
       "description": [
        "Tells yum whether or not it should perform a GPG signature check on packages.",
        "No default setting. If the value is not set, the system setting from C(/etc/yum.conf) or system default of V(false) will be used."
       ],
       "type": "bool"
      },
      "gpgkey": {
       "description": [
        "A URL pointing to the ASCII-armored GPG key file for the repository.",
        "It can also be a list of multiple URLs."
       ],
       "elements": "str",
       "type": "list"
      },
      "group": {
       "description": [
        "Name of the group that should own the filesystem object, as would be fed to I(chown).",
        "When left unspecified, it uses the current group of the current user unless you are root, in which case it can preserve the previous ownership."
       ],
       "type": "str"
      },
      "http_caching": {
       "choices": [
        "all",
        "packages",
        "none"
       ],
       "description": [
        "Determines how upstream HTTP caches are instructed to handle any HTTP downloads that Yum does.",
        "V(all) means that all HTTP downloads should be cached.",
        "V(packages) means that only RPM package downloads should be cached (but not repository metadata downloads).",
        "V(none) means that no HTTP downloads should be cached."
       ],
       "type": "str"
      },
      "include": {
       "description": [
        "Include external configuration file. Both, local path and URL is supported. Configuration file will be inserted at the position of the C(include=) line. Included files may contain further include lines. Yum will abort with an error if an inclusion loop is detected."
       ],
       "type": "str"
      },
      "includepkgs": {
       "description": [
        "List of packages you want to only use from a repository. This should be a space separated list. Shell globs using wildcards (for example V(*) and V(?)) are allowed. Substitution variables (for example V($releasever)) are honored here.",
        "The list can also be a regular YAML array."
       ],
       "elements": "str",
       "type": "list"
      },
      "ip_resolve": {
       "choices": [
        "4",
        "6",
        "IPv4",
        "IPv6",
        "whatever"
       ],
       "description": [
        "Determines how yum resolves host names.",
        "V(4) or V(IPv4) - resolve to IPv4 addresses only.",
        "V(6) or V(IPv6) - resolve to IPv6 addresses only."
       ],
       "type": "str"
      },
      "keepalive": {
       "description": [
        "This tells yum whether or not HTTP/1.1 keepalive should be used with this repository. This can improve transfer speeds by using one connection when downloading multiple files from a repository."
       ],
       "type": "bool"
      },
      "keepcache": {
       "choices": [
        "0",
        "1"
       ],
       "description": [
        "Either V(1) or V(0). Determines whether or not yum keeps the cache of headers and packages after successful installation.",
        "This parameter is deprecated and will be removed in version 2.20."
       ],
       "type": "str"
      },
      "metadata_expire": {
       "description": [
        "Time (in seconds) after which the metadata will expire.",
        "Default value is 6 hours."
       ],
       "type": "str"
      },
      "metadata_expire_filter": {
       "choices": [
        "never",
        "read-only:past",
        "read-only:present",
        "read-only:future"
       ],
       "description": [
        "Filter the O(metadata_expire) time, allowing a trade of speed for accuracy if a command doesn't require it. Each yum command can specify that it requires a certain level of timeliness quality from the remote repos. from \"I'm about to install/upgrade, so this better be current\" to \"Anything that's available is good enough\".",
        "V(never) - Nothing is filtered, always obey O(metadata_expire).",
        "V(read-only:past) - Commands that only care about past information are filtered from metadata expiring. Eg. C(yum history) info (if history needs to lookup anything about a previous transaction, then by definition the remote package was available in the past).",
        "V(read-only:present) - Commands that are balanced between past and future. Eg. C(yum list yum).",
        "V(read-only:future) - Commands that are likely to result in running other commands which will require the latest metadata. Eg. C(yum check-update).",
        "Note that this option does not override \"yum clean expire-cache\"."
       ],
       "type": "str"
      },
      "metalink": {
       "description": [
        "Specifies a URL to a metalink file for the repomd.xml, a list of mirrors for the entire repository are generated by converting the mirrors for the repomd.xml file to a O(baseurl).",
        "This, the O(baseurl) or O(mirrorlist) parameters are required if O(state) is set to V(present)."
       ],
       "type": "str"
      },
      "mirrorlist": {
       "description": [
        "Specifies a URL to a file containing a list of baseurls.",
        "This, the O(baseurl) or O(metalink) parameters are required if O(state) is set to V(present)."
       ],
       "type": "str"
      },
      "mirrorlist_expire": {
       "description": [
        "Time (in seconds) after which the mirrorlist locally cached will expire.",
        "Default value is 6 hours."
       ],
       "type": "str"
      },
      "mode": {
       "description": [
        "The permissions the resulting filesystem object should have.",
        "For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must give Ansible enough information to parse them correctly. For consistent results, quote octal numbers (for example, V('644') or V('1777')) so Ansible receives a string and can do its own conversion from string into number. Adding a leading zero (for example, V(0755)) works sometimes, but can fail in loops and some other circumstances.",
        "Giving Ansible a number without following either of these rules will end up with a decimal number which will have unexpected results.",
        "As of Ansible 1.8, the mode may be specified as a symbolic mode (for example, V(u+rwx) or V(u=rw,g=r,o=r)).",
        "If O(mode) is not specified and the destination filesystem object B(does not) exist, the default C(umask) on the system will be used when setting the mode for the newly created filesystem object.",
        "If O(mode) is not specified and the destination filesystem object B(does) exist, the mode of the existing filesystem object will be used.",
        "Specifying O(mode) is the best way to ensure filesystem objects are created with the correct permissions. See CVE-2020-1736 for further details."
       ],
       "type": "raw"
      },
      "module_hotfixes": {
       "description": [
        "Disable module RPM filtering and make all RPMs from the repository available. The default is V(None)."
       ],
       "type": "bool",
       "version_added": "2.11",
       "version_added_collection": "ansible.builtin"
      },
      "name": {
       "description": [
        "Unique repository ID. This option builds the section name of the repository in the repo file.",
        "This parameter is only required if O(state) is set to V(present) or V(absent)."
       ],
       "required": true,
       "type": "str"
      },
      "owner": {
       "description": [
        "Name of the user that should own the filesystem object, as would be fed to I(chown).",
        "When left unspecified, it uses the current user unless you are root, in which case it can preserve the previous ownership.",
        "Specifying a numeric username will be assumed to be a user ID and not a username. Avoid numeric usernames to avoid this confusion."
       ],
       "type": "str"
      },
      "password": {
       "description": [
        "Password to use with the username for basic authentication."
       ],
       "type": "str"
      },
      "priority": {
       "description": [
        "Enforce ordered protection of repositories. The value is an integer from 1 to 99.",
        "This option only works if the YUM Priorities plugin is installed."
       ],
       "type": "str"
      },
      "protect": {
       "description": [
        "Protect packages from updates from other repositories."
       ],
       "type": "bool"
      },
      "proxy": {
       "description": [
        "URL to the proxy server that yum should use. Set to V(_none_) to disable the global proxy setting."
       ],
       "type": "str"
      },
      "proxy_password": {
       "description": [
        "Password for this proxy."
       ],
       "type": "str"
      },
      "proxy_username": {
       "description": [
        "Username to use for proxy."
       ],
       "type": "str"
      },
      "repo_gpgcheck": {
       "description": [
        "This tells yum whether or not it should perform a GPG signature check on the repodata from this repository."
       ],
       "type": "bool"
      },
      "reposdir": {
       "default": "/etc/yum.repos.d",
       "description": [
        "Directory where the C(.repo) files will be stored."
       ],
       "type": "path"
      },
      "retries": {
       "description": [
        "Set the number of times any attempt to retrieve a file should retry before returning an error. Setting this to V(0) makes yum try forever."
       ],
       "type": "str"
      },
      "s3_enabled": {
       "description": [
        "Enables support for S3 repositories.",
        "This option only works if the YUM S3 plugin is installed."
       ],
       "type": "bool"
      },
      "selevel": {
       "description": [
        "The level part of the SELinux filesystem object context.",
        "This is the MLS/MCS attribute, sometimes known as the C(range).",
        "When set to V(_default), it will use the C(level) portion of the policy if available."
       ],
       "type": "str"
      },
      "serole": {
       "description": [
        "The role part of the SELinux filesystem object context.",
        "When set to V(_default), it will use the C(role) portion of the policy if available."
       ],
       "type": "str"
      },
      "setype": {
       "description": [
        "The type part of the SELinux filesystem object context.",
        "When set to V(_default), it will use the C(type) portion of the policy if available."
       ],
       "type": "str"
      },
      "seuser": {
       "description": [
        "The user part of the SELinux filesystem object context.",
        "By default it uses the V(system) policy, where applicable.",
        "When set to V(_default), it will use the C(user) portion of the policy if available."
       ],
       "type": "str"
      },
      "skip_if_unavailable": {
       "description": [
        "If set to V(true) yum will continue running if this repository cannot be contacted for any reason. This should be set carefully as all repos are consulted for any given command."
       ],
       "type": "bool"
      },
      "ssl_check_cert_permissions": {
       "description": [
        "Whether yum should check the permissions on the paths for the certificates on the repository (both remote and local).",
        "If we can't read any of the files then yum will force O(skip_if_unavailable) to be V(true). This is most useful for non-root processes which use yum on repos that have client cert files which are readable only by root."
       ],
       "type": "bool"
      },
      "sslcacert": {
       "aliases": [
        "ca_cert"
       ],
       "description": [
        "Path to the directory containing the databases of the certificate authorities yum should use to verify SSL certificates."
       ],
       "type": "str"
      },
      "sslclientcert": {
       "aliases": [
        "client_cert"
       ],
       "description": [
        "Path to the SSL client certificate yum should use to connect to repos/remote sites."
       ],
       "type": "str"
      },
      "sslclientkey": {
       "aliases": [
        "client_key"
       ],
       "description": [
        "Path to the SSL client key yum should use to connect to repos/remote sites."
       ],
       "type": "str"
      },
      "sslverify": {
       "aliases": [
        "validate_certs"
       ],
       "description": [
        "Defines whether yum should verify SSL certificates/hosts at all."
       ],
       "type": "bool"
      },
      "state": {
       "choices": [
        "absent",
        "present"
       ],
       "default": "present",
       "description": [
        "State of the repo file."
       ],
       "type": "str"
      },
      "throttle": {
       "description": [
        "Enable bandwidth throttling for downloads.",
        "This option can be expressed as a absolute data rate in bytes/sec. An SI prefix (k, M or G) may be appended to the bandwidth value."
       ],
       "type": "str"
      },
      "timeout": {
       "description": [
        "Number of seconds to wait for a connection before timing out."
       ],
       "type": "str"
      },
      "ui_repoid_vars": {
       "description": [
        "When a repository id is displayed, append these yum variables to the string if they are used in the O(baseurl)/etc. Variables are appended in the order listed (and found)."
       ],
       "type": "str"
      },
      "unsafe_writes": {
       "default": false,
       "description": [
        "Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target filesystem object.",
        "By default this module uses atomic operations to prevent data corruption or inconsistent reads from the target filesystem objects, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted filesystem objects, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.",
        "This option allows Ansible to fall back to unsafe methods of updating filesystem objects when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes).",
        "IMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption."
       ],
       "type": "bool",
       "version_added": "2.2",
       "version_added_collection": "ansible.builtin"
      },
      "username": {
       "description": [
        "Username to use for basic authentication to a repo or really any url."
       ],
       "type": "str"
      }
     },
     "short_description": "Add or remove YUM repositories",
     "version_added": "2.1",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "\n- name: Add repository\n  ansible.builtin.yum_repository:\n    name: epel\n    description: EPEL YUM repo\n    baseurl: https://download.fedoraproject.org/pub/epel/$releasever/$basearch/\n\n- name: Add multiple repositories into the same file (1/2)\n  ansible.builtin.yum_repository:\n    name: epel\n    description: EPEL YUM repo\n    file: external_repos\n    baseurl: https://download.fedoraproject.org/pub/epel/$releasever/$basearch/\n    gpgcheck: no\n\n- name: Add multiple repositories into the same file (2/2)\n  ansible.builtin.yum_repository:\n    name: rpmforge\n    description: RPMforge YUM repo\n    file: external_repos\n    baseurl: http://apt.sw.be/redhat/el7/en/$basearch/rpmforge\n    mirrorlist: http://mirrorlist.repoforge.org/el7/mirrors-rpmforge\n    enabled: no\n\n# Handler showing how to clean yum metadata cache\n- name: yum-clean-metadata\n  ansible.builtin.command: yum clean metadata\n\n# Example removing a repository and cleaning up metadata cache\n- name: Remove repository (and clean up left-over metadata)\n  ansible.builtin.yum_repository:\n    name: epel\n    state: absent\n  notify: yum-clean-metadata\n\n- name: Remove repository from a specific repo file\n  ansible.builtin.yum_repository:\n    name: epel\n    file: external_repos\n    state: absent\n",
    "metadata": null,
    "return": {
     "repo": {
      "description": "repository name",
      "returned": "success",
      "sample": "epel",
      "type": "str"
     },
     "state": {
      "description": "state of the target, after execution",
      "returned": "success",
      "sample": "present",
      "type": "str"
     }
    }
   },
   "ns.col2.foo": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "full"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "details": [
        "The module M(boo) is not using an FQCN.",
        "Sometimes our markup is B(broken."
       ],
       "platforms": "posix",
       "support": "N/A"
      }
     },
     "author": [
      "Someone else (@ansible)"
     ],
     "collection": "ns.col2",
     "description": [
      "Does some foo on the remote host.",
      "A broken reference R(asdfasdfoobarTHISDOESNOTEXIST,asdfasdfoobarTHISDOESNOTEXIST).",
      "The option O(foo) exists, but O(foobar) does not.",
      "The return value RV(bar) exists, but RV(barbaz) does not.",
      "Again existing: O(ns.col2.foo#module:foo=1), RV(ns.col2.foo#module:bar=2)",
      "Again not existing: O(ns.col2.foo#module:foobar=1), RV(ns.col2.foo#module:barbaz=2)"
     ],
     "filename": "ansible_collections/ns/col2/plugins/modules/foo.py",
     "has_action": false,
     "module": "foo",
     "options": {
      "bar": {
       "description": [
        {
         "A bar": [
          "foo",
          "bar",
          "baz"
         ]
        },
        true,
        42
       ],
       "type": "list of ints"
      },
      "foo": "The foo source.",
      "subfoo": {
       "bam": "baz",
       "description": "Some recursive foo.",
       "suboptions": {
        "foo": {
         "description": [
          "A sub foo.",
          "Whatever.",
          "Also required when I(subfoo) is specified when I(foo=bar) or C(baz)."
         ],
         "required": true,
         "type": "str"
        }
       },
       "type": "dict"
      }
     },
     "requirements": "Foo.",
     "seealso": {
      "foo": "bar"
     },
     "version_added": "foo",
     "version_added_collection": "ns.col2"
    },
    "examples": "\nThis is not YAML.\n",
    "metadata": null,
    "return": {
     "bar": {
      "description": "Some bar.",
      "returned": "success",
      "sample": "baz",
      "type": "string or so"
     },
     "baz": "baz!"
    }
   },
   "ns.col2.foo2": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "full"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "details": [
        "The module M(boo) is not using an FQCN.",
        "Sometimes our markup is B(broken."
       ],
       "platforms": "posix",
       "support": "N/A"
      }
     },
     "author": [
      "Someone else (@ansible)"
     ],
     "collection": "ns.col2",
     "description": [
      "Does some foo on the remote host.",
      "A broken reference R(asdfasdfoobarTHISDOESNOTEXIST,asdfasdfoobarTHISDOESNOTEXIST).",
      "The option O(foo) exists, but O(foobar) does not.",
      "The return value RV(bar) exists, but RV(barbaz) does not.",
      "Again existing: O(ns.col2.foo#module:foo=1), RV(ns.col2.foo#module:bar=2)",
      "Again not existing: O(ns.col2.foo#module:foobar=1), RV(ns.col2.foo#module:barbaz=2)"
     ],
     "filename": "ansible_collections/ns/col2/plugins/modules/foo2.py",
     "has_action": false,
     "module": "foo2",
     "options": {
      "bar": {
       "description": [
        "Bar.",
        "Some O(broken markup)."
       ],
       "elements": "int",
       "type": "list"
      },
      "foo": {
       "description": "The foo source.",
       "type": "str"
      },
      "subfoo": {
       "description": "Some recursive foo.",
       "suboptions": {
        "BaZ": {
         "description": "Funky.",
         "type": "int"
        },
        "foo": {
         "description": [
          "A sub foo.",
          "Whatever.",
          "Also required when I(subfoo) is specified when I(foo=bar) or C(baz).",
          "RV(foobarbaz) does not exist."
         ],
         "required": true,
         "type": "str"
        }
       },
       "type": "dict"
      }
     },
     "requirements": "Foo.",
     "seealso": [
      {
       "module": "ns.col2.foo3"
      },
      {
       "module": "ns.col2.foobarbaz"
      },
      {
       "plugin": "ns.col2.foo4",
       "plugin_type": "module"
      },
      {
       "plugin": "ns.col2.foobarbaz",
       "plugin_type": "inventory"
      },
      {
       "description": "The service module.",
       "module": "ansible.builtin.service"
      },
      {
       "description": "A non-existing module.",
       "module": "ansible.builtin.foobarbaz"
      },
      {
       "description": "The linear strategy plugin.",
       "plugin": "ansible.builtin.linear",
       "plugin_type": "strategy"
      },
      {
       "description": "A non-existing stragey plugin",
       "plugin": "ansible.builtin.foobarbaz",
       "plugin_type": "strategy"
      }
     ],
     "short_description": "Foo two"
    },
    "examples": "\nname: This is YAML.\n",
    "metadata": null,
    "return": {
     "bar": {
      "description": "Some bar.",
      "returned": "success",
      "sample": "baz",
      "type": "string"
     }
    }
   },
   "ns.col2.foo3": {
    "doc": {
     "attributes": {
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "full"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "N/A"
      }
     },
     "author": [
      "Someone else (@ansible)"
     ],
     "collection": "ns.col2",
     "description": [
      "Does some foo on the remote host."
     ],
     "filename": "ansible_collections/ns/col2/plugins/modules/foo3.py",
     "has_action": false,
     "module": "foo3",
     "options": {
      "bar": {
       "description": [
        "Bar."
       ],
       "elements": "int",
       "type": "list"
      },
      "foo": {
       "description": "The foo source.",
       "type": "str"
      },
      "subfoo": {
       "description": "Some recursive foo.",
       "suboptions": {
        "foo": {
         "description": [
          "A sub foo.",
          "Whatever.",
          "Also required when I(subfoo) is specified when I(foo=bar) or C(baz)."
         ],
         "required": true,
         "type": "str"
        }
       },
       "type": "dict"
      }
     },
     "requirements": "Foo.",
     "short_description": "Foo III"
    },
    "examples": "\nThis is not YAML.\n",
    "metadata": null,
    "return": {
     "bar": {
      "description": "Some bar.",
      "returned": "success",
      "sample": "baz",
      "type": "string or so"
     },
     "baz": "baz!"
    }
   },
   "ns.col2.foo4": {
    "doc": {
     "author": [
      "Nobody (@ansible)"
     ],
     "collection": "ns.col2",
     "description": [],
     "filename": "ansible_collections/ns/col2/plugins/modules/foo4.py",
     "has_action": false,
     "module": "foo4",
     "options": {
      "correct_array_stubs": {
       "description": [
        "O(ansible.builtin.iptables#module:tcp_flags.flags[])",
        "O(ns2.col.bar#filter:foo)",
        "O(ns2.col.bar#filter:foo[])",
        "O(ext.col.foo#module:foo[baz].bar)",
        "RV(ext.col.foo#module:baz)",
        "RV(ext.col.foo#module:baz[ ])",
        "RV(ansible.builtin.stat#module:stat[foo.bar])"
       ]
      },
      "existing": {
       "description": [
        "M(ansible.builtin.service)",
        "P(ansible.builtin.pipe#lookup)",
        "O(ansible.builtin.file#module:state)",
        "RV(ansible.builtin.stat#module:stat.exists)",
        "M(ns2.flatcol.foo)",
        "P(ns2.flatcol.sub.foo2#module)",
        "O(ns2.flatcol.foo#module:subbaz.bam)",
        "RV(ns2.flatcol.sub.foo2#module:bar)",
        "M(ns2.col.foo2)",
        "P(ns2.col.foo#lookup)",
        "O(ns2.col.bar#filter:foo[-1])",
        "RV(ns2.col.bar#test:_value)",
        "M(ns.col2.foo2)",
        "P(ns.col2.foo2#module)",
        "O(ns.col2.foo2#module:subfoo.foo)",
        "RV(ns.col2.foo2#module:bar)",
        "M(ext.col.foo)",
        "P(ext.col.bar#lookup)",
        "O(ext.col.foo#module:foo[len(foo\\)].bar)",
        "RV(ext.col.foo#module:baz[])",
        "O(ns.col2.foo2#module:subfoo.BaZ)"
       ]
      },
      "incorrect_array_stubs": {
       "description": [
        "O(ansible.builtin.file#module:state[])",
        "RV(ansible.builtin.stat#module:stat[foo.bar].exists)",
        "RV(ansible.builtin.stat#module:stat.exists[])",
        "O(ns.col2.foo2#module:subfoo[)",
        "RV(ns.col2.foo2#module:bar[])",
        "O(ext.col.foo#module:foo.bar)"
       ]
      },
      "not_existing": {
       "description": [
        "M(ansible.builtin.foobar)",
        "P(ansible.builtin.bazbam#lookup)",
        "O(ansible.builtin.file#module:foobarbaz)",
        "RV(ansible.builtin.stat#module:baz.bam[])",
        "O(ansible.builtin.foobar#module:state)",
        "RV(ansible.builtin.bazbam#module:stat.exists)",
        "M(ns2.flatcol.foobarbaz)",
        "P(ns2.flatcol.sub.bazbam#module)",
        "O(ns2.flatcol.foo#module:foofoofoobar)",
        "RV(ns2.flatcol.sub.foo2#module:bazbarbam)",
        "O(ns2.flatcol.foobar#module:subbaz.bam)",
        "RV(ns2.flatcol.sub.bazbam#module:bar)",
        "M(ns2.col.joo)",
        "P(ns2.col.joo#lookup)",
        "O(ns2.col.bar#filter:jooo)",
        "RV(ns2.col.bar#test:booo)",
        "O(ns2.col.joo#filter:foo[-1])",
        "RV(ns2.col.joo#test:_value)",
        "M(ns.col2.foobarbaz)",
        "P(ns.col2.foobarbam#filter)",
        "O(ns.col2.foo2#module:barbazbam.foo)",
        "RV(ns.col2.foo2#module:bambazbar)",
        "O(ns.col2.foofoo#test:subfoo.foo)",
        "RV(ns.col2.foofoo#lookup:baz)",
        "M(ext.col.notthere)",
        "P(ext.col.notthere#lookup)",
        "O(ext.col.foo#module:foo[len(foo\\)].notthere)",
        "O(ext.col.foo#module:notthere[len(notthere\\)].bar)",
        "RV(ext.col.foo#module:notthere[])",
        "O(ext.col.notthere#module:foo[len(foo\\)].bar)",
        "RV(ext.col.notthere#module:baz[])"
       ]
      }
     },
     "short_description": "Markup reference linting test"
    },
    "examples": null,
    "metadata": null,
    "return": null
   },
   "ns2.col.foo": {
    "doc": {
     "attributes": {
      "action_group": {
       "description": "Use C(group/ns2.col.foo_group) in C(module_defaults) to set defaults for this module.",
       "membership": [
        "ns2.col.foo_group"
       ],
       "support": "full"
      },
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "full"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "N/A"
      }
     },
     "author": [
      "Ansible Core Team",
      "Someone else (@ansible)"
     ],
     "collection": "ns2.col",
     "description": [
      "Does some foo on the remote host.",
      "Whether foo is magic or not has not yet been determined.",
      "E(FOOBAR1), E(FOOBAR2), E(FOOBAR3), E(FOOBAR4)."
     ],
     "filename": "ansible_collections/ns2/col/plugins/modules/foo.py",
     "has_action": false,
     "module": "foo",
     "options": {
      "bar": {
       "aliases": [
        "baz"
       ],
       "description": [
        "A bar.",
        "Independent from O(foo).",
        "Do not confuse with RV(bar)."
       ],
       "elements": "int",
       "type": "list"
      },
      "foo": {
       "description": "The foo source.",
       "required": true,
       "type": "str"
      },
      "subfoo": {
       "description": "Some recursive foo.",
       "suboptions": {
        "foo": {
         "description": [
          "A sub foo.",
          "Whatever.",
          "Also required when O(subfoo) is specified when O(foo=bar) or V(baz)."
         ],
         "required": true,
         "type": "str"
        }
       },
       "type": "dict",
       "version_added": "2.0.0",
       "version_added_collection": "ns2.col"
      }
     },
     "requirements": [
      "Foo on remote."
     ],
     "seealso": [
      {
       "module": "ns2.col.foo2"
      },
      {
       "plugin": "ns2.col.foo",
       "plugin_type": "lookup"
      },
      {
       "description": "The service module.",
       "module": "ansible.builtin.service"
      },
      {
       "description": "The ssh connection plugin.",
       "plugin": "ansible.builtin.ssh",
       "plugin_type": "connection"
      }
     ],
     "short_description": "Do some foo O(bar)",
     "version_added": "2.0.0",
     "version_added_collection": "ns2.col"
    },
    "examples": "\n- name: Do some foo\n  ns2.col.foo:\n    foo: '{{ foo }}'\n    bar:\n      - 1\n      - 2\n      - 3\n    subfoo:\n      foo: hoo!\n",
    "metadata": null,
    "return": {
     "bar": {
      "description": [
       "Some bar.",
       "Referencing myself as RV(bar).",
       "Do not confuse with O(bar)."
      ],
      "returned": "success",
      "sample": "baz",
      "type": "str"
     }
    }
   },
   "ns2.col.foo2": {
    "doc": {
     "attributes": {
      "action_group": {
       "description": "Use C(group/ns2.col.foo_group) or C(group/ns2.col.bar_group) in C(module_defaults) to set defaults for this module.",
       "membership": [
        "ns2.col.bar_group",
        "ns2.col.foo_group"
       ],
       "support": "full"
      },
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "N/A"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "partial"
      }
     },
     "author": [
      "Another one (@ansible-community)"
     ],
     "collection": "ns2.col",
     "description": [
      "Foo bar.",
      "See O(ns2.col.foo#role:main:foo_param_1) for a random role parameter reference. And O(ns2.col.foo#role:main:foo_param_2=42) for one with a value.",
      "Reference using alias - O(ns2.col.foo_redirect#module:bar) and O(ns2.col.foo_redirect#module:baz)."
     ],
     "filename": "ansible_collections/ns2/col/plugins/modules/foo2.py",
     "has_action": false,
     "module": "foo2",
     "options": {
      "bar": {
       "description": [
        "Some bar.",
        "See O(ns2.col.foo#role:main:foo_param_1) for a random role parameter reference. And O(ns2.col.foo#role:main:foo_param_2=42) for one with a value."
       ],
       "type": "str"
      }
     },
     "short_description": "Another foo"
    },
    "examples": "\n- name: Do some foo\n  ns2.col.foo2:\n    bar: foo\n",
    "metadata": null,
    "return": {
     "bar": {
      "description": [
       "Some bar.",
       "Referencing myself as RV(bar).",
       "Do not confuse with O(bar)."
      ],
      "returned": "success",
      "sample": "baz",
      "type": "str"
     }
    }
   },
   "ns2.col.sub.foo3": {
    "doc": {
     "attributes": {
      "action_group": {
       "description": "Use C(group/ns2.col.foo_group) or C(group/ns2.col.bar_group) in C(module_defaults) to set defaults for this module.",
       "membership": [
        "ns2.col.bar_group",
        "ns2.col.foo_group"
       ],
       "support": "full"
      },
      "check_mode": {
       "description": "Can run in check_mode and return changed status prediction without modifying target",
       "support": "full"
      },
      "diff_mode": {
       "description": "Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode",
       "support": "N/A"
      },
      "platform": {
       "description": "Target OS/families that can be operated against",
       "platforms": "posix",
       "support": "partial"
      }
     },
     "author": [
      "Another one (@ansible-community)"
     ],
     "collection": "ns2.col",
     "description": [
      "Foo sub bar.",
      "See O(ns2.col.foo#role:main:foo_param_1) for a random role parameter reference. And O(ns2.col.foo#role:main:foo_param_2=42) for one with a value."
     ],
     "filename": "ansible_collections/ns2/col/plugins/modules/sub/foo3.py",
     "has_action": false,
     "module": "foo3",
     "options": {
      "bar": {
       "description": [
        "Some bar.",
        "See O(ns2.col.foo#role:main:foo_param_1) for a random role parameter reference. And O(ns2.col.foo#role:main:foo_param_2=42) for one with a value."
       ],
       "type": "str"
      }
     },
     "short_description": "A sub-foo"
    },
    "examples": "\n- name: Do some foobar\n  ns2.col.sub.foo3:\n    bar: baz\n",
    "metadata": null,
    "return": {
     "bar": {
      "description": [
       "Some bar.",
       "Referencing myself as RV(bar).",
       "Do not confuse with O(bar)."
      ],
      "returned": "success",
      "sample": "baz",
      "type": "str"
     }
    }
   }
  },
  "netconf": {},
  "role": {
   "ns.col2.bar": {
    "collection": "ns.col2",
    "entry_points": {
     "baz": {
      "description": [
       "This is the baz entrypoint of the bar role."
      ],
      "short_description": "Bar role, baz entrypoint \u30c6\u30b9\u30c8\u30ed\u30fc\u30eb"
     },
     "main": {
      "author": [
       "Felix Fontein (@felixfontein)"
      ],
      "description": [
       "This is the bar role."
      ],
      "seealso": [
       {
        "module": "ns2.col.foo"
       },
       {
        "module": "ns2.col.foobarbaz"
       }
      ],
      "short_description": "Bar role"
     }
    },
    "path": "ansible_collections/ns/col2"
   },
   "ns2.col.foo": {
    "collection": "ns2.col",
    "entry_points": {
     "main": {
      "attributes": {
       "check_mode": {
        "description": "Can run in check_mode and return changed status prediction without modifying target",
        "support": "full"
       },
       "platform": {
        "description": "The supported platforms",
        "platforms": "Linux, macOS, FreeBSD",
        "support": "full"
       }
      },
      "author": [
       "Felix Fontein (@felixfontein)"
      ],
      "deprecated": {
       "alternatives": "I don't know\nof any\nalternative.\n",
       "removed_in": "5.0.0",
       "why": "Just some text.\nThis one has more than one line.\nAnd one more.\n"
      },
      "description": [
       "This is the foo role.",
       "If you set O(foo_param_1) while O(foo_param_2=3), this might behave funny."
      ],
      "options": {
       "foo_param_1": {
        "description": [
         "A string parameter",
         "If you set O(foo_param_1) while O(foo_param_2=3), this might behave funny."
        ],
        "type": "str"
       },
       "foo_param_2": {
        "default": 13,
        "description": "An integer parameter with a default.",
        "type": "int"
       }
      },
      "seealso": [
       {
        "module": "ns2.col.foo"
       }
      ],
      "short_description": "Foo role",
      "version_added": "0.2.0"
     }
    },
    "path": "ansible_collections/ns2/col"
   }
  },
  "shell": {
   "ansible.builtin.cmd": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Used with the 'ssh' connection plugin and no C(DefaultShell) has been set on the Windows host."
     ],
     "filename": "/ansible/plugins/shell/cmd.py",
     "name": "cmd",
     "options": {
      "async_dir": {
       "default": "%USERPROFILE%\\.ansible_async",
       "description": [
        "Directory in which ansible will keep async job information.",
        "Before Ansible 2.8, this was set to C(remote_tmp + \"\\.ansible_async\")."
       ],
       "ini": [
        {
         "key": "async_dir",
         "section": "powershell"
        }
       ],
       "vars": [
        {
         "name": "ansible_async_dir"
        }
       ],
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      },
      "environment": {
       "default": [
        {}
       ],
       "description": [
        "List of dictionaries of environment variables and their values to use when executing commands."
       ],
       "elements": "dictionary",
       "keyword": [
        {
         "name": "environment"
        }
       ],
       "type": "list"
      },
      "remote_tmp": {
       "default": "%TEMP%",
       "description": [
        "Temporary directory to use on targets when copying files to the host."
       ],
       "ini": [
        {
         "key": "remote_tmp",
         "section": "powershell"
        }
       ],
       "vars": [
        {
         "name": "ansible_remote_tmp"
        }
       ]
      },
      "set_module_language": {
       "choices": [
        "no",
        false
       ],
       "default": "no",
       "description": [
        "Controls if we set the locale for modules when executing on the target.",
        "Windows only supports V(no) as an option."
       ],
       "type": "bool"
      }
     },
     "short_description": "Windows Command Prompt",
     "version_added": "2.8",
     "version_added_collection": "ansible.builtin"
    },
    "examples": null,
    "metadata": null,
    "return": null
   },
   "ansible.builtin.powershell": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "The only option when using 'winrm' or 'psrp' as a connection plugin.",
      "Can also be used when using 'ssh' as a connection plugin and the C(DefaultShell) has been configured to PowerShell."
     ],
     "filename": "/ansible/plugins/shell/powershell.py",
     "name": "powershell",
     "options": {
      "async_dir": {
       "default": "%USERPROFILE%\\.ansible_async",
       "description": [
        "Directory in which ansible will keep async job information.",
        "Before Ansible 2.8, this was set to C(remote_tmp + \"\\.ansible_async\")."
       ],
       "ini": [
        {
         "key": "async_dir",
         "section": "powershell"
        }
       ],
       "vars": [
        {
         "name": "ansible_async_dir"
        }
       ],
       "version_added": "2.8",
       "version_added_collection": "ansible.builtin"
      },
      "environment": {
       "default": [
        {}
       ],
       "description": [
        "List of dictionaries of environment variables and their values to use when executing commands."
       ],
       "elements": "dictionary",
       "keyword": [
        {
         "name": "environment"
        }
       ],
       "type": "list"
      },
      "remote_tmp": {
       "default": "%TEMP%",
       "description": [
        "Temporary directory to use on targets when copying files to the host."
       ],
       "ini": [
        {
         "key": "remote_tmp",
         "section": "powershell"
        }
       ],
       "vars": [
        {
         "name": "ansible_remote_tmp"
        }
       ]
      },
      "set_module_language": {
       "choices": [
        "no",
        false
       ],
       "default": "no",
       "description": [
        "Controls if we set the locale for modules when executing on the target.",
        "Windows only supports V(no) as an option."
       ],
       "type": "bool"
      }
     },
     "short_description": "Windows PowerShell",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": null,
    "metadata": null,
    "return": null
   },
   "ansible.builtin.sh": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "This shell plugin is the one you want to use on most Unix systems, it is the most compatible and widely installed shell."
     ],
     "filename": "/ansible/plugins/shell/sh.py",
     "name": "sh",
     "options": {
      "admin_users": {
       "default": [
        "root",
        "toor"
       ],
       "description": [
        "list of users to be expected to have admin privileges. This is used by the controller to determine how to share temporary files between the remote user and the become user."
       ],
       "elements": "string",
       "env": [
        {
         "name": "ANSIBLE_ADMIN_USERS"
        }
       ],
       "ini": [
        {
         "key": "admin_users",
         "section": "defaults"
        }
       ],
       "type": "list",
       "vars": [
        {
         "name": "ansible_admin_users"
        }
       ]
      },
      "async_dir": {
       "default": "~/.ansible_async",
       "description": [
        "Directory in which ansible will keep async job information"
       ],
       "env": [
        {
         "name": "ANSIBLE_ASYNC_DIR"
        }
       ],
       "ini": [
        {
         "key": "async_dir",
         "section": "defaults"
        }
       ],
       "vars": [
        {
         "name": "ansible_async_dir"
        }
       ]
      },
      "common_remote_group": {
       "default": null,
       "description": [
        "Checked when Ansible needs to execute a module as a different user.",
        "If setfacl and chown both fail and do not let the different user access the module's files, they will be chgrp'd to this group.",
        "In order for this to work, the remote_user and become_user must share a common group and this setting must be set to that group."
       ],
       "env": [
        {
         "name": "ANSIBLE_COMMON_REMOTE_GROUP"
        }
       ],
       "ini": [
        {
         "key": "common_remote_group",
         "section": "defaults"
        }
       ],
       "name": "Enables changing the group ownership of temporary files and directories",
       "vars": [
        {
         "name": "ansible_common_remote_group"
        }
       ],
       "version_added": "2.10",
       "version_added_collection": "ansible.builtin"
      },
      "environment": {
       "default": [
        {}
       ],
       "description": [
        "List of dictionaries of environment variables and their values to use when executing commands."
       ],
       "elements": "dictionary",
       "keyword": [
        {
         "name": "environment"
        }
       ],
       "type": "list"
      },
      "remote_tmp": {
       "default": "~/.ansible/tmp",
       "description": [
        "Temporary directory to use on targets when executing tasks."
       ],
       "env": [
        {
         "name": "ANSIBLE_REMOTE_TEMP"
        },
        {
         "name": "ANSIBLE_REMOTE_TMP"
        }
       ],
       "ini": [
        {
         "key": "remote_tmp",
         "section": "defaults"
        }
       ],
       "vars": [
        {
         "name": "ansible_remote_tmp"
        }
       ]
      },
      "system_tmpdirs": {
       "default": [
        "/var/tmp",
        "/tmp"
       ],
       "description": [
        "List of valid system temporary directories on the managed machine for Ansible to validate O(remote_tmp) against, when specific permissions are needed.  These must be world readable, writable, and executable. This list should only contain directories which the system administrator has pre-created with the proper ownership and permissions otherwise security issues can arise.",
        "When O(remote_tmp) is required to be a system temp dir and it does not match any in the list, the first one from the list will be used instead."
       ],
       "elements": "string",
       "env": [
        {
         "name": "ANSIBLE_SYSTEM_TMPDIRS"
        }
       ],
       "ini": [
        {
         "key": "system_tmpdirs",
         "section": "defaults"
        }
       ],
       "type": "list",
       "vars": [
        {
         "name": "ansible_system_tmpdirs"
        }
       ]
      },
      "world_readable_temp": {
       "default": false,
       "description": [
        "This makes the temporary files created on the machine world-readable and will issue a warning instead of failing the task.",
        "It is useful when becoming an unprivileged user."
       ],
       "env": [
        {
         "name": "ANSIBLE_SHELL_ALLOW_WORLD_READABLE_TEMP"
        }
       ],
       "ini": [
        {
         "key": "allow_world_readable_tmpfiles",
         "section": "defaults"
        }
       ],
       "type": "boolean",
       "vars": [
        {
         "name": "ansible_shell_allow_world_readable_temp"
        }
       ],
       "version_added": "2.10",
       "version_added_collection": "ansible.builtin"
      }
     },
     "short_description": "POSIX shell (/bin/sh)",
     "version_added": "historical",
     "version_added_collection": "ansible.builtin"
    },
    "examples": null,
    "metadata": null,
    "return": null
   },
   "ns2.col.foo": {
    "doc": {
     "collection": "ns2.col",
     "description": [
      "This is for the foo shell."
     ],
     "filename": "ansible_collections/ns2/col/plugins/shell/foo.py",
     "name": "foo",
     "options": {
      "bar": {
       "description": "Foo bar.",
       "type": "string"
      },
      "remote_tmp": {
       "default": "~/.ansible/tmp",
       "description": [
        "Temporary directory to use on targets when executing tasks."
       ],
       "env": [
        {
         "name": "ANSIBLE_REMOTE_TEMP"
        },
        {
         "name": "ANSIBLE_REMOTE_TMP"
        }
       ],
       "ini": [
        {
         "key": "remote_tmp",
         "section": "defaults"
        }
       ],
       "vars": [
        {
         "name": "ansible_remote_tmp"
        }
       ],
       "version_added": "2.10",
       "version_added_collection": "ansible.builtin"
      }
     },
     "short_description": "Foo shell O(bar)",
     "version_added": "1.0.0",
     "version_added_collection": "ns2.col"
    },
    "examples": null,
    "metadata": null,
    "return": null
   }
  },
  "strategy": {
   "ansible.builtin.debug": {
    "doc": {
     "author": "Kishin Yagami (!UNKNOWN)",
     "collection": "ansible.builtin",
     "description": [
      "Task execution is 'linear' but controlled by an interactive debug session."
     ],
     "filename": "/ansible/plugins/strategy/debug.py",
     "name": "debug",
     "short_description": "Executes tasks in interactive debug session.",
     "version_added": "2.1",
     "version_added_collection": "ansible.builtin"
    },
    "examples": null,
    "metadata": null,
    "return": null
   },
   "ansible.builtin.free": {
    "doc": {
     "author": "Ansible Core Team",
     "collection": "ansible.builtin",
     "description": [
      "Task execution is as fast as possible per batch as defined by C(serial) (default all). Ansible will not wait for other hosts to finish the current task before queuing more tasks for other hosts. All hosts are still attempted for the current task, but it prevents blocking new tasks for hosts that have already finished.",
      "With the free strategy, unlike the default linear strategy, a host that is slow or stuck on a specific task won't hold up the rest of the hosts and tasks."
     ],
     "filename": "/ansible/plugins/strategy/free.py",
     "name": "free",
     "short_description": "Executes tasks without waiting for all hosts",
     "version_added": "2.0",
     "version_added_collection": "ansible.builtin"
    },
    "examples": null,
    "metadata": null,
    "return": null
   },
   "ansible.builtin.host_pinned": {
    "doc": {
     "author": "Ansible Core Team",
     "collection": "ansible.builtin",
     "description": [
      "Task execution is as fast as possible per host in batch as defined by C(serial) (default all). Ansible will not start a play for a host unless the play can be finished without interruption by tasks for another host, i.e. the number of hosts with an active play does not exceed the number of forks. Ansible will not wait for other hosts to finish the current task before queuing the next task for a host that has finished. Once a host is done with the play, it opens it's slot to a new host that was waiting to start. Other than that, it behaves just like the \"free\" strategy."
     ],
     "filename": "/ansible/plugins/strategy/host_pinned.py",
     "name": "host_pinned",
     "short_description": "Executes tasks on each host without interruption",
     "version_added": "2.7",
     "version_added_collection": "ansible.builtin"
    },
    "examples": null,
    "metadata": null,
    "return": null
   },
   "ansible.builtin.linear": {
    "doc": {
     "author": "Ansible Core Team",
     "collection": "ansible.builtin",
     "description": [
      "Task execution is in lockstep per host batch as defined by C(serial) (default all). Up to the fork limit of hosts will execute each task at the same time and then the next series of hosts until the batch is done, before going on to the next task."
     ],
     "filename": "/ansible/plugins/strategy/linear.py",
     "name": "linear",
     "notes": [
      "This was the default Ansible behaviour before 'strategy plugins' were introduced in 2.0."
     ],
     "short_description": "Executes tasks in a linear fashion",
     "version_added": "2.0",
     "version_added_collection": "ansible.builtin"
    },
    "examples": null,
    "metadata": null,
    "return": null
   },
   "ns2.col.foo": {
    "doc": {
     "author": "Ansible Core Team",
     "collection": "ns2.col",
     "description": [
      "This is something funny. Or at least I think so from its name."
     ],
     "filename": "ansible_collections/ns2/col/plugins/strategy/foo.py",
     "name": "foo",
     "short_description": "Executes tasks in foo",
     "version_added": "1.1.0",
     "version_added_collection": "ns2.col"
    },
    "examples": null,
    "metadata": null,
    "return": null
   }
  },
  "test": {
   "ansible.builtin.abs": {
    "doc": {
     "aliases": [
      "is_abs"
     ],
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Check if the provided path is absolute, not relative.",
      "An absolute path expresses the location of a filesystem object starting at the filesystem root and requires no context.",
      "A relative path does not start at the filesystem root and requires a 'current' directory as a context to resolve."
     ],
     "filename": "/ansible/plugins/test/abs.yml",
     "name": "abs",
     "options": {
      "_input": {
       "description": "A path.",
       "type": "path"
      }
     },
     "short_description": "is the path absolute",
     "version_added": "2.5",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "is_path_absolute: \"{{ '/etc/hosts' is abs }}}\"\nrelative_paths: \"{{ all_paths | reject('abs') }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the path is absolute, V(False) if it is relative.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.all": {
    "doc": {
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "This test checks each condition in a list for truthiness.",
      "Same as the C(all) Python function."
     ],
     "filename": "/ansible/plugins/test/all.yml",
     "name": "all",
     "options": {
      "_input": {
       "description": "List of conditions, each can be a boolean or conditional expression that results in a boolean value.",
       "elements": "raw",
       "required": true,
       "type": "list"
      }
     },
     "short_description": "are all conditions in a list true",
     "version_added": "2.4",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "varexpression: \"{{ 3 == 3 }}\"\n# are all statements true?\n{{ [true, booleanvar, varexpression] is all }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if all elements of the list were True, V(False) otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.any": {
    "doc": {
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "This test checks each condition in a list for truthiness.",
      "Same as the C(any) Python function."
     ],
     "filename": "/ansible/plugins/test/any.yml",
     "name": "any",
     "options": {
      "_input": {
       "description": "List of conditions, each can be a boolean or conditional expression that results in a boolean value.",
       "elements": "raw",
       "required": true,
       "type": "list"
      }
     },
     "short_description": "is any conditions in a list true",
     "version_added": "2.4",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "varexpression: \"{{ 3 == 3 }}\"\n# are all statements true?\n{{ [false, booleanvar, varexpression] is any}}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if any element of the list was true, V(False) otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.change": {
    "doc": {
     "aliases": [
      "change"
     ],
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Tests if task required changes to complete",
      "This test checks for the existence of a C(changed) key in the input dictionary and that it is V(True) if present"
     ],
     "filename": "/ansible/plugins/test/change.yml",
     "name": "changed",
     "options": {
      "_input": {
       "description": "registered result from an Ansible task",
       "required": true,
       "type": "dictionary"
      }
     },
     "short_description": "did the task require changes",
     "version_added": "1.9",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# test 'status' to know how to respond\n{{ taskresults is changed }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the task was required changes, V(False) otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.changed": {
    "doc": {
     "aliases": [
      "change"
     ],
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Tests if task required changes to complete",
      "This test checks for the existence of a C(changed) key in the input dictionary and that it is V(True) if present"
     ],
     "filename": "/ansible/plugins/test/changed.yml",
     "name": "changed",
     "options": {
      "_input": {
       "description": "registered result from an Ansible task",
       "required": true,
       "type": "dictionary"
      }
     },
     "short_description": "did the task require changes",
     "version_added": "1.9",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# test 'status' to know how to respond\n{{ taskresults is changed }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the task was required changes, V(False) otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.contains": {
    "doc": {
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Checks the supplied element against the input list to see if it exists within it."
     ],
     "filename": "/ansible/plugins/test/contains.yml",
     "name": "contains",
     "options": {
      "_contained": {
       "description": "Element to test for.",
       "required": true,
       "type": "raw"
      },
      "_input": {
       "description": "List of elements to compare.",
       "elements": "raw",
       "required": true,
       "type": "list"
      }
     },
     "short_description": "does the list contain this element",
     "version_added": "2.4",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# simple expression\n{{ listofthings is contains('this') }}\n\n# as a selector\n- action: module=doessomething\n  when: (lacp_groups|selectattr('interfaces', 'contains', 'em1')|first).master\n  vars:\n    lacp_groups:\n      - master: lacp0\n        network: 10.65.100.0/24\n        gateway: 10.65.100.1\n        dns4:\n          - 10.65.100.10\n          - 10.65.100.11\n        interfaces:\n          - em1\n          - em2\n\n      - master: lacp1\n        network: 10.65.120.0/24\n        gateway: 10.65.120.1\n        dns4:\n          - 10.65.100.10\n          - 10.65.100.11\n        interfaces:\n            - em3\n            - em4\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the specified element is contained in the supplied sequence, V(False) otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.directory": {
    "doc": {
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Check if the provided path maps to an existing directory on the controller's filesystem (localhost)."
     ],
     "filename": "/ansible/plugins/test/directory.yml",
     "name": "directory",
     "options": {
      "_input": {
       "description": "A path.",
       "type": "path"
      }
     },
     "short_description": "does the path resolve to an existing directory",
     "version_added": "2.5",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "vars:\n  my_etc_hosts_not_a_dir: \"{{ '/etc/hosts' is directory}}\"\n  list_of_files: \"{{ list_of_paths | reject('directory') }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the path corresponds to an existing directory on the filesystem on the controller, V(False) if otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.exists": {
    "doc": {
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Check if the provided path maps to an existing filesystem object on the controller (localhost).",
      "Follows symlinks and checks the target of the symlink instead of the link itself, use the P(ansible.builtin.link#test) or P(ansible.builtin.link_exists#test) tests to check on the link."
     ],
     "filename": "/ansible/plugins/test/exists.yml",
     "name": "exists",
     "options": {
      "_input": {
       "description": "a path",
       "type": "path"
      }
     },
     "short_description": "does the path exist, follow symlinks",
     "version_added": "2.5",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "vars:\n  my_etc_hosts_exists: \"{{ '/etc/hosts' is exist }}\"\n  list_of_local_files_to_copy_to_remote: \"{{ list_of_all_possible_files | select('exists') }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the path corresponds to an existing filesystem object on the controller (after following symlinks), V(False) if otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.failed": {
    "doc": {
     "aliases": [
      "failure"
     ],
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Tests if task finished in failure, opposite of C(succeeded).",
      "This test checks for the existence of a C(failed) key in the input dictionary and that it is V(True) if present.",
      "Tasks that get skipped or not executed due to other failures (syntax, templating, unreachable host, etc) do not return a 'failed' status."
     ],
     "filename": "/ansible/plugins/test/failed.yml",
     "name": "failed",
     "options": {
      "_input": {
       "description": "registered result from an Ansible task",
       "required": true,
       "type": "dictionary"
      }
     },
     "short_description": "did the task fail",
     "version_added": "1.9",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# test 'status' to know how to respond\n{{ taskresults is failed }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the task was failed, V(False) otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.failure": {
    "doc": {
     "aliases": [
      "failure"
     ],
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Tests if task finished in failure, opposite of C(succeeded).",
      "This test checks for the existence of a C(failed) key in the input dictionary and that it is V(True) if present.",
      "Tasks that get skipped or not executed due to other failures (syntax, templating, unreachable host, etc) do not return a 'failed' status."
     ],
     "filename": "/ansible/plugins/test/failure.yml",
     "name": "failed",
     "options": {
      "_input": {
       "description": "registered result from an Ansible task",
       "required": true,
       "type": "dictionary"
      }
     },
     "short_description": "did the task fail",
     "version_added": "1.9",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# test 'status' to know how to respond\n{{ taskresults is failed }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the task was failed, V(False) otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.falsy": {
    "doc": {
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "This check is a more Python version of what is 'false'.",
      "It is the opposite of 'truthy'."
     ],
     "filename": "/ansible/plugins/test/falsy.yml",
     "name": "falsy",
     "options": {
      "_input": {
       "description": "An expression that can be expressed in a boolean context.",
       "required": true,
       "type": "string"
      },
      "convert_bool": {
       "default": false,
       "description": "Attempts to convert the result to a strict Python boolean vs normally acceptable values (V(yes)/V(no), V(on)/V(off), V(0)/V(1), etc).",
       "type": "bool"
      }
     },
     "short_description": "Pythonic false",
     "version_added": "2.10",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "thisisfalse: '{{ \"any string\" is falsy }}'\nthisistrue: '{{ \"\" is falsy }}'\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(False) if the condition is not \"Python truthy\", V(True) otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.file": {
    "doc": {
     "aliases": [
      "is_file"
     ],
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Check if the provided path maps to an existing file on the controller's filesystem (localhost)"
     ],
     "filename": "/ansible/plugins/test/file.yml",
     "name": "file",
     "options": {
      "_input": {
       "description": "A path.",
       "type": "path"
      }
     },
     "short_description": "does the path resolve to an existing file",
     "version_added": "2.5",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "vars:\n  my_etc_hosts_is_a_file: \"{{ '/etc/hosts' is file }}\"\n  list_of_files: \"{{ list_of_paths | select('file') }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the path corresponds to an existing file on the filesystem on the controller, V(False) if otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.finished": {
    "doc": {
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Used to test if an async task has finished, it will also work with normal tasks but will issue a warning.",
      "This test checks for the existence of a C(finished) key in the input dictionary and that it is V(1) if present"
     ],
     "filename": "/ansible/plugins/test/finished.yml",
     "name": "finished",
     "options": {
      "_input": {
       "description": "registered result from an Ansible task",
       "required": true,
       "type": "dictionary"
      }
     },
     "short_description": "Did async task finish",
     "version_added": "1.9",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# test 'status' to know how to respond\n{{ (asynctaskpoll is finished}}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the async task has finished, V(False) otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.is_abs": {
    "doc": {
     "aliases": [
      "is_abs"
     ],
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Check if the provided path is absolute, not relative.",
      "An absolute path expresses the location of a filesystem object starting at the filesystem root and requires no context.",
      "A relative path does not start at the filesystem root and requires a 'current' directory as a context to resolve."
     ],
     "filename": "/ansible/plugins/test/is_abs.yml",
     "name": "abs",
     "options": {
      "_input": {
       "description": "A path.",
       "type": "path"
      }
     },
     "short_description": "is the path absolute",
     "version_added": "2.5",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "is_path_absolute: \"{{ '/etc/hosts' is abs }}}\"\nrelative_paths: \"{{ all_paths | reject('abs') }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the path is absolute, V(False) if it is relative.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.is_dir": {
    "doc": {
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Check if the provided path maps to an existing directory on the controller's filesystem (localhost)."
     ],
     "filename": "/ansible/plugins/test/is_dir.yml",
     "name": "directory",
     "options": {
      "_input": {
       "description": "A path.",
       "type": "path"
      }
     },
     "short_description": "does the path resolve to an existing directory",
     "version_added": "2.5",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "vars:\n  my_etc_hosts_not_a_dir: \"{{ '/etc/hosts' is directory}}\"\n  list_of_files: \"{{ list_of_paths | reject('directory') }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the path corresponds to an existing directory on the filesystem on the controller, V(False) if otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.is_file": {
    "doc": {
     "aliases": [
      "is_file"
     ],
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Check if the provided path maps to an existing file on the controller's filesystem (localhost)"
     ],
     "filename": "/ansible/plugins/test/is_file.yml",
     "name": "file",
     "options": {
      "_input": {
       "description": "A path.",
       "type": "path"
      }
     },
     "short_description": "does the path resolve to an existing file",
     "version_added": "2.5",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "vars:\n  my_etc_hosts_is_a_file: \"{{ '/etc/hosts' is file }}\"\n  list_of_files: \"{{ list_of_paths | select('file') }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the path corresponds to an existing file on the filesystem on the controller, V(False) if otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.is_link": {
    "doc": {
     "aliases": [
      "islink"
     ],
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Check if the provided path maps to an existing symlink on the controller's filesystem (localhost)."
     ],
     "filename": "/ansible/plugins/test/is_link.yml",
     "name": "link",
     "options": {
      "_input": {
       "description": "A path.",
       "type": "path"
      }
     },
     "short_description": "does the path reference existing symbolic link",
     "version_added": "2.5",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "ismyhostsalink: \"{{ '/etc/hosts' is link}}\"\nlist_of_symlinks: \"{{ list_of_paths | select('link') }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the path corresponds to an existing symlink on the filesystem on the controller, V(False) if otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.is_mount": {
    "doc": {
     "aliases": [
      "is_mount"
     ],
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Check if the provided path maps to a filesystem mount point on the controller (localhost)."
     ],
     "filename": "/ansible/plugins/test/is_mount.yml",
     "name": "mount",
     "options": {
      "_input": {
       "description": "A path.",
       "type": "path"
      }
     },
     "short_description": "does the path resolve to mount point",
     "version_added": "2.5",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "vars:\n  ihopefalse: \"{{ '/etc/hosts' is mount }}\"\n  normallytrue: \"{{ '/tmp' is mount }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the path corresponds to a mount point on the controller, V(False) if otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.is_same_file": {
    "doc": {
     "aliases": [
      "is_file"
     ],
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": "Check if the provided paths map to the same location on the controller's filesystem (localhost).",
     "filename": "/ansible/plugins/test/is_same_file.yml",
     "name": "same_file",
     "options": {
      "_input": {
       "description": "A path.",
       "required": true,
       "type": "path"
      },
      "_path2": {
       "description": "Another path.",
       "required": true,
       "type": "path"
      }
     },
     "short_description": "compares two paths to see if they resolve to the same filesystem object",
     "version_added": "2.5",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "amionelevelfromroot: \"{{ '/etc/hosts' is same_file('../etc/hosts') }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the paths correspond to the same location on the filesystem on the controller, V(False) if otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.isnan": {
    "doc": {
     "aliases": [
      "is_file"
     ],
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Whether the input is a special floating point number called L(not a number, https://en.wikipedia.org/wiki/NaN)."
     ],
     "filename": "/ansible/plugins/test/isnan.yml",
     "name": "nan",
     "options": {
      "_input": {
       "description": "Possible number representation or string that can be converted into one.",
       "required": true,
       "type": "raw"
      }
     },
     "short_description": "is this not a number (NaN)",
     "version_added": "2.5",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "isnan: \"{{ '42' is nan }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the input is NaN, V(False) if otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.issubset": {
    "doc": {
     "aliases": [
      "issubset"
     ],
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Validate if the first list is a sub set (is included) of the second list."
     ],
     "filename": "/ansible/plugins/test/issubset.yml",
     "name": "subset",
     "options": {
      "_input": {
       "description": "List.",
       "elements": "raw",
       "required": true,
       "type": "list"
      },
      "_superset": {
       "description": "List to test against.",
       "elements": "raw",
       "required": true,
       "type": "list"
      }
     },
     "short_description": "is the list a subset of this other list",
     "version_added": "2.4",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "big: [1,2,3,4,5]\nsml: [3,4]\nissmallinbig: '{{ small is subset(big) }}'\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the specified list is a subset of the provided list, V(False) otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.issuperset": {
    "doc": {
     "aliases": [
      "issuperset"
     ],
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Validate if the first list is a super set (includes) the second list."
     ],
     "filename": "/ansible/plugins/test/issuperset.yml",
     "name": "superset",
     "options": {
      "_input": {
       "description": "List.",
       "elements": "raw",
       "required": true,
       "type": "list"
      },
      "_subset": {
       "description": "List to test against.",
       "elements": "raw",
       "required": true,
       "type": "list"
      }
     },
     "short_description": "is the list a superset of this other list",
     "version_added": "2.4",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "big: [1,2,3,4,5]\nsmall: [3,4]\nissmallinbig: '{{ big is superset(small) }}'\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the specified list is a superset of the provided list, V(False) otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.link": {
    "doc": {
     "aliases": [
      "islink"
     ],
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Check if the provided path maps to an existing symlink on the controller's filesystem (localhost)."
     ],
     "filename": "/ansible/plugins/test/link.yml",
     "name": "link",
     "options": {
      "_input": {
       "description": "A path.",
       "type": "path"
      }
     },
     "short_description": "does the path reference existing symbolic link",
     "version_added": "2.5",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "ismyhostsalink: \"{{ '/etc/hosts' is link}}\"\nlist_of_symlinks: \"{{ list_of_paths | select('link') }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the path corresponds to an existing symlink on the filesystem on the controller, V(False) if otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.link_exists": {
    "doc": {
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Check if the provided path maps to an existing symlink on the controller's filesystem (localhost).",
      "Does not follow symlinks, so it only verifies that the link itself exists."
     ],
     "filename": "/ansible/plugins/test/link_exists.yml",
     "name": "link_exists",
     "options": {
      "_input": {
       "description": "A path.",
       "type": "path"
      }
     },
     "short_description": "does the path exist, no follow",
     "version_added": "2.5",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "ismyhostsalink: \"{{ '/etc/hosts' is link_exists}}\"\nlist_of_symlinks: \"{{ list_of_paths | select('link_exists') }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the path corresponds to an existing filesystem object on the controller, V(False) if otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.match": {
    "doc": {
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Compare string against regular expression using Python's match function, this means the regex is automatically anchored at the start of the string."
     ],
     "filename": "/ansible/plugins/test/match.yml",
     "name": "match",
     "options": {
      "_input": {
       "description": "String to match.",
       "required": true,
       "type": "string"
      },
      "ignorecase": {
       "default": false,
       "description": "Use case insensitive matching.",
       "type": "boolean"
      },
      "multiline": {
       "default": false,
       "description": "Match against multiple lines in string.",
       "type": "boolean"
      },
      "pattern": {
       "description": "Regex to match against.",
       "required": true,
       "type": "string"
      }
     },
     "short_description": "Does string match regular expression from the start"
    },
    "examples": "url: \"https://example.com/users/foo/resources/bar\"\nfoundmatch: url is match(\"https://example.com/users/.*/resources\")\nnomatch: url is match(\"/users/.*/resources\")\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if there is a match, V(False) otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.mount": {
    "doc": {
     "aliases": [
      "is_mount"
     ],
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Check if the provided path maps to a filesystem mount point on the controller (localhost)."
     ],
     "filename": "/ansible/plugins/test/mount.yml",
     "name": "mount",
     "options": {
      "_input": {
       "description": "A path.",
       "type": "path"
      }
     },
     "short_description": "does the path resolve to mount point",
     "version_added": "2.5",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "vars:\n  ihopefalse: \"{{ '/etc/hosts' is mount }}\"\n  normallytrue: \"{{ '/tmp' is mount }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the path corresponds to a mount point on the controller, V(False) if otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.nan": {
    "doc": {
     "aliases": [
      "is_file"
     ],
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Whether the input is a special floating point number called L(not a number, https://en.wikipedia.org/wiki/NaN)."
     ],
     "filename": "/ansible/plugins/test/nan.yml",
     "name": "nan",
     "options": {
      "_input": {
       "description": "Possible number representation or string that can be converted into one.",
       "required": true,
       "type": "raw"
      }
     },
     "short_description": "is this not a number (NaN)",
     "version_added": "2.5",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "isnan: \"{{ '42' is nan }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the input is NaN, V(False) if otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.reachable": {
    "doc": {
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Tests if task was able to reach the host for execution",
      "This test checks for the existence of a C(unreachable) key in the input dictionary and that it is V(False) if present"
     ],
     "filename": "/ansible/plugins/test/reachable.yml",
     "name": "reachable",
     "options": {
      "_input": {
       "description": "registered result from an Ansible task",
       "required": true,
       "type": "dictionary"
      }
     },
     "short_description": "Task did not end due to unreachable host",
     "version_added": "1.9",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# test 'status' to know how to respond\n{{ taskresults is reachable }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the task did not flag the host as unreachable, V(False) otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.regex": {
    "doc": {
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Compare string against regular expression using Python's match or search functions."
     ],
     "filename": "/ansible/plugins/test/regex.yml",
     "name": "regex",
     "options": {
      "_input": {
       "description": "String to match.",
       "required": true,
       "type": "string"
      },
      "ignorecase": {
       "default": false,
       "description": "Use case insensitive matching.",
       "type": "boolean"
      },
      "match_type": {
       "choices": [
        "match",
        "search"
       ],
       "default": "search",
       "description": "Decide which function to be used to do the matching.",
       "type": "string"
      },
      "multiline": {
       "default": false,
       "description": "Match against multiple lines in string.",
       "type": "boolean"
      },
      "pattern": {
       "description": "Regex to match against.",
       "required": true,
       "type": "string"
      }
     },
     "short_description": "Does string match regular expression from the start"
    },
    "examples": "url: \"https://example.com/users/foo/resources/bar\"\nfoundmatch: url is regex(\"example\\.com/\\w+/foo\")\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if there is a match, V(False) otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.same_file": {
    "doc": {
     "aliases": [
      "is_file"
     ],
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": "Check if the provided paths map to the same location on the controller's filesystem (localhost).",
     "filename": "/ansible/plugins/test/same_file.yml",
     "name": "same_file",
     "options": {
      "_input": {
       "description": "A path.",
       "required": true,
       "type": "path"
      },
      "_path2": {
       "description": "Another path.",
       "required": true,
       "type": "path"
      }
     },
     "short_description": "compares two paths to see if they resolve to the same filesystem object",
     "version_added": "2.5",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "amionelevelfromroot: \"{{ '/etc/hosts' is same_file('../etc/hosts') }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the paths correspond to the same location on the filesystem on the controller, V(False) if otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.search": {
    "doc": {
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Compare string against regular expression using Python's C(search) function."
     ],
     "filename": "/ansible/plugins/test/search.yml",
     "name": "search",
     "options": {
      "_input": {
       "description": "String to match.",
       "required": true,
       "type": "string"
      },
      "ignorecase": {
       "default": false,
       "description": "Use case insensitive matching.",
       "type": "boolean"
      },
      "multiline": {
       "default": false,
       "description": "Match against multiple lines in string.",
       "type": "boolean"
      },
      "pattern": {
       "description": "Regex to match against.",
       "required": true,
       "type": "string"
      }
     },
     "short_description": "Does string match a regular expression"
    },
    "examples": "url: \"https://example.com/users/foo/resources/bar\"\nfoundmatch: url is search(\"https://example.com/users/.*/resources\")\nalsomatch: url is search(\"users/.*/resources\")\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if there is a match, V(False) otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.skip": {
    "doc": {
     "aliases": [
      "skip"
     ],
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Tests if task was skipped",
      "This test checks for the existence of a C(skipped) key in the input dictionary and that it is V(True) if present"
     ],
     "filename": "/ansible/plugins/test/skip.yml",
     "name": "skipped",
     "options": {
      "_input": {
       "description": "registered result from an Ansible task",
       "required": true,
       "type": "dictionary"
      }
     },
     "short_description": "Was task skipped",
     "version_added": "1.9",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# test 'status' to know how to respond\n{{ taskresults is skipped }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the task was skipped, V(False) otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.skipped": {
    "doc": {
     "aliases": [
      "skip"
     ],
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Tests if task was skipped",
      "This test checks for the existence of a C(skipped) key in the input dictionary and that it is V(True) if present"
     ],
     "filename": "/ansible/plugins/test/skipped.yml",
     "name": "skipped",
     "options": {
      "_input": {
       "description": "registered result from an Ansible task",
       "required": true,
       "type": "dictionary"
      }
     },
     "short_description": "Was task skipped",
     "version_added": "1.9",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# test 'status' to know how to respond\n{{ taskresults is skipped }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the task was skipped, V(False) otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.started": {
    "doc": {
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Used to check if an async task has started, will also work with non async tasks but will issue a warning.",
      "This test checks for the existence of a C(started) key in the input dictionary and that it is V(1) if present"
     ],
     "filename": "/ansible/plugins/test/started.yml",
     "name": "started",
     "options": {
      "_input": {
       "description": "registered result from an Ansible task",
       "required": true,
       "type": "dictionary"
      }
     },
     "short_description": "Was async task started",
     "version_added": "1.9",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# test 'status' to know how to respond\n{{ (asynctaskpoll is started}}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the task has started, V(False) otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.subset": {
    "doc": {
     "aliases": [
      "issubset"
     ],
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Validate if the first list is a sub set (is included) of the second list."
     ],
     "filename": "/ansible/plugins/test/subset.yml",
     "name": "subset",
     "options": {
      "_input": {
       "description": "List.",
       "elements": "raw",
       "required": true,
       "type": "list"
      },
      "_superset": {
       "description": "List to test against.",
       "elements": "raw",
       "required": true,
       "type": "list"
      }
     },
     "short_description": "is the list a subset of this other list",
     "version_added": "2.4",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "big: [1,2,3,4,5]\nsml: [3,4]\nissmallinbig: '{{ small is subset(big) }}'\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the specified list is a subset of the provided list, V(False) otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.succeeded": {
    "doc": {
     "aliases": [
      "succeeded",
      "successful"
     ],
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Tests if task finished successfully, opposite of C(failed).",
      "This test checks for the existence of a C(failed) key in the input dictionary and that it is V(False) if present"
     ],
     "filename": "/ansible/plugins/test/succeeded.yml",
     "name": "success",
     "options": {
      "_input": {
       "description": "registered result from an Ansible task",
       "required": true,
       "type": "dictionary"
      }
     },
     "short_description": "check task success",
     "version_added": "1.9",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# test 'status' to know how to respond\n{{ taskresults is success }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the task was successfully completed, V(False) otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.success": {
    "doc": {
     "aliases": [
      "succeeded",
      "successful"
     ],
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Tests if task finished successfully, opposite of C(failed).",
      "This test checks for the existence of a C(failed) key in the input dictionary and that it is V(False) if present"
     ],
     "filename": "/ansible/plugins/test/success.yml",
     "name": "success",
     "options": {
      "_input": {
       "description": "registered result from an Ansible task",
       "required": true,
       "type": "dictionary"
      }
     },
     "short_description": "check task success",
     "version_added": "1.9",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# test 'status' to know how to respond\n{{ taskresults is success }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the task was successfully completed, V(False) otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.successful": {
    "doc": {
     "aliases": [
      "succeeded",
      "successful"
     ],
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Tests if task finished successfully, opposite of C(failed).",
      "This test checks for the existence of a C(failed) key in the input dictionary and that it is V(False) if present"
     ],
     "filename": "/ansible/plugins/test/successful.yml",
     "name": "success",
     "options": {
      "_input": {
       "description": "registered result from an Ansible task",
       "required": true,
       "type": "dictionary"
      }
     },
     "short_description": "check task success",
     "version_added": "1.9",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# test 'status' to know how to respond\n{{ taskresults is success }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the task was successfully completed, V(False) otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.superset": {
    "doc": {
     "aliases": [
      "issuperset"
     ],
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Validate if the first list is a super set (includes) the second list."
     ],
     "filename": "/ansible/plugins/test/superset.yml",
     "name": "superset",
     "options": {
      "_input": {
       "description": "List.",
       "elements": "raw",
       "required": true,
       "type": "list"
      },
      "_subset": {
       "description": "List to test against.",
       "elements": "raw",
       "required": true,
       "type": "list"
      }
     },
     "short_description": "is the list a superset of this other list",
     "version_added": "2.4",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "big: [1,2,3,4,5]\nsmall: [3,4]\nissmallinbig: '{{ big is superset(small) }}'\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the specified list is a superset of the provided list, V(False) otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.truthy": {
    "doc": {
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "This check is a more Python version of what is 'true'.",
      "It is the opposite of P(ansible.builtin.falsy#test)."
     ],
     "filename": "/ansible/plugins/test/truthy.yml",
     "name": "truthy",
     "options": {
      "_input": {
       "description": "An expression that can be expressed in a boolean context.",
       "required": true,
       "type": "string"
      },
      "convert_bool": {
       "default": false,
       "description": "Attempts to convert to strict python boolean vs normally acceptable values (V(yes)/V(no), V(on)/V(off), V(0)/V(1), etc).",
       "type": "bool"
      }
     },
     "short_description": "Pythonic true",
     "version_added": "2.10",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "thisistrue: '{{ \"any string\" is truthy }}'\nthisisfalse: '{{ \"\" is truthy }}'\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the condition is not \"Python truthy\", V(False) otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.unreachable": {
    "doc": {
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Tests if task was not able to reach the host for execution",
      "This test checks for the existence of a C(unreachable) key in the input dictionary and that it's value is V(True)"
     ],
     "filename": "/ansible/plugins/test/unreachable.yml",
     "name": "unreachable",
     "options": {
      "_input": {
       "description": "registered result from an Ansible task",
       "required": true,
       "type": "dictionary"
      }
     },
     "short_description": "Did task end due to the host was unreachable",
     "version_added": "1.9",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# test 'status' to know how to respond\n{{ taskresults is unreachable }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the task flagged the host as unreachable, V(False) otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.uri": {
    "doc": {
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Validates that the input string conforms to the URI standard, optionally that is also in the list of schemas provided."
     ],
     "filename": "/ansible/plugins/test/uri.yml",
     "name": "uri",
     "options": {
      "_input": {
       "description": "Possible URI.",
       "required": true,
       "type": "string"
      },
      "schemes": {
       "description": "Subset of URI schemas to validate against, otherwise B(any) scheme is considered valid.",
       "elements": "string",
       "required": false,
       "type": "list"
      }
     },
     "short_description": "is the string a valid URI",
     "version_added": "2.14",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# URLs are URIs\n{{ 'http://example.com' is uri }}\n# but not all URIs are URLs\n{{ 'mailto://nowone@example.com' is uri }}\n# looking only for file transfers URIs\n{{ 'mailto://nowone@example.com' is not uri(schemes=['ftp', 'ftps', 'sftp', 'file']) }}\n# make sure URL conforms to the 'special schemas'\n{{ 'http://nobody:secret@example.com' is uri(['ftp', 'ftps', 'http', 'https', 'ws', 'wss']) }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(false) if the string is not a URI or the schema extracted does not match the supplied list.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.url": {
    "doc": {
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Validates a string to conform to the URL standard."
     ],
     "filename": "/ansible/plugins/test/url.yml",
     "name": "url",
     "options": {
      "_input": {
       "description": "Possible URL.",
       "required": true,
       "type": "string"
      },
      "schemes": {
       "description": "Subset of URI schemas to validate against, otherwise B(any) scheme is considered valid.",
       "elements": "string",
       "type": "list"
      }
     },
     "short_description": "is the string a valid URL",
     "version_added": "2.14",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# simple URL\n{{ 'http://example.com' is url }}\n# looking only for file transfers URIs\n{{ 'mailto://nowone@example.com' is not uri(schemes=['ftp', 'ftps', 'sftp', 'file']) }}\n#  but it is according to standard\n{{ 'mailto://nowone@example.com' is not uri }}\n# more complex URL\n{{ 'ftp://admin:secret@example.com/path/to/myfile.yml' is url }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(false) if the string is not a URL, V(true) otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.urn": {
    "doc": {
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Validates that the input string conforms to the URN standard."
     ],
     "filename": "/ansible/plugins/test/urn.yml",
     "name": "urn",
     "options": {
      "_input": {
       "description": "Possible URN.",
       "required": true,
       "type": "string"
      }
     },
     "short_description": "is the string a valid URN",
     "version_added": "2.14",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "# ISBN in URN format\n{{ 'urn:isbn:9780302376463' is urn }}\n# this is URL/URI but not URN\n{{ 'mailto://nowone@example.com' is not urn }}\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(true) if the string is a URN and V(false) if  it is not.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.vault_encrypted": {
    "doc": {
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Verifies if the input is an Ansible vault."
     ],
     "filename": "/ansible/plugins/test/vault_encrypted.yml",
     "name": "truthy",
     "options": {
      "_input": {
       "description": "The possible vault.",
       "required": true,
       "type": "string"
      }
     },
     "short_description": "Is this an encrypted vault",
     "version_added": "2.10",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "thisisfalse: '{{ \"any string\" is ansible_vault }}'\nthisistrue: '{{ \"$ANSIBLE_VAULT;1.2;AES256;dev....\" is ansible_vault }}'\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) if the input is a valid ansible vault, V(False) otherwise.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.version": {
    "doc": {
     "aliases": [
      "version_compare"
     ],
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Compare version strings using various versioning schemes"
     ],
     "filename": "/ansible/plugins/test/version.yml",
     "name": "version",
     "notes": [
      "V(loose) - This type corresponds to the Python C(distutils.version.LooseVersion) class. All version formats are valid for this type. The rules for comparison are simple and predictable, but may not always give expected results.",
      "V(strict) - This type corresponds to the Python C(distutils.version.StrictVersion) class. A version number consists of two or three dot-separated numeric components, with an optional \"pre-release\" tag on the end. The pre-release tag consists of a single letter C(a) or C(b) followed by a number.  If the numeric components of two version numbers are equal, then one with a pre-release tag will always be deemed earlier (lesser) than one without.",
      "V(semver)/V(semantic) - This type implements the L(Semantic Version,https://semver.org) scheme for version comparison.",
      "V(pep440) - This type implements the Python L(PEP-440,https://peps.python.org/pep-0440/) versioning rules for version comparison. Added in version 2.14."
     ],
     "options": {
      "_input": {
       "description": "Left hand version to compare",
       "required": true,
       "type": "string"
      },
      "operator": {
       "choices": [
        "==",
        "=",
        "eq",
        "<",
        "lt",
        "<=",
        "le",
        ">",
        "gt",
        ">=",
        "ge",
        "!=",
        "<>",
        "ne"
       ],
       "default": "eq",
       "description": "Comparison operator",
       "required": false,
       "type": "string"
      },
      "strict": {
       "default": false,
       "description": "Whether to use strict version scheme. Mutually exclusive with O(version_type)",
       "required": false,
       "type": "boolean"
      },
      "version": {
       "description": "Right hand version to compare",
       "required": true,
       "type": "string"
      },
      "version_type": {
       "choices": [
        "loose",
        "strict",
        "semver",
        "semantic",
        "pep440"
       ],
       "default": "loose",
       "description": "Version scheme to use for comparison. Mutually exclusive with O(strict). See C(notes) for descriptions on the version types.",
       "required": false,
       "type": "string"
      }
     },
     "short_description": "compare version strings",
     "version_added": "1.6",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "- name: version test examples\n  assert:\n    that:\n      - \"'1.0' is version_compare('1.0', '==')\"  # old name\n      - \"'1.0' is version('1.0', '==')\"\n      - \"'1.0' is version('2.0', '!=')\"\n      - \"'1.0' is version('2.0', '<')\"\n      - \"'2.0' is version('1.0', '>')\"\n      - \"'1.0' is version('1.0', '<=')\"\n      - \"'1.0' is version('1.0', '>=')\"\n      - \"'1.0' is version_compare('1.0', '==', strict=true)\"  # old name\n      - \"'1.0' is version('1.0', '==', strict=true)\"\n      - \"'1.0' is version('2.0', '!=', strict=true)\"\n      - \"'1.0' is version('2.0', '<', strict=true)\"\n      - \"'2.0' is version('1.0', '>', strict=true)\"\n      - \"'1.0' is version('1.0', '<=', strict=true)\"\n      - \"'1.0' is version('1.0', '>=', strict=true)\"\n      - \"'1.2.3' is version('2.0.0', 'lt', version_type='semver')\"\n      - \"'2.14.0rc1' is version('2.14.0', 'lt', version_type='pep440')\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) or V(False) depending on the outcome of the comparison.",
      "type": "boolean"
     }
    }
   },
   "ansible.builtin.version_compare": {
    "doc": {
     "aliases": [
      "version_compare"
     ],
     "author": "Ansible Core",
     "collection": "ansible.builtin",
     "description": [
      "Compare version strings using various versioning schemes"
     ],
     "filename": "/ansible/plugins/test/version_compare.yml",
     "name": "version",
     "notes": [
      "V(loose) - This type corresponds to the Python C(distutils.version.LooseVersion) class. All version formats are valid for this type. The rules for comparison are simple and predictable, but may not always give expected results.",
      "V(strict) - This type corresponds to the Python C(distutils.version.StrictVersion) class. A version number consists of two or three dot-separated numeric components, with an optional \"pre-release\" tag on the end. The pre-release tag consists of a single letter C(a) or C(b) followed by a number.  If the numeric components of two version numbers are equal, then one with a pre-release tag will always be deemed earlier (lesser) than one without.",
      "V(semver)/V(semantic) - This type implements the L(Semantic Version,https://semver.org) scheme for version comparison.",
      "V(pep440) - This type implements the Python L(PEP-440,https://peps.python.org/pep-0440/) versioning rules for version comparison. Added in version 2.14."
     ],
     "options": {
      "_input": {
       "description": "Left hand version to compare",
       "required": true,
       "type": "string"
      },
      "operator": {
       "choices": [
        "==",
        "=",
        "eq",
        "<",
        "lt",
        "<=",
        "le",
        ">",
        "gt",
        ">=",
        "ge",
        "!=",
        "<>",
        "ne"
       ],
       "default": "eq",
       "description": "Comparison operator",
       "required": false,
       "type": "string"
      },
      "strict": {
       "default": false,
       "description": "Whether to use strict version scheme. Mutually exclusive with O(version_type)",
       "required": false,
       "type": "boolean"
      },
      "version": {
       "description": "Right hand version to compare",
       "required": true,
       "type": "string"
      },
      "version_type": {
       "choices": [
        "loose",
        "strict",
        "semver",
        "semantic",
        "pep440"
       ],
       "default": "loose",
       "description": "Version scheme to use for comparison. Mutually exclusive with O(strict). See C(notes) for descriptions on the version types.",
       "required": false,
       "type": "string"
      }
     },
     "short_description": "compare version strings",
     "version_added": "1.6",
     "version_added_collection": "ansible.builtin"
    },
    "examples": "- name: version test examples\n  assert:\n    that:\n      - \"'1.0' is version_compare('1.0', '==')\"  # old name\n      - \"'1.0' is version('1.0', '==')\"\n      - \"'1.0' is version('2.0', '!=')\"\n      - \"'1.0' is version('2.0', '<')\"\n      - \"'2.0' is version('1.0', '>')\"\n      - \"'1.0' is version('1.0', '<=')\"\n      - \"'1.0' is version('1.0', '>=')\"\n      - \"'1.0' is version_compare('1.0', '==', strict=true)\"  # old name\n      - \"'1.0' is version('1.0', '==', strict=true)\"\n      - \"'1.0' is version('2.0', '!=', strict=true)\"\n      - \"'1.0' is version('2.0', '<', strict=true)\"\n      - \"'2.0' is version('1.0', '>', strict=true)\"\n      - \"'1.0' is version('1.0', '<=', strict=true)\"\n      - \"'1.0' is version('1.0', '>=', strict=true)\"\n      - \"'1.2.3' is version('2.0.0', 'lt', version_type='semver')\"\n      - \"'2.14.0rc1' is version('2.14.0', 'lt', version_type='pep440')\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns V(True) or V(False) depending on the outcome of the comparison.",
      "type": "boolean"
     }
    }
   },
   "ns2.col.bar": {
    "doc": {
     "aliases": [
      "is_bar"
     ],
     "author": "Ansible Core",
     "collection": "ns2.col",
     "description": [
      "Check whether a path is a bar."
     ],
     "filename": "ansible_collections/ns2/col/plugins/test/bar.yml",
     "name": "bar",
     "options": {
      "_input": {
       "description": "A path.",
       "type": "path"
      }
     },
     "short_description": "Is something a bar"
    },
    "examples": "is_path_bar: \"{{ '/etc/hosts' is ns2.col.bar }}}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns C(true) if the path is a bar, C(false) if it is not a bar.",
      "type": "boolean"
     }
    }
   },
   "ns2.col.foo": {
    "doc": {
     "author": "Nobody",
     "collection": "ns2.col",
     "description": [
      "Check whether the input dictionary is a foo."
     ],
     "filename": "ansible_collections/ns2/col/plugins/test/foo.py",
     "name": "foo",
     "options": {
      "_input": {
       "description": "Something to test.",
       "required": true,
       "type": "dictionary"
      },
      "bar": {
       "description": "Foo bar.",
       "type": "string"
      }
     },
     "short_description": "Is something a foo O(bar)"
    },
    "examples": "\nsome_var: \"{{ {'a': 1} is ns2.col.foo }}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Whether the input is a foo.",
      "type": "boolean"
     }
    }
   },
   "ns2.col.is_bar": {
    "doc": {
     "aliases": [
      "is_bar"
     ],
     "author": "Ansible Core",
     "collection": "ns2.col",
     "description": [
      "Check whether a path is a bar."
     ],
     "filename": "ansible_collections/ns2/col/plugins/test/is_bar.yml",
     "name": "bar",
     "options": {
      "_input": {
       "description": "A path.",
       "type": "path"
      }
     },
     "short_description": "Is something a bar"
    },
    "examples": "is_path_bar: \"{{ '/etc/hosts' is ns2.col.bar }}}\"\n",
    "metadata": null,
    "return": {
     "_value": {
      "description": "Returns C(true) if the path is a bar, C(false) if it is not a bar.",
      "type": "boolean"
     }
    }
   }
  },
  "vars": {
   "ansible.builtin.host_group_vars": {
    "doc": {
     "collection": "ansible.builtin",
     "description": [
      "Loads YAML vars into corresponding groups/hosts in group_vars/ and host_vars/ directories.",
      "Files are restricted by extension to one of .yaml, .json, .yml or no extension.",
      "Hidden (starting with '.') and backup (ending with '~') files and directories are ignored.",
      "Only applies to inventory sources that are existing paths.",
      "Starting in 2.10, this plugin requires enabling and is enabled by default."
     ],
     "filename": "/ansible/plugins/vars/host_group_vars.py",
     "name": "host_group_vars",
     "options": {
      "_valid_extensions": {
       "default": [
        ".yml",
        ".yaml",
        ".json"
       ],
       "description": [
        "Check all of these extensions when looking for 'variable' files which should be YAML or JSON or vaulted versions of these.",
        "This affects vars_files, include_vars, inventory and vars plugins among others."
       ],
       "elements": "string",
       "env": [
        {
         "name": "ANSIBLE_YAML_FILENAME_EXT"
        }
       ],
       "ini": [
        {
         "key": "yaml_valid_extensions",
         "section": "defaults"
        }
       ],
       "type": "list"
      },
      "stage": {
       "choices": [
        "all",
        "task",
        "inventory"
       ],
       "description": [
        "Control when this vars plugin may be executed.",
        "Setting this option to V(all) will run the vars plugin after importing inventory and whenever it is demanded by a task.",
        "Setting this option to V(task) will only run the vars plugin whenever it is demanded by a task.",
        "Setting this option to V(inventory) will only run the vars plugin after parsing inventory.",
        "If this option is omitted, the global C(RUN_VARS_PLUGINS) configuration is used to determine when to execute the vars plugin."
       ],
       "env": [
        {
         "name": "ANSIBLE_VARS_PLUGIN_STAGE"
        }
       ],
       "ini": [
        {
         "key": "stage",
         "section": "vars_host_group_vars"
        }
       ],
       "type": "str",
       "version_added": "2.10",
       "version_added_collection": "ansible.builtin"
      }
     },
     "requirements": [
      "Enabled in configuration"
     ],
     "short_description": "In charge of loading group_vars and host_vars",
     "version_added": "2.4",
     "version_added_collection": "ansible.builtin"
    },
    "examples": null,
    "metadata": null,
    "return": null
   },
   "ns2.col.foo": {
    "doc": {
     "collection": "ns2.col",
     "description": [
      "Load some foo.",
      "This is so glorious."
     ],
     "filename": "ansible_collections/ns2/col/plugins/vars/foo.py",
     "name": "foo",
     "options": {
      "_valid_extensions": {
       "default": [
        ".foo",
        ".foobar"
       ],
       "description": [
        "All extensions to check."
       ],
       "elements": "string",
       "env": [
        {
         "name": "ANSIBLE_FOO_FILENAME_EXT"
        }
       ],
       "ini": [
        {
         "key": "foo_valid_extensions",
         "section": "defaults"
        }
       ],
       "type": "list"
      },
      "bar": {
       "description": "Foo bar.",
       "type": "string"
      }
     },
     "requirements": [
      "Enabled in Ansible's configuration."
     ],
     "short_description": "Load foo O(bar)",
     "version_added": "0.9.0",
     "version_added_collection": "ns2.col"
    },
    "examples": null,
    "metadata": null,
    "return": null
   }
  }
 }
}